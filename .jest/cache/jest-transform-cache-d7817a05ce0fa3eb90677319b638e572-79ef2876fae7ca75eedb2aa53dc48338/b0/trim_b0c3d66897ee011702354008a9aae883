992fc147964e6fd86373ee878f739cd3
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const _baseToString_js_1 = __importDefault(require("./_baseToString.js"));
const _baseTrim_js_1 = __importDefault(require("./_baseTrim.js"));
const _castSlice_js_1 = __importDefault(require("./_castSlice.js"));
const _charsEndIndex_js_1 = __importDefault(require("./_charsEndIndex.js"));
const _charsStartIndex_js_1 = __importDefault(require("./_charsStartIndex.js"));
const _stringToArray_js_1 = __importDefault(require("./_stringToArray.js"));
const toString_js_1 = __importDefault(require("./toString.js"));
/**
 * Removes leading and trailing whitespace or specified characters from `string`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to trim.
 * @param {string} [chars=whitespace] The characters to trim.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {string} Returns the trimmed string.
 * @example
 *
 * _.trim('  abc  ');
 * // => 'abc'
 *
 * _.trim('-_-abc-_-', '_-');
 * // => 'abc'
 *
 * _.map(['  foo  ', '  bar  '], _.trim);
 * // => ['foo', 'bar']
 */
function trim(string, chars, guard) {
    string = (0, toString_js_1.default)(string);
    if (string && (guard || chars === undefined)) {
        return (0, _baseTrim_js_1.default)(string);
    }
    if (!string || !(chars = (0, _baseToString_js_1.default)(chars))) {
        return string;
    }
    var strSymbols = (0, _stringToArray_js_1.default)(string), chrSymbols = (0, _stringToArray_js_1.default)(chars), start = (0, _charsStartIndex_js_1.default)(strSymbols, chrSymbols), end = (0, _charsEndIndex_js_1.default)(strSymbols, chrSymbols) + 1;
    return (0, _castSlice_js_1.default)(strSymbols, start, end).join('');
}
exports.default = trim;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL21hY2Jvb2sva2FycG92LXdvcmsvVHJ1ZU5BUy93ZWJ1aS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RyaW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSwwRUFBOEM7QUFDOUMsa0VBQXNDO0FBQ3RDLG9FQUF3QztBQUN4Qyw0RUFBZ0Q7QUFDaEQsZ0ZBQW9EO0FBQ3BELDRFQUFnRDtBQUNoRCxnRUFBcUM7QUFFckM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFCRztBQUNILFNBQVMsSUFBSSxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsS0FBSztJQUNoQyxNQUFNLEdBQUcsSUFBQSxxQkFBUSxFQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzFCLElBQUksTUFBTSxJQUFJLENBQUMsS0FBSyxJQUFJLEtBQUssS0FBSyxTQUFTLENBQUMsRUFBRSxDQUFDO1FBQzdDLE9BQU8sSUFBQSxzQkFBUSxFQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFDRCxJQUFJLENBQUMsTUFBTSxJQUFJLENBQUMsQ0FBQyxLQUFLLEdBQUcsSUFBQSwwQkFBWSxFQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUM5QyxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBQ0QsSUFBSSxVQUFVLEdBQUcsSUFBQSwyQkFBYSxFQUFDLE1BQU0sQ0FBQyxFQUNsQyxVQUFVLEdBQUcsSUFBQSwyQkFBYSxFQUFDLEtBQUssQ0FBQyxFQUNqQyxLQUFLLEdBQUcsSUFBQSw2QkFBZSxFQUFDLFVBQVUsRUFBRSxVQUFVLENBQUMsRUFDL0MsR0FBRyxHQUFHLElBQUEsMkJBQWEsRUFBQyxVQUFVLEVBQUUsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBRXBELE9BQU8sSUFBQSx1QkFBUyxFQUFDLFVBQVUsRUFBRSxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3BELENBQUM7QUFFRCxrQkFBZSxJQUFJLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL21hY2Jvb2sva2FycG92LXdvcmsvVHJ1ZU5BUy93ZWJ1aS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RyaW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGJhc2VUb1N0cmluZyBmcm9tICcuL19iYXNlVG9TdHJpbmcuanMnO1xuaW1wb3J0IGJhc2VUcmltIGZyb20gJy4vX2Jhc2VUcmltLmpzJztcbmltcG9ydCBjYXN0U2xpY2UgZnJvbSAnLi9fY2FzdFNsaWNlLmpzJztcbmltcG9ydCBjaGFyc0VuZEluZGV4IGZyb20gJy4vX2NoYXJzRW5kSW5kZXguanMnO1xuaW1wb3J0IGNoYXJzU3RhcnRJbmRleCBmcm9tICcuL19jaGFyc1N0YXJ0SW5kZXguanMnO1xuaW1wb3J0IHN0cmluZ1RvQXJyYXkgZnJvbSAnLi9fc3RyaW5nVG9BcnJheS5qcyc7XG5pbXBvcnQgdG9TdHJpbmcgZnJvbSAnLi90b1N0cmluZy5qcyc7XG5cbi8qKlxuICogUmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50cmltKCcgIGFiYyAgJyk7XG4gKiAvLyA9PiAnYWJjJ1xuICpcbiAqIF8udHJpbSgnLV8tYWJjLV8tJywgJ18tJyk7XG4gKiAvLyA9PiAnYWJjJ1xuICpcbiAqIF8ubWFwKFsnICBmb28gICcsICcgIGJhciAgJ10sIF8udHJpbSk7XG4gKiAvLyA9PiBbJ2ZvbycsICdiYXInXVxuICovXG5mdW5jdGlvbiB0cmltKHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgcmV0dXJuIGJhc2VUcmltKHN0cmluZyk7XG4gIH1cbiAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcbiAgICAgIGNoclN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KGNoYXJzKSxcbiAgICAgIHN0YXJ0ID0gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpLFxuICAgICAgZW5kID0gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSArIDE7XG5cbiAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCBzdGFydCwgZW5kKS5qb2luKCcnKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdHJpbTtcbiJdLCJ2ZXJzaW9uIjozfQ==