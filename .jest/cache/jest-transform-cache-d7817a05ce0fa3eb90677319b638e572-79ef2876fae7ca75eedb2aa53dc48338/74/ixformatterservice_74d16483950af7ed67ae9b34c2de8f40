fa1f53c61a6dbc3b3d0fbbde94556d27
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IxFormatterService = void 0;
const core_1 = require("@angular/core");
const window_helper_1 = require("app/helpers/window.helper");
let IxFormatterService = class IxFormatterService {
    constructor(window) {
        var _a, _b;
        this.window = window;
        this.protocol = ((_b = (_a = this.window) === null || _a === void 0 ? void 0 : _a.location) === null || _b === void 0 ? void 0 : _b.protocol) || 'http:';
        this.iecUnits = ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB'];
        /**
         * Formats any memory size in bytes to human readable string, e.g., '2147483648' to '2 GiB'
         * @param value The string to be formatted
         * @returns Formatted string
         */
        this.memorySizeFormatting = (value) => {
            if (!value) {
                return '';
            }
            value = value.toString();
            return !value || Number.isNaN(Number(value)) ? '' : this.convertBytesToHumanReadable(value, 2);
        };
        /**
         * Parses passed in human readable memory size string into a normalized value.
         * If no units are provided, MiB is used as default unit
         * @param value The value to be parsed
         * @returns The parsed value
         */
        this.memorySizeParsing = (value, postfix) => {
            if (!value) {
                return null;
            }
            const finalValue = `${value} ${!Number(value) ? '' : postfix || ''}`.trim();
            const humanStringToNum = this.convertHumanStringToNum(finalValue, true);
            // Default unit is MiB so if the user passed in no unit, we assume unit is MiB
            return (humanStringToNum !== Number(finalValue)) ? humanStringToNum : this.convertHumanStringToNum(finalValue + 'mb', true);
        };
        /**
         * Converts a number from bytes to the most natural human readable format
         * @param rawBytes Bytes to be converted
         * @param decimalPlaces Number of decimal places that the final value should be rounded off to
         * @param minUnits If no unit is provided, what minimum base unit should be assumed
         * @param hideBytes If the value is in bytes, should the 'B' sign be added
         * @returns A human readable string with appropriate units
         */
        this.convertBytesToHumanReadable = (rawBytes, decimalPlaces, minUnits, hideBytes) => {
            let i = 0;
            let units;
            let bytes = Number(rawBytes);
            const dec = decimalPlaces !== undefined ? decimalPlaces : 2;
            if (bytes >= 1024) {
                do {
                    bytes = bytes / 1024;
                    i++;
                } while (bytes >= 1024 && i < 4);
                units = this.iecUnits[i];
            }
            else if (minUnits) {
                units = minUnits;
            }
            else {
                units = hideBytes ? '' : 'B';
            }
            return `${parseFloat(bytes.toFixed(dec))} ${units}`;
        };
        /**
         * Converts a human readable size string with units into bytes. Any invalid letters result in null returned
         * @param hstr The string to be converted
         * @param dec Does the passed string has a decimal point values
         * @param allowedUnits allowedUnits should include any or all of 'bkmgtp', the first letters of KiB, Mib, etc.
         * The first letter is used as the default, so for 'gtp', an entered value of 256 becomes 256 GiB.
         * If you don't pass in allowedUnits, all of the above are accepted AND no unit is attached to an unlabeled number,
         * so 256 is considered 256 bytes.
         * @returns The passed human readable string converted into number of bytes
         */
        this.convertHumanStringToNum = (hstr, dec = false, allowedUnits) => {
            const { unit, number } = this.getNumberAndUnitFromHumanString(hstr, dec, allowedUnits);
            return number === null ? null : Number(number) * this.convertUnitToNum(unit);
        };
        /**
         * Normalize short units ("MB") or human units ("M") to IEC units ("MiB")
         * @param unitStr The unit string to be normalized
         * @returns Normalized unit string based on the passed value
         */
        this.normalizeUnit = (unitStr) => {
            // empty unit is valid, just return
            if (!unitStr) {
                return '';
            }
            const iecUnitsStr = this.iecUnits.join('|');
            const shortUnitsStr = this.iecUnits.map((unit) => {
                if (unit.length > 1) {
                    return unit.charAt(0) + unit.charAt(2);
                }
                return 'BYTES';
            }).join('|');
            const humanUnitsStr = this.iecUnits.map((unit) => unit.charAt(0)).join('|');
            const allUnitsStr = (iecUnitsStr + '|' + shortUnitsStr + '|' + humanUnitsStr).toUpperCase();
            const unitsRe = new RegExp('^\\s*(' + allUnitsStr + '){1}\\s*$');
            unitStr = unitStr.toUpperCase();
            if (unitStr.match(unitsRe)) {
                // always return IEC units
                // could take a parameter to return short or human units
                if (unitStr.toLowerCase() === 'b' || unitStr.toLowerCase() === 'bytes') {
                    return 'B';
                }
                return unitStr.charAt(0).toUpperCase() + 'iB';
            }
            return undefined;
        };
        /**
         * Convert IEC ("MiB"), short ("MB"), or human ("M") units to number of bytes. Unknown units are evaluated as 1
         * @param unitStr The unit string to be converted
         * @returns Number of bytes
         */
        this.convertUnitToNum = (unitStr) => {
            unitStr = this.normalizeUnit(unitStr);
            if (!unitStr) {
                return 1;
            }
            return (1024 ** (this.iecUnits.indexOf(unitStr)));
        };
        this.stringAsUrlParsing = (value) => {
            if (value.startsWith('http')) {
                return value;
            }
            return `${this.protocol}//${value}`;
        };
    }
    /**
     * Converts passed in human readable string into two parts. The digit value in numbers and the unit that's applied.
     * @param hstr The human readable size string
     * @param dec Does the value has decimal point values
     * @param allowedUnits allowedUnits should include any or all of 'bkmgtp', the first letters of KiB, Mib, etc.
     * The first letter is used as the default, so for 'gtp', an entered value of 256 becomes 256 GiB.
     * If you don't pass in allowedUnits, all of the above are accepted AND no unit is attached to an unlabeled number,
     * so 256 is considered 256 bytes.
     * @returns The passed human readable string converted into number and unit seperately
     */
    getNumberAndUnitFromHumanString(hstr, dec = false, allowedUnits) {
        let num;
        let unit = '';
        // empty value is evaluated as zero
        if (!hstr) {
            return { number: null, unit: null };
        }
        // remove whitespace
        hstr = hstr.replace(/\s+/g, '');
        // get leading number
        let match = [];
        if (dec) {
            match = hstr.match(/^(\d+(\.\d+)?)/);
        }
        else {
            match = hstr.match(/^(\d+)/);
        }
        if (match && match.length > 1) {
            num = match[1];
        }
        else {
            // leading number is required
            return { number: null, unit: null };
        }
        // get optional unit
        unit = hstr.replace(num, '');
        if (!unit && allowedUnits) {
            unit = allowedUnits[0];
        }
        const normalizedUnit = this.normalizeUnit(unit);
        if (
        // error when unit is present and...
        (unit) && (
        // ...allowedUnits are passed in but unit is not in allowed Units
        (allowedUnits && !allowedUnits.toLowerCase().includes(unit[0].toLowerCase()))
            // ...when allowedUnits are not passed in and unit is not recognized
            || !normalizedUnit)) {
            return { number: null, unit: null };
        }
        return { number: num, unit: normalizedUnit };
    }
};
exports.IxFormatterService = IxFormatterService;
IxFormatterService.ctorParameters = () => [
    { type: Window, decorators: [{ type: core_1.Inject, args: [window_helper_1.WINDOW,] }] }
];
exports.IxFormatterService = IxFormatterService = __decorate([
    (0, core_1.Injectable)({ providedIn: 'root' })
], IxFormatterService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL21hY2Jvb2sva2FycG92LXdvcmsvVHJ1ZU5BUy93ZWJ1aS9zcmMvYXBwL21vZHVsZXMvZm9ybXMvaXgtZm9ybXMvc2VydmljZXMvaXgtZm9ybWF0dGVyLnNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsd0NBQW1EO0FBQ25ELDZEQUFtRDtBQUc1QyxJQUFNLGtCQUFrQixHQUF4QixNQUFNLGtCQUFrQjtJQUk3QixZQUFvQyxNQUFjOztRQUFkLFdBQU0sR0FBTixNQUFNLENBQVE7UUFIekMsYUFBUSxHQUFHLENBQUEsTUFBQSxNQUFBLElBQUksQ0FBQyxNQUFNLDBDQUFFLFFBQVEsMENBQUUsUUFBUSxLQUFJLE9BQU8sQ0FBQztRQUN0RCxhQUFRLEdBQXNCLENBQUMsR0FBRyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztRQUloRjs7OztXQUlHO1FBQ0gseUJBQW9CLEdBQXFDLENBQUMsS0FBc0IsRUFBRSxFQUFFO1lBQ2xGLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztnQkFDWCxPQUFPLEVBQUUsQ0FBQztZQUNaLENBQUM7WUFDRCxLQUFLLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ3pCLE9BQU8sQ0FBQyxLQUFLLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsMkJBQTJCLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ2pHLENBQUMsQ0FBQztRQUVGOzs7OztXQUtHO1FBQ0gsc0JBQWlCLEdBQW1ELENBQUMsS0FBYSxFQUFFLE9BQWUsRUFBRSxFQUFFO1lBQ3JHLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztnQkFDWCxPQUFPLElBQUksQ0FBQztZQUNkLENBQUM7WUFFRCxNQUFNLFVBQVUsR0FBRyxHQUFHLEtBQUssSUFBSSxDQUFDLE1B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Q0FBQyxDQUFDLENBQUM7UUFDakIsQ0FBQzthQUFNLENBQUM7WUFDTiw2QkFBNkI7WUFDN0IsT0FBTyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDO1FBQ3RDLENBQUM7UUFFRCxvQkFBb0I7UUFDcEIsSUFBSSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQzdCLElBQUksQ0FBQyxJQUFJLElBQUksWUFBWSxFQUFFLENBQUM7WUFDMUIsSUFBSSxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN6QixDQUFDO1FBRUQsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNoRDtRQUNFLG9DQUFvQztRQUNwQyxDQUFDLElBQUksQ0FBQyxJQUFJO1FBQ1IsaUVBQWlFO1FBQ2pFLENBQUMsWUFBWSxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztZQUM3RSxvRUFBb0U7ZUFDakUsQ0FBQyxjQUFjLENBQ25CLEVBQ0QsQ0FBQztZQUNELE9BQU8sRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQztRQUN0QyxDQUFDO1FBQ0QsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLGNBQWMsRUFBRSxDQUFDO0lBQy9DLENBQUM7O0FBckpVLGdEQUFrQjs7eUNBSWhCLGFBQU0sU0FBQyxzQkFBTTs7NkJBSmYsa0JBQWtCO0lBRDlCLElBQUEsaUJBQVUsRUFBQyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsQ0FBQztHQUN0QixrQkFBa0IsQ0E4TTlCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNib29rL2thcnBvdi13b3JrL1RydWVOQVMvd2VidWkvc3JjL2FwcC9tb2R1bGVzL2Zvcm1zL2l4LWZvcm1zL3NlcnZpY2VzL2l4LWZvcm1hdHRlci5zZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgV0lORE9XIH0gZnJvbSAnYXBwL2hlbHBlcnMvd2luZG93LmhlbHBlcic7XG5cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgSXhGb3JtYXR0ZXJTZXJ2aWNlIHtcbiAgcmVhZG9ubHkgcHJvdG9jb2wgPSB0aGlzLndpbmRvdz8ubG9jYXRpb24/LnByb3RvY29sIHx8ICdodHRwOic7XG4gIHJlYWRvbmx5IGllY1VuaXRzOiByZWFkb25seSBzdHJpbmdbXSA9IFsnQicsICdLaUInLCAnTWlCJywgJ0dpQicsICdUaUInLCAnUGlCJ107XG5cbiAgY29uc3RydWN0b3IoQEluamVjdChXSU5ET1cpIHByaXZhdGUgd2luZG93OiBXaW5kb3cpIHt9XG5cbiAgLyoqXG4gICAqIEZvcm1hdHMgYW55IG1lbW9yeSBzaXplIGluIGJ5dGVzIHRvIGh1bWFuIHJlYWRhYmxlIHN0cmluZywgZS5nLiwgJzIxNDc0ODM2NDgnIHRvICcyIEdpQidcbiAgICogQHBhcmFtIHZhbHVlIFRoZSBzdHJpbmcgdG8gYmUgZm9ybWF0dGVkXG4gICAqIEByZXR1cm5zIEZvcm1hdHRlZCBzdHJpbmdcbiAgICovXG4gIG1lbW9yeVNpemVGb3JtYXR0aW5nOiAodmFsOiBzdHJpbmcgfCBudW1iZXIpID0+IHN0cmluZyA9ICh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKSA9PiB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuICF2YWx1ZSB8fCBOdW1iZXIuaXNOYU4oTnVtYmVyKHZhbHVlKSkgPyAnJyA6IHRoaXMuY29udmVydEJ5dGVzVG9IdW1hblJlYWRhYmxlKHZhbHVlLCAyKTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2VzIHBhc3NlZCBpbiBodW1hbiByZWFkYWJsZSBtZW1vcnkgc2l6ZSBzdHJpbmcgaW50byBhIG5vcm1hbGl6ZWQgdmFsdWUuXG4gICAqIElmIG5vIHVuaXRzIGFyZSBwcm92aWRlZCwgTWlCIGlzIHVzZWQgYXMgZGVmYXVsdCB1bml0XG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgcGFyc2VkXG4gICAqIEByZXR1cm5zIFRoZSBwYXJzZWQgdmFsdWVcbiAgICovXG4gIG1lbW9yeVNpemVQYXJzaW5nOiAodmFsOiBzdHJpbmcsIHBvc3RmaXhWYWx1ZT86IHN0cmluZykgPT4gbnVtYmVyID0gKHZhbHVlOiBzdHJpbmcsIHBvc3RmaXg6IHN0cmluZykgPT4ge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGZpbmFsVmFsdWUgPSBgJHt2YWx1ZX0gJHshTnVtYmVyKHZhbHVlKSA/ICcnIDogcG9zdGZpeCB8fCAnJ31gLnRyaW0oKTtcbiAgICBjb25zdCBodW1hblN0cmluZ1RvTnVtID0gdGhpcy5jb252ZXJ0SHVtYW5TdHJpbmdUb051bShmaW5hbFZhbHVlLCB0cnVlKTtcblxuICAgIC8vIERlZmF1bHQgdW5pdCBpcyBNaUIgc28gaWYgdGhlIHVzZXIgcGFzc2VkIGluIG5vIHVuaXQsIHdlIGFzc3VtZSB1bml0IGlzIE1pQlxuICAgIHJldHVybiAoaHVtYW5TdHJpbmdUb051bSAhPT0gTnVtYmVyKGZpbmFsVmFsdWUpKSA/IGh1bWFuU3RyaW5nVG9OdW0gOiB0aGlzLmNvbnZlcnRIdW1hblN0cmluZ1RvTnVtKGZpbmFsVmFsdWUgKyAnbWInLCB0cnVlKTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydHMgYSBudW1iZXIgZnJvbSBieXRlcyB0byB0aGUgbW9zdCBuYXR1cmFsIGh1bWFuIHJlYWRhYmxlIGZvcm1hdFxuICAgKiBAcGFyYW0gcmF3Qnl0ZXMgQnl0ZXMgdG8gYmUgY29udmVydGVkXG4gICAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGF0IHRoZSBmaW5hbCB2YWx1ZSBzaG91bGQgYmUgcm91bmRlZCBvZmYgdG9cbiAgICogQHBhcmFtIG1pblVuaXRzIElmIG5vIHVuaXQgaXMgcHJvdmlkZWQsIHdoYXQgbWluaW11bSBiYXNlIHVuaXQgc2hvdWxkIGJlIGFzc3VtZWRcbiAgICogQHBhcmFtIGhpZGVCeXRlcyBJZiB0aGUgdmFsdWUgaXMgaW4gYnl0ZXMsIHNob3VsZCB0aGUgJ0InIHNpZ24gYmUgYWRkZWRcbiAgICogQHJldHVybnMgQSBodW1hbiByZWFkYWJsZSBzdHJpbmcgd2l0aCBhcHByb3ByaWF0ZSB1bml0c1xuICAgKi9cbiAgY29udmVydEJ5dGVzVG9IdW1hblJlYWRhYmxlID0gKFxuICAgIHJhd0J5dGVzOiBudW1iZXIgfCBzdHJpbmcsXG4gICAgZGVjaW1hbFBsYWNlcz86IG51bWJlcixcbiAgICBtaW5Vbml0cz86IHN0cmluZyxcbiAgICBoaWRlQnl0ZXM/OiBib29sZWFuLFxuICApOiBzdHJpbmcgPT4ge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgdW5pdHM7XG4gICAgbGV0IGJ5dGVzID0gTnVtYmVyKHJhd0J5dGVzKTtcblxuICAgIGNvbnN0IGRlYyA9IGRlY2ltYWxQbGFjZXMgIT09IHVuZGVmaW5lZCA/IGRlY2ltYWxQbGFjZXMgOiAyO1xuICAgIGlmIChieXRlcyA+PSAxMDI0KSB7XG4gICAgICBkbyB7XG4gICAgICAgIGJ5dGVzID0gYnl0ZXMgLyAxMDI0O1xuICAgICAgICBpKys7XG4gICAgICB9IHdoaWxlIChieXRlcyA+PSAxMDI0ICYmIGkgPCA0KTtcbiAgICAgIHVuaXRzID0gdGhpcy5pZWNVbml0c1tpXTtcbiAgICB9IGVsc2UgaWYgKG1pblVuaXRzKSB7XG4gICAgICB1bml0cyA9IG1pblVuaXRzO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bml0cyA9IGhpZGVCeXRlcyA/ICcnIDogJ0InO1xuICAgIH1cbiAgICByZXR1cm4gYCR7cGFyc2VGbG9hdChieXRlcy50b0ZpeGVkKGRlYykpfSAke3VuaXRzfWA7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgaHVtYW4gcmVhZGFibGUgc2l6ZSBzdHJpbmcgd2l0aCB1bml0cyBpbnRvIGJ5dGVzLiBBbnkgaW52YWxpZCBsZXR0ZXJzIHJlc3VsdCBpbiBudWxsIHJldHVybmVkXG4gICAqIEBwYXJhbSBoc3RyIFRoZSBzdHJpbmcgdG8gYmUgY29udmVydGVkXG4gICAqIEBwYXJhbSBkZWMgRG9lcyB0aGUgcGFzc2VkIHN0cmluZyBoYXMgYSBkZWNpbWFsIHBvaW50IHZhbHVlc1xuICAgKiBAcGFyYW0gYWxsb3dlZFVuaXRzIGFsbG93ZWRVbml0cyBzaG91bGQgaW5jbHVkZSBhbnkgb3IgYWxsIG9mICdia21ndHAnLCB0aGUgZmlyc3QgbGV0dGVycyBvZiBLaUIsIE1pYiwgZXRjLlxuICAgKiBUaGUgZmlyc3QgbGV0dGVyIGlzIHVzZWQgYXMgdGhlIGRlZmF1bHQsIHNvIGZvciAnZ3RwJywgYW4gZW50ZXJlZCB2YWx1ZSBvZiAyNTYgYmVjb21lcyAyNTYgR2lCLlxuICAgKiBJZiB5b3UgZG9uJ3QgcGFzcyBpbiBhbGxvd2VkVW5pdHMsIGFsbCBvZiB0aGUgYWJvdmUgYXJlIGFjY2VwdGVkIEFORCBubyB1bml0IGlzIGF0dGFjaGVkIHRvIGFuIHVubGFiZWxlZCBudW1iZXIsXG4gICAqIHNvIDI1NiBpcyBjb25zaWRlcmVkIDI1NiBieXRlcy5cbiAgICogQHJldHVybnMgVGhlIHBhc3NlZCBodW1hbiByZWFkYWJsZSBzdHJpbmcgY29udmVydGVkIGludG8gbnVtYmVyIG9mIGJ5dGVzXG4gICAqL1xuICBjb252ZXJ0SHVtYW5TdHJpbmdUb051bSA9IChcbiAgICBoc3RyOiBzdHJpbmcsXG4gICAgZGVjID0gZmFsc2UsXG4gICAgYWxsb3dlZFVuaXRzPzogJ2JrbWd0cCcgfCAna21ndHAnIHwgJ21ndHAnIHwgJ2d0cCcgfCAndHAnIHwgJ3AnLFxuICApOiBudW1iZXIgPT4ge1xuICAgIGNvbnN0IHsgdW5pdCwgbnVtYmVyIH0gPSB0aGlzLmdldE51bWJlckFuZFVuaXRGcm9tSHVtYW5TdHJpbmcoaHN0ciwgZGVjLCBhbGxvd2VkVW5pdHMpO1xuXG4gICAgcmV0dXJuIG51bWJlciA9PT0gbnVsbCA/IG51bGwgOiBOdW1iZXIobnVtYmVyKSAqIHRoaXMuY29udmVydFVuaXRUb051bSh1bml0KTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydHMgcGFzc2VkIGluIGh1bWFuIHJlYWRhYmxlIHN0cmluZyBpbnRvIHR3byBwYXJ0cy4gVGhlIGRpZ2l0IHZhbHVlIGluIG51bWJlcnMgYW5kIHRoZSB1bml0IHRoYXQncyBhcHBsaWVkLlxuICAgKiBAcGFyYW0gaHN0ciBUaGUgaHVtYW4gcmVhZGFibGUgc2l6ZSBzdHJpbmdcbiAgICogQHBhcmFtIGRlYyBEb2VzIHRoZSB2YWx1ZSBoYXMgZGVjaW1hbCBwb2ludCB2YWx1ZXNcbiAgICogQHBhcmFtIGFsbG93ZWRVbml0cyBhbGxvd2VkVW5pdHMgc2hvdWxkIGluY2x1ZGUgYW55IG9yIGFsbCBvZiAnYmttZ3RwJywgdGhlIGZpcnN0IGxldHRlcnMgb2YgS2lCLCBNaWIsIGV0Yy5cbiAgICogVGhlIGZpcnN0IGxldHRlciBpcyB1c2VkIGFzIHRoZSBkZWZhdWx0LCBzbyBmb3IgJ2d0cCcsIGFuIGVudGVyZWQgdmFsdWUgb2YgMjU2IGJlY29tZXMgMjU2IEdpQi5cbiAgICogSWYgeW91IGRvbid0IHBhc3MgaW4gYWxsb3dlZFVuaXRzLCBhbGwgb2YgdGhlIGFib3ZlIGFyZSBhY2NlcHRlZCBBTkQgbm8gdW5pdCBpcyBhdHRhY2hlZCB0byBhbiB1bmxhYmVsZWQgbnVtYmVyLFxuICAgKiBzbyAyNTYgaXMgY29uc2lkZXJlZCAyNTYgYnl0ZXMuXG4gICAqIEByZXR1cm5zIFRoZSBwYXNzZWQgaHVtYW4gcmVhZGFibGUgc3RyaW5nIGNvbnZlcnRlZCBpbnRvIG51bWJlciBhbmQgdW5pdCBzZXBlcmF0ZWx5XG4gICAqL1xuICBnZXROdW1iZXJBbmRVbml0RnJvbUh1bWFuU3RyaW5nKFxuICAgIGhzdHI6IHN0cmluZyxcbiAgICBkZWMgPSBmYWxzZSxcbiAgICBhbGxvd2VkVW5pdHM/OiAnYmttZ3RwJyB8ICdrbWd0cCcgfCAnbWd0cCcgfCAnZ3RwJyB8ICd0cCcgfCAncCcsXG4gICk6IHsgbnVtYmVyOiBzdHJpbmc7IHVuaXQ6IHN0cmluZyB9IHtcbiAgICBsZXQgbnVtO1xuICAgIGxldCB1bml0ID0gJyc7XG5cbiAgICAvLyBlbXB0eSB2YWx1ZSBpcyBldmFsdWF0ZWQgYXMgemVyb1xuICAgIGlmICghaHN0cikge1xuICAgICAgcmV0dXJuIHsgbnVtYmVyOiBudWxsLCB1bml0OiBudWxsIH07XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHdoaXRlc3BhY2VcbiAgICBoc3RyID0gaHN0ci5yZXBsYWNlKC9cXHMrL2csICcnKTtcblxuICAgIC8vIGdldCBsZWFkaW5nIG51bWJlclxuICAgIGxldCBtYXRjaCA9IFtdO1xuICAgIGlmIChkZWMpIHtcbiAgICAgIG1hdGNoID0gaHN0ci5tYXRjaCgvXihcXGQrKFxcLlxcZCspPykvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF0Y2ggPSBoc3RyLm1hdGNoKC9eKFxcZCspLyk7XG4gICAgfVxuICAgIGlmIChtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICBudW0gPSBtYXRjaFsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbGVhZGluZyBudW1iZXIgaXMgcmVxdWlyZWRcbiAgICAgIHJldHVybiB7IG51bWJlcjogbnVsbCwgdW5pdDogbnVsbCB9O1xuICAgIH1cblxuICAgIC8vIGdldCBvcHRpb25hbCB1bml0XG4gICAgdW5pdCA9IGhzdHIucmVwbGFjZShudW0sICcnKTtcbiAgICBpZiAoIXVuaXQgJiYgYWxsb3dlZFVuaXRzKSB7XG4gICAgICB1bml0ID0gYWxsb3dlZFVuaXRzWzBdO1xuICAgIH1cblxuICAgIGNvbnN0IG5vcm1hbGl6ZWRVbml0ID0gdGhpcy5ub3JtYWxpemVVbml0KHVuaXQpO1xuICAgIGlmIChcbiAgICAgIC8vIGVycm9yIHdoZW4gdW5pdCBpcyBwcmVzZW50IGFuZC4uLlxuICAgICAgKHVuaXQpICYmIChcbiAgICAgICAgLy8gLi4uYWxsb3dlZFVuaXRzIGFyZSBwYXNzZWQgaW4gYnV0IHVuaXQgaXMgbm90IGluIGFsbG93ZWQgVW5pdHNcbiAgICAgICAgKGFsbG93ZWRVbml0cyAmJiAhYWxsb3dlZFVuaXRzLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXModW5pdFswXS50b0xvd2VyQ2FzZSgpKSlcbiAgICAgICAgLy8gLi4ud2hlbiBhbGxvd2VkVW5pdHMgYXJlIG5vdCBwYXNzZWQgaW4gYW5kIHVuaXQgaXMgbm90IHJlY29nbml6ZWRcbiAgICAgICAgfHwgIW5vcm1hbGl6ZWRVbml0XG4gICAgICApXG4gICAgKSB7XG4gICAgICByZXR1cm4geyBudW1iZXI6IG51bGwsIHVuaXQ6IG51bGwgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbnVtYmVyOiBudW0sIHVuaXQ6IG5vcm1hbGl6ZWRVbml0IH07XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplIHNob3J0IHVuaXRzIChcIk1CXCIpIG9yIGh1bWFuIHVuaXRzIChcIk1cIikgdG8gSUVDIHVuaXRzIChcIk1pQlwiKVxuICAgKiBAcGFyYW0gdW5pdFN0ciBUaGUgdW5pdCBzdHJpbmcgdG8gYmUgbm9ybWFsaXplZFxuICAgKiBAcmV0dXJucyBOb3JtYWxpemVkIHVuaXQgc3RyaW5nIGJhc2VkIG9uIHRoZSBwYXNzZWQgdmFsdWVcbiAgICovXG4gIG5vcm1hbGl6ZVVuaXQgPSAodW5pdFN0cjogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICAvLyBlbXB0eSB1bml0IGlzIHZhbGlkLCBqdXN0IHJldHVyblxuICAgIGlmICghdW5pdFN0cikge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGNvbnN0IGllY1VuaXRzU3RyID0gdGhpcy5pZWNVbml0cy5qb2luKCd8Jyk7XG4gICAgY29uc3Qgc2hvcnRVbml0c1N0ciA9IHRoaXMuaWVjVW5pdHMubWFwKCh1bml0KSA9PiB7XG4gICAgICBpZiAodW5pdC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHJldHVybiB1bml0LmNoYXJBdCgwKSArIHVuaXQuY2hhckF0KDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdCWVRFUyc7XG4gICAgfSkuam9pbignfCcpO1xuICAgIGNvbnN0IGh1bWFuVW5pdHNTdHIgPSB0aGlzLmllY1VuaXRzLm1hcCgodW5pdCkgPT4gdW5pdC5jaGFyQXQoMCkpLmpvaW4oJ3wnKTtcblxuICAgIGNvbnN0IGFsbFVuaXRzU3RyID0gKGllY1VuaXRzU3RyICsgJ3wnICsgc2hvcnRVbml0c1N0ciArICd8JyArIGh1bWFuVW5pdHNTdHIpLnRvVXBwZXJDYXNlKCk7XG4gICAgY29uc3QgdW5pdHNSZSA9IG5ldyBSZWdFeHAoJ15cXFxccyooJyArIGFsbFVuaXRzU3RyICsgJyl7MX1cXFxccyokJyk7XG5cbiAgICB1bml0U3RyID0gdW5pdFN0ci50b1VwcGVyQ2FzZSgpO1xuICAgIGlmICh1bml0U3RyLm1hdGNoKHVuaXRzUmUpKSB7XG4gICAgICAvLyBhbHdheXMgcmV0dXJuIElFQyB1bml0c1xuICAgICAgLy8gY291bGQgdGFrZSBhIHBhcmFtZXRlciB0byByZXR1cm4gc2hvcnQgb3IgaHVtYW4gdW5pdHNcbiAgICAgIGlmICh1bml0U3RyLnRvTG93ZXJDYXNlKCkgPT09ICdiJyB8fCB1bml0U3RyLnRvTG93ZXJDYXNlKCkgPT09ICdieXRlcycpIHtcbiAgICAgICAgcmV0dXJuICdCJztcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bml0U3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgJ2lCJztcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCBJRUMgKFwiTWlCXCIpLCBzaG9ydCAoXCJNQlwiKSwgb3IgaHVtYW4gKFwiTVwiKSB1bml0cyB0byBudW1iZXIgb2YgYnl0ZXMuIFVua25vd24gdW5pdHMgYXJlIGV2YWx1YXRlZCBhcyAxXG4gICAqIEBwYXJhbSB1bml0U3RyIFRoZSB1bml0IHN0cmluZyB0byBiZSBjb252ZXJ0ZWRcbiAgICogQHJldHVybnMgTnVtYmVyIG9mIGJ5dGVzXG4gICAqL1xuICBjb252ZXJ0VW5pdFRvTnVtID0gKHVuaXRTdHI6IHN0cmluZyk6IG51bWJlciA9PiB7XG4gICAgdW5pdFN0ciA9IHRoaXMubm9ybWFsaXplVW5pdCh1bml0U3RyKTtcbiAgICBpZiAoIXVuaXRTdHIpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gKDEwMjQgKiogKHRoaXMuaWVjVW5pdHMuaW5kZXhPZih1bml0U3RyKSkpO1xuICB9O1xuXG4gIHN0cmluZ0FzVXJsUGFyc2luZyA9ICh2YWx1ZTogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICBpZiAodmFsdWUuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGAke3RoaXMucHJvdG9jb2x9Ly8ke3ZhbHVlfWA7XG4gIH07XG59XG4iXSwidmVyc2lvbiI6M30=