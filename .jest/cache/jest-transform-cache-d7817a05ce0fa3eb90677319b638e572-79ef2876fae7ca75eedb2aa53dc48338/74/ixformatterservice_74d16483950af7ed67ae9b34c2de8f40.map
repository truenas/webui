{"file":"/Users/macbook/karpov-work/TrueNAS/webui/src/app/modules/forms/ix-forms/services/ix-formatter.service.ts","mappings":"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","names":[],"sources":["/Users/macbook/karpov-work/TrueNAS/webui/src/app/modules/forms/ix-forms/services/ix-formatter.service.ts"],"sourcesContent":["import { Inject, Injectable } from '@angular/core';\nimport { WINDOW } from 'app/helpers/window.helper';\n\n@Injectable({ providedIn: 'root' })\nexport class IxFormatterService {\n  readonly protocol = this.window?.location?.protocol || 'http:';\n  readonly iecUnits: readonly string[] = ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB'];\n\n  constructor(@Inject(WINDOW) private window: Window) {}\n\n  /**\n   * Formats any memory size in bytes to human readable string, e.g., '2147483648' to '2 GiB'\n   * @param value The string to be formatted\n   * @returns Formatted string\n   */\n  memorySizeFormatting: (val: string | number) => string = (value: string | number) => {\n    if (!value) {\n      return '';\n    }\n    value = value.toString();\n    return !value || Number.isNaN(Number(value)) ? '' : this.convertBytesToHumanReadable(value, 2);\n  };\n\n  /**\n   * Parses passed in human readable memory size string into a normalized value.\n   * If no units are provided, MiB is used as default unit\n   * @param value The value to be parsed\n   * @returns The parsed value\n   */\n  memorySizeParsing: (val: string, postfixValue?: string) => number = (value: string, postfix: string) => {\n    if (!value) {\n      return null;\n    }\n\n    const finalValue = `${value} ${!Number(value) ? '' : postfix || ''}`.trim();\n    const humanStringToNum = this.convertHumanStringToNum(finalValue, true);\n\n    // Default unit is MiB so if the user passed in no unit, we assume unit is MiB\n    return (humanStringToNum !== Number(finalValue)) ? humanStringToNum : this.convertHumanStringToNum(finalValue + 'mb', true);\n  };\n\n  /**\n   * Converts a number from bytes to the most natural human readable format\n   * @param rawBytes Bytes to be converted\n   * @param decimalPlaces Number of decimal places that the final value should be rounded off to\n   * @param minUnits If no unit is provided, what minimum base unit should be assumed\n   * @param hideBytes If the value is in bytes, should the 'B' sign be added\n   * @returns A human readable string with appropriate units\n   */\n  convertBytesToHumanReadable = (\n    rawBytes: number | string,\n    decimalPlaces?: number,\n    minUnits?: string,\n    hideBytes?: boolean,\n  ): string => {\n    let i = 0;\n    let units;\n    let bytes = Number(rawBytes);\n\n    const dec = decimalPlaces !== undefined ? decimalPlaces : 2;\n    if (bytes >= 1024) {\n      do {\n        bytes = bytes / 1024;\n        i++;\n      } while (bytes >= 1024 && i < 4);\n      units = this.iecUnits[i];\n    } else if (minUnits) {\n      units = minUnits;\n    } else {\n      units = hideBytes ? '' : 'B';\n    }\n    return `${parseFloat(bytes.toFixed(dec))} ${units}`;\n  };\n\n  /**\n   * Converts a human readable size string with units into bytes. Any invalid letters result in null returned\n   * @param hstr The string to be converted\n   * @param dec Does the passed string has a decimal point values\n   * @param allowedUnits allowedUnits should include any or all of 'bkmgtp', the first letters of KiB, Mib, etc.\n   * The first letter is used as the default, so for 'gtp', an entered value of 256 becomes 256 GiB.\n   * If you don't pass in allowedUnits, all of the above are accepted AND no unit is attached to an unlabeled number,\n   * so 256 is considered 256 bytes.\n   * @returns The passed human readable string converted into number of bytes\n   */\n  convertHumanStringToNum = (\n    hstr: string,\n    dec = false,\n    allowedUnits?: 'bkmgtp' | 'kmgtp' | 'mgtp' | 'gtp' | 'tp' | 'p',\n  ): number => {\n    const { unit, number } = this.getNumberAndUnitFromHumanString(hstr, dec, allowedUnits);\n\n    return number === null ? null : Number(number) * this.convertUnitToNum(unit);\n  };\n\n  /**\n   * Converts passed in human readable string into two parts. The digit value in numbers and the unit that's applied.\n   * @param hstr The human readable size string\n   * @param dec Does the value has decimal point values\n   * @param allowedUnits allowedUnits should include any or all of 'bkmgtp', the first letters of KiB, Mib, etc.\n   * The first letter is used as the default, so for 'gtp', an entered value of 256 becomes 256 GiB.\n   * If you don't pass in allowedUnits, all of the above are accepted AND no unit is attached to an unlabeled number,\n   * so 256 is considered 256 bytes.\n   * @returns The passed human readable string converted into number and unit seperately\n   */\n  getNumberAndUnitFromHumanString(\n    hstr: string,\n    dec = false,\n    allowedUnits?: 'bkmgtp' | 'kmgtp' | 'mgtp' | 'gtp' | 'tp' | 'p',\n  ): { number: string; unit: string } {\n    let num;\n    let unit = '';\n\n    // empty value is evaluated as zero\n    if (!hstr) {\n      return { number: null, unit: null };\n    }\n\n    // remove whitespace\n    hstr = hstr.replace(/\\s+/g, '');\n\n    // get leading number\n    let match = [];\n    if (dec) {\n      match = hstr.match(/^(\\d+(\\.\\d+)?)/);\n    } else {\n      match = hstr.match(/^(\\d+)/);\n    }\n    if (match && match.length > 1) {\n      num = match[1];\n    } else {\n      // leading number is required\n      return { number: null, unit: null };\n    }\n\n    // get optional unit\n    unit = hstr.replace(num, '');\n    if (!unit && allowedUnits) {\n      unit = allowedUnits[0];\n    }\n\n    const normalizedUnit = this.normalizeUnit(unit);\n    if (\n      // error when unit is present and...\n      (unit) && (\n        // ...allowedUnits are passed in but unit is not in allowed Units\n        (allowedUnits && !allowedUnits.toLowerCase().includes(unit[0].toLowerCase()))\n        // ...when allowedUnits are not passed in and unit is not recognized\n        || !normalizedUnit\n      )\n    ) {\n      return { number: null, unit: null };\n    }\n    return { number: num, unit: normalizedUnit };\n  }\n\n  /**\n   * Normalize short units (\"MB\") or human units (\"M\") to IEC units (\"MiB\")\n   * @param unitStr The unit string to be normalized\n   * @returns Normalized unit string based on the passed value\n   */\n  normalizeUnit = (unitStr: string): string => {\n    // empty unit is valid, just return\n    if (!unitStr) {\n      return '';\n    }\n\n    const iecUnitsStr = this.iecUnits.join('|');\n    const shortUnitsStr = this.iecUnits.map((unit) => {\n      if (unit.length > 1) {\n        return unit.charAt(0) + unit.charAt(2);\n      }\n      return 'BYTES';\n    }).join('|');\n    const humanUnitsStr = this.iecUnits.map((unit) => unit.charAt(0)).join('|');\n\n    const allUnitsStr = (iecUnitsStr + '|' + shortUnitsStr + '|' + humanUnitsStr).toUpperCase();\n    const unitsRe = new RegExp('^\\\\s*(' + allUnitsStr + '){1}\\\\s*$');\n\n    unitStr = unitStr.toUpperCase();\n    if (unitStr.match(unitsRe)) {\n      // always return IEC units\n      // could take a parameter to return short or human units\n      if (unitStr.toLowerCase() === 'b' || unitStr.toLowerCase() === 'bytes') {\n        return 'B';\n      }\n      return unitStr.charAt(0).toUpperCase() + 'iB';\n    }\n    return undefined;\n  };\n\n  /**\n   * Convert IEC (\"MiB\"), short (\"MB\"), or human (\"M\") units to number of bytes. Unknown units are evaluated as 1\n   * @param unitStr The unit string to be converted\n   * @returns Number of bytes\n   */\n  convertUnitToNum = (unitStr: string): number => {\n    unitStr = this.normalizeUnit(unitStr);\n    if (!unitStr) {\n      return 1;\n    }\n    return (1024 ** (this.iecUnits.indexOf(unitStr)));\n  };\n\n  stringAsUrlParsing = (value: string): string => {\n    if (value.startsWith('http')) {\n      return value;\n    }\n\n    return `${this.protocol}//${value}`;\n  };\n}\n"],"version":3}