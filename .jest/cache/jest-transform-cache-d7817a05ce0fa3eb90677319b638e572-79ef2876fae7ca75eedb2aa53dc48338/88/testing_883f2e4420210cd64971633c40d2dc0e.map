{
  "version": 3,
  "sources": ["/Users/macbook/karpov-work/TrueNAS/webui/node_modules/@angular/material/fesm2022/menu/testing.mjs"],
  "sourcesContent": ["import { ContentContainerComponentHarness, HarnessPredicate, TestKey } from '@angular/cdk/testing';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\n\n/** Harness for interacting with a mat-menu in tests. */\nclass MatMenuHarness extends ContentContainerComponentHarness {\n    constructor() {\n        super(...arguments);\n        this._documentRootLocator = this.documentRootLocatorFactory();\n    }\n    /** The selector for the host element of a `MatMenu` instance. */\n    static { this.hostSelector = '.mat-mdc-menu-trigger'; }\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a menu with specific attributes.\n     * @param options Options for filtering which menu instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options = {}) {\n        return new HarnessPredicate(this, options).addOption('triggerText', options.triggerText, (harness, text) => HarnessPredicate.stringMatches(harness.getTriggerText(), text));\n    }\n    /** Whether the menu is disabled. */\n    async isDisabled() {\n        const disabled = (await this.host()).getAttribute('disabled');\n        return coerceBooleanProperty(await disabled);\n    }\n    /** Whether the menu is open. */\n    async isOpen() {\n        return !!(await this._getMenuPanel());\n    }\n    /** Gets the text of the menu's trigger element. */\n    async getTriggerText() {\n        return (await this.host()).text();\n    }\n    /** Focuses the menu. */\n    async focus() {\n        return (await this.host()).focus();\n    }\n    /** Blurs the menu. */\n    async blur() {\n        return (await this.host()).blur();\n    }\n    /** Whether the menu is focused. */\n    async isFocused() {\n        return (await this.host()).isFocused();\n    }\n    /** Opens the menu. */\n    async open() {\n        if (!(await this.isOpen())) {\n            return (await this.host()).click();\n        }\n    }\n    /** Closes the menu. */\n    async close() {\n        const panel = await this._getMenuPanel();\n        if (panel) {\n            return panel.sendKeys(TestKey.ESCAPE);\n        }\n    }\n    /**\n     * Gets a list of `MatMenuItemHarness` representing the items in the menu.\n     * @param filters Optionally filters which menu items are included.\n     */\n    async getItems(filters) {\n        const panelId = await this._getPanelId();\n        if (panelId) {\n            return this._documentRootLocator.locatorForAll(MatMenuItemHarness.with({\n                ...(filters || {}),\n                ancestor: `#${panelId}`,\n            }))();\n        }\n        return [];\n    }\n    /**\n     * Clicks an item in the menu, and optionally continues clicking items in subsequent sub-menus.\n     * @param itemFilter A filter used to represent which item in the menu should be clicked. The\n     *     first matching menu item will be clicked.\n     * @param subItemFilters A list of filters representing the items to click in any subsequent\n     *     sub-menus. The first item in the sub-menu matching the corresponding filter in\n     *     `subItemFilters` will be clicked.\n     */\n    async clickItem(itemFilter, ...subItemFilters) {\n        await this.open();\n        const items = await this.getItems(itemFilter);\n        if (!items.length) {\n            throw Error(`Could not find item matching ${JSON.stringify(itemFilter)}`);\n        }\n        if (!subItemFilters.length) {\n            return await items[0].click();\n        }\n        const menu = await items[0].getSubmenu();\n        if (!menu) {\n            throw Error(`Item matching ${JSON.stringify(itemFilter)} does not have a submenu`);\n        }\n        return menu.clickItem(...subItemFilters);\n    }\n    async getRootHarnessLoader() {\n        const panelId = await this._getPanelId();\n        return this.documentRootLocatorFactory().harnessLoaderFor(`#${panelId}`);\n    }\n    /** Gets the menu panel associated with this menu. */\n    async _getMenuPanel() {\n        const panelId = await this._getPanelId();\n        return panelId ? this._documentRootLocator.locatorForOptional(`#${panelId}`)() : null;\n    }\n    /** Gets the id of the menu panel associated with this menu. */\n    async _getPanelId() {\n        const panelId = await (await this.host()).getAttribute('aria-controls');\n        return panelId || null;\n    }\n}\nclass MatMenuItemHarness extends ContentContainerComponentHarness {\n    /** The selector for the host element of a `MatMenuItem` instance. */\n    static { this.hostSelector = '.mat-mdc-menu-item'; }\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a menu item with specific attributes.\n     * @param options Options for filtering which menu item instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options = {}) {\n        return new HarnessPredicate(this, options)\n            .addOption('text', options.text, (harness, text) => HarnessPredicate.stringMatches(harness.getText(), text))\n            .addOption('hasSubmenu', options.hasSubmenu, async (harness, hasSubmenu) => (await harness.hasSubmenu()) === hasSubmenu);\n    }\n    /** Whether the menu is disabled. */\n    async isDisabled() {\n        const disabled = (await this.host()).getAttribute('disabled');\n        return coerceBooleanProperty(await disabled);\n    }\n    /** Gets the text of the menu item. */\n    async getText() {\n        return (await this.host()).text();\n    }\n    /** Focuses the menu item. */\n    async focus() {\n        return (await this.host()).focus();\n    }\n    /** Blurs the menu item. */\n    async blur() {\n        return (await this.host()).blur();\n    }\n    /** Whether the menu item is focused. */\n    async isFocused() {\n        return (await this.host()).isFocused();\n    }\n    /** Clicks the menu item. */\n    async click() {\n        return (await this.host()).click();\n    }\n    /** Whether this item has a submenu. */\n    async hasSubmenu() {\n        return (await this.host()).matchesSelector(MatMenuHarness.hostSelector);\n    }\n    /** Gets the submenu associated with this menu item, or null if none. */\n    async getSubmenu() {\n        if (await this.hasSubmenu()) {\n            return new MatMenuHarness(this.locatorFactory);\n        }\n        return null;\n    }\n}\n\nexport { MatMenuHarness, MatMenuItemHarness };\n//# sourceMappingURL=testing.mjs.map\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAA4E;AAC5E,sBAAsC;AAGtC,MAAM,kBAAN,MAAM,wBAAuB,gDAAiC;AAAA,EAC1D,cAAc;AACV,UAAM,GAAG,SAAS;AAClB,SAAK,uBAAuB,KAAK,2BAA2B;AAAA,EAChE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,OAAO,KAAK,UAAU,CAAC,GAAG;AACtB,WAAO,IAAI,gCAAiB,MAAM,OAAO,EAAE,UAAU,eAAe,QAAQ,aAAa,CAAC,SAAS,SAAS,gCAAiB,cAAc,QAAQ,eAAe,GAAG,IAAI,CAAC;AAAA,EAC9K;AAAA;AAAA,EAEM,aAAa;AAAA;AACf,YAAM,YAAY,MAAM,KAAK,KAAK,GAAG,aAAa,UAAU;AAC5D,iBAAO,uCAAsB,MAAM,QAAQ;AAAA,IAC/C;AAAA;AAAA;AAAA,EAEM,SAAS;AAAA;AACX,aAAO,CAAC,EAAE,MAAM,KAAK,cAAc;AAAA,IACvC;AAAA;AAAA;AAAA,EAEM,iBAAiB;AAAA;AACnB,cAAQ,MAAM,KAAK,KAAK,GAAG,KAAK;AAAA,IACpC;AAAA;AAAA;AAAA,EAEM,QAAQ;AAAA;AACV,cAAQ,MAAM,KAAK,KAAK,GAAG,MAAM;AAAA,IACrC;AAAA;AAAA;AAAA,EAEM,OAAO;AAAA;AACT,cAAQ,MAAM,KAAK,KAAK,GAAG,KAAK;AAAA,IACpC;AAAA;AAAA;AAAA,EAEM,YAAY;AAAA;AACd,cAAQ,MAAM,KAAK,KAAK,GAAG,UAAU;AAAA,IACzC;AAAA;AAAA;AAAA,EAEM,OAAO;AAAA;AACT,UAAI,EAAE,MAAM,KAAK,OAAO,IAAI;AACxB,gBAAQ,MAAM,KAAK,KAAK,GAAG,MAAM;AAAA,MACrC;AAAA,IACJ;AAAA;AAAA;AAAA,EAEM,QAAQ;AAAA;AACV,YAAM,QAAQ,MAAM,KAAK,cAAc;AACvC,UAAI,OAAO;AACP,eAAO,MAAM,SAAS,uBAAQ,MAAM;AAAA,MACxC;AAAA,IACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAKM,SAAS,SAAS;AAAA;AACpB,YAAM,UAAU,MAAM,KAAK,YAAY;AACvC,UAAI,SAAS;AACT,eAAO,KAAK,qBAAqB,cAAc,mBAAmB,KAAK,iCAC/D,WAAW,CAAC,IADmD;AAAA,UAEnE,UAAU,IAAI,OAAO;AAAA,QACzB,EAAC,CAAC,EAAE;AAAA,MACR;AACA,aAAO,CAAC;AAAA,IACZ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASM,UAAU,eAAe,gBAAgB;AAAA;AAC3C,YAAM,KAAK,KAAK;AAChB,YAAM,QAAQ,MAAM,KAAK,SAAS,UAAU;AAC5C,UAAI,CAAC,MAAM,QAAQ;AACf,cAAM,MAAM,gCAAgC,KAAK,UAAU,UAAU,CAAC,EAAE;AAAA,MAC5E;AACA,UAAI,CAAC,eAAe,QAAQ;AACxB,eAAO,MAAM,MAAM,CAAC,EAAE,MAAM;AAAA,MAChC;AACA,YAAM,OAAO,MAAM,MAAM,CAAC,EAAE,WAAW;AACvC,UAAI,CAAC,MAAM;AACP,cAAM,MAAM,iBAAiB,KAAK,UAAU,UAAU,CAAC,0BAA0B;AAAA,MACrF;AACA,aAAO,KAAK,UAAU,GAAG,cAAc;AAAA,IAC3C;AAAA;AAAA,EACM,uBAAuB;AAAA;AACzB,YAAM,UAAU,MAAM,KAAK,YAAY;AACvC,aAAO,KAAK,2BAA2B,EAAE,iBAAiB,IAAI,OAAO,EAAE;AAAA,IAC3E;AAAA;AAAA;AAAA,EAEM,gBAAgB;AAAA;AAClB,YAAM,UAAU,MAAM,KAAK,YAAY;AACvC,aAAO,UAAU,KAAK,qBAAqB,mBAAmB,IAAI,OAAO,EAAE,EAAE,IAAI;AAAA,IACrF;AAAA;AAAA;AAAA,EAEM,cAAc;AAAA;AAChB,YAAM,UAAU,OAAO,MAAM,KAAK,KAAK,GAAG,aAAa,eAAe;AACtE,aAAO,WAAW;AAAA,IACtB;AAAA;AACJ;AAlGa,gBAAK,eAAe;AANjC,IAAM,iBAAN;AAyGA,MAAM,sBAAN,MAAM,4BAA2B,gDAAiC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQ9D,OAAO,KAAK,UAAU,CAAC,GAAG;AACtB,WAAO,IAAI,gCAAiB,MAAM,OAAO,EACpC,UAAU,QAAQ,QAAQ,MAAM,CAAC,SAAS,SAAS,gCAAiB,cAAc,QAAQ,QAAQ,GAAG,IAAI,CAAC,EAC1G,UAAU,cAAc,QAAQ,YAAY,CAAO,SAAS,eAAY;AAAI,oBAAM,QAAQ,WAAW,OAAO;AAAA,MAAU;AAAA,EAC/H;AAAA;AAAA,EAEM,aAAa;AAAA;AACf,YAAM,YAAY,MAAM,KAAK,KAAK,GAAG,aAAa,UAAU;AAC5D,iBAAO,uCAAsB,MAAM,QAAQ;AAAA,IAC/C;AAAA;AAAA;AAAA,EAEM,UAAU;AAAA;AACZ,cAAQ,MAAM,KAAK,KAAK,GAAG,KAAK;AAAA,IACpC;AAAA;AAAA;AAAA,EAEM,QAAQ;AAAA;AACV,cAAQ,MAAM,KAAK,KAAK,GAAG,MAAM;AAAA,IACrC;AAAA;AAAA;AAAA,EAEM,OAAO;AAAA;AACT,cAAQ,MAAM,KAAK,KAAK,GAAG,KAAK;AAAA,IACpC;AAAA;AAAA;AAAA,EAEM,YAAY;AAAA;AACd,cAAQ,MAAM,KAAK,KAAK,GAAG,UAAU;AAAA,IACzC;AAAA;AAAA;AAAA,EAEM,QAAQ;AAAA;AACV,cAAQ,MAAM,KAAK,KAAK,GAAG,MAAM;AAAA,IACrC;AAAA;AAAA;AAAA,EAEM,aAAa;AAAA;AACf,cAAQ,MAAM,KAAK,KAAK,GAAG,gBAAgB,eAAe,YAAY;AAAA,IAC1E;AAAA;AAAA;AAAA,EAEM,aAAa;AAAA;AACf,UAAI,MAAM,KAAK,WAAW,GAAG;AACzB,eAAO,IAAI,eAAe,KAAK,cAAc;AAAA,MACjD;AACA,aAAO;AAAA,IACX;AAAA;AACJ;AA/Ca,oBAAK,eAAe;AAFjC,IAAM,qBAAN;",
  "names": []
}
