a75dd6a109df7dca252dcffb0db03e1a
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const _baseWrapperValue_js_1 = __importDefault(require("./_baseWrapperValue.js"));
const _getView_js_1 = __importDefault(require("./_getView.js"));
const isArray_js_1 = __importDefault(require("./isArray.js"));
/** Used to indicate the type of lazy iteratees. */
var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2;
/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;
/**
 * Extracts the unwrapped value from its lazy wrapper.
 *
 * @private
 * @name value
 * @memberOf LazyWrapper
 * @returns {*} Returns the unwrapped value.
 */
function lazyValue() {
    var array = this.__wrapped__.value(), dir = this.__dir__, isArr = (0, isArray_js_1.default)(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = (0, _getView_js_1.default)(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : (start - 1), iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
    if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return (0, _baseWrapperValue_js_1.default)(array, this.__actions__);
    }
    var result = [];
    outer: while (length-- && resIndex < takeCount) {
        index += dir;
        var iterIndex = -1, value = array[index];
        while (++iterIndex < iterLength) {
            var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type, computed = iteratee(value);
            if (type == LAZY_MAP_FLAG) {
                value = computed;
            }
            else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                }
                else {
                    break outer;
                }
            }
        }
        result[resIndex++] = value;
    }
    return result;
}
exports.default = lazyValue;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL21hY2Jvb2sva2FycG92LXdvcmsvVHJ1ZU5BUy93ZWJ1aS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19sYXp5VmFsdWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxrRkFBc0Q7QUFDdEQsZ0VBQW9DO0FBQ3BDLDhEQUFtQztBQUVuQyxtREFBbUQ7QUFDbkQsSUFBSSxnQkFBZ0IsR0FBRyxDQUFDLEVBQ3BCLGFBQWEsR0FBRyxDQUFDLENBQUM7QUFFdEIsd0ZBQXdGO0FBQ3hGLElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7QUFFekI7Ozs7Ozs7R0FPRztBQUNILFNBQVMsU0FBUztJQUNoQixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxFQUNoQyxHQUFHLEdBQUcsSUFBSSxDQUFDLE9BQU8sRUFDbEIsS0FBSyxHQUFHLElBQUEsb0JBQU8sRUFBQyxLQUFLLENBQUMsRUFDdEIsT0FBTyxHQUFHLEdBQUcsR0FBRyxDQUFDLEVBQ2pCLFNBQVMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFDcEMsSUFBSSxHQUFHLElBQUEscUJBQU8sRUFBQyxDQUFDLEVBQUUsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsRUFDNUMsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLEVBQ2xCLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUNkLE1BQU0sR0FBRyxHQUFHLEdBQUcsS0FBSyxFQUNwQixLQUFLLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxFQUNuQyxTQUFTLEdBQUcsSUFBSSxDQUFDLGFBQWEsRUFDOUIsVUFBVSxHQUFHLFNBQVMsQ0FBQyxNQUFNLEVBQzdCLFFBQVEsR0FBRyxDQUFDLEVBQ1osU0FBUyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBRXRELElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLE9BQU8sSUFBSSxTQUFTLElBQUksTUFBTSxJQUFJLFNBQVMsSUFBSSxNQUFNLENBQUMsRUFBRSxDQUFDO1FBQ3ZFLE9BQU8sSUFBQSw4QkFBZ0IsRUFBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFDRCxJQUFJLE1BQU0sR0FBRyxFQUFFLENBQUM7SUFFaEIsS0FBSyxFQUNMLE9BQU8sTUFBTSxFQUFFLElBQUksUUFBUSxHQUFHLFNBQVMsRUFBRSxDQUFDO1FBQ3hDLEtBQUssSUFBSSxHQUFHLENBQUM7UUFFYixJQUFJLFNBQVMsR0FBRyxDQUFDLENBQUMsRUFDZCxLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRXpCLE9BQU8sRUFBRSxTQUFTLEdBQUcsVUFBVSxFQUFFLENBQUM7WUFDaEMsSUFBSSxJQUFJLEdBQUcsU0FBUyxDQUFDLFNBQVMsQ0FBQyxFQUMzQixRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFDeEIsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLEVBQ2hCLFFBQVEsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7WUFFL0IsSUFBSSxJQUFJLElBQUksYUFBYSxFQUFFLENBQUM7Z0JBQzFCLEtBQUssR0FBRyxRQUFRLENBQUM7WUFDbkIsQ0FBQztpQkFBTSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQ3JCLElBQUksSUFBSSxJQUFJLGdCQUFnQixFQUFFLENBQUM7b0JBQzdCLFNBQVMsS0FBSyxDQUFDO2dCQUNqQixDQUFDO3FCQUFNLENBQUM7b0JBQ04sTUFBTSxLQUFLLENBQUM7Z0JBQ2QsQ0FBQztZQUNILENBQUM7UUFDSCxDQUFDO1FBQ0QsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDO0lBQzdCLENBQUM7SUFDRCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBRUQsa0JBQWUsU0FBUyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNib29rL2thcnBvdi13b3JrL1RydWVOQVMvd2VidWkvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGF6eVZhbHVlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBiYXNlV3JhcHBlclZhbHVlIGZyb20gJy4vX2Jhc2VXcmFwcGVyVmFsdWUuanMnO1xuaW1wb3J0IGdldFZpZXcgZnJvbSAnLi9fZ2V0Vmlldy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuXG4vKiogVXNlZCB0byBpbmRpY2F0ZSB0aGUgdHlwZSBvZiBsYXp5IGl0ZXJhdGVlcy4gKi9cbnZhciBMQVpZX0ZJTFRFUl9GTEFHID0gMSxcbiAgICBMQVpZX01BUF9GTEFHID0gMjtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSB1bndyYXBwZWQgdmFsdWUgZnJvbSBpdHMgbGF6eSB3cmFwcGVyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSB2YWx1ZVxuICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBsYXp5VmFsdWUoKSB7XG4gIHZhciBhcnJheSA9IHRoaXMuX193cmFwcGVkX18udmFsdWUoKSxcbiAgICAgIGRpciA9IHRoaXMuX19kaXJfXyxcbiAgICAgIGlzQXJyID0gaXNBcnJheShhcnJheSksXG4gICAgICBpc1JpZ2h0ID0gZGlyIDwgMCxcbiAgICAgIGFyckxlbmd0aCA9IGlzQXJyID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgIHZpZXcgPSBnZXRWaWV3KDAsIGFyckxlbmd0aCwgdGhpcy5fX3ZpZXdzX18pLFxuICAgICAgc3RhcnQgPSB2aWV3LnN0YXJ0LFxuICAgICAgZW5kID0gdmlldy5lbmQsXG4gICAgICBsZW5ndGggPSBlbmQgLSBzdGFydCxcbiAgICAgIGluZGV4ID0gaXNSaWdodCA/IGVuZCA6IChzdGFydCAtIDEpLFxuICAgICAgaXRlcmF0ZWVzID0gdGhpcy5fX2l0ZXJhdGVlc19fLFxuICAgICAgaXRlckxlbmd0aCA9IGl0ZXJhdGVlcy5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICB0YWtlQ291bnQgPSBuYXRpdmVNaW4obGVuZ3RoLCB0aGlzLl9fdGFrZUNvdW50X18pO1xuXG4gIGlmICghaXNBcnIgfHwgKCFpc1JpZ2h0ICYmIGFyckxlbmd0aCA9PSBsZW5ndGggJiYgdGFrZUNvdW50ID09IGxlbmd0aCkpIHtcbiAgICByZXR1cm4gYmFzZVdyYXBwZXJWYWx1ZShhcnJheSwgdGhpcy5fX2FjdGlvbnNfXyk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIG91dGVyOlxuICB3aGlsZSAobGVuZ3RoLS0gJiYgcmVzSW5kZXggPCB0YWtlQ291bnQpIHtcbiAgICBpbmRleCArPSBkaXI7XG5cbiAgICB2YXIgaXRlckluZGV4ID0gLTEsXG4gICAgICAgIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgd2hpbGUgKCsraXRlckluZGV4IDwgaXRlckxlbmd0aCkge1xuICAgICAgdmFyIGRhdGEgPSBpdGVyYXRlZXNbaXRlckluZGV4XSxcbiAgICAgICAgICBpdGVyYXRlZSA9IGRhdGEuaXRlcmF0ZWUsXG4gICAgICAgICAgdHlwZSA9IGRhdGEudHlwZSxcbiAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgaWYgKHR5cGUgPT0gTEFaWV9NQVBfRkxBRykge1xuICAgICAgICB2YWx1ZSA9IGNvbXB1dGVkO1xuICAgICAgfSBlbHNlIGlmICghY29tcHV0ZWQpIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9GSUxURVJfRkxBRykge1xuICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxhenlWYWx1ZTtcbiJdLCJ2ZXJzaW9uIjozfQ==