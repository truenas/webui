{
  "version": 3,
  "sources": ["/Users/macbook/karpov-work/TrueNAS/webui/node_modules/@angular/cdk/fesm2022/testing/testbed.mjs"],
  "sourcesContent": ["import { getNoKeysSpecifiedError, TestKey, _getTextWithExcludedElements, handleAutoChangeDetectionStatus, stopHandlingAutoChangeDetectionStatus, HarnessEnvironment } from '@angular/cdk/testing';\nimport { flush } from '@angular/core/testing';\nimport { takeWhile } from 'rxjs/operators';\nimport { BehaviorSubject } from 'rxjs';\nimport * as keyCodes from '@angular/cdk/keycodes';\nimport { PERIOD } from '@angular/cdk/keycodes';\n\n/** Unique symbol that is used to patch a property to a proxy zone. */\nconst stateObservableSymbol = Symbol('ProxyZone_PATCHED#stateObservable');\n/**\n * Interceptor that can be set up in a `ProxyZone` instance. The interceptor\n * will keep track of the task state and emit whenever the state changes.\n *\n * This serves as a workaround for https://github.com/angular/angular/issues/32896.\n */\nclass TaskStateZoneInterceptor {\n    constructor(_lastState) {\n        this._lastState = _lastState;\n        /** Subject that can be used to emit a new state change. */\n        this._stateSubject = new BehaviorSubject(this._lastState ? this._getTaskStateFromInternalZoneState(this._lastState) : { stable: true });\n        /** Public observable that emits whenever the task state changes. */\n        this.state = this._stateSubject;\n    }\n    /** This will be called whenever the task state changes in the intercepted zone. */\n    onHasTask(delegate, current, target, hasTaskState) {\n        if (current === target) {\n            this._stateSubject.next(this._getTaskStateFromInternalZoneState(hasTaskState));\n        }\n    }\n    /** Gets the task state from the internal ZoneJS task state. */\n    _getTaskStateFromInternalZoneState(state) {\n        return { stable: !state.macroTask && !state.microTask };\n    }\n    /**\n     * Sets up the custom task state Zone interceptor in the  `ProxyZone`. Throws if\n     * no `ProxyZone` could be found.\n     * @returns an observable that emits whenever the task state changes.\n     */\n    static setup() {\n        if (Zone === undefined) {\n            throw Error('Could not find ZoneJS. For test harnesses running in TestBed, ' +\n                'ZoneJS needs to be installed.');\n        }\n        // tslint:disable-next-line:variable-name\n        const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n        // If there is no \"ProxyZoneSpec\" installed, we throw an error and recommend\n        // setting up the proxy zone by pulling in the testing bundle.\n        if (!ProxyZoneSpec) {\n            throw Error('ProxyZoneSpec is needed for the test harnesses but could not be found. ' +\n                'Please make sure that your environment includes zone.js/dist/zone-testing.js');\n        }\n        // Ensure that there is a proxy zone instance set up, and get\n        // a reference to the instance if present.\n        const zoneSpec = ProxyZoneSpec.assertPresent();\n        // If there already is a delegate registered in the proxy zone, and it\n        // is type of the custom task state interceptor, we just use that state\n        // observable. This allows us to only intercept Zone once per test\n        // (similar to how `fakeAsync` or `async` work).\n        if (zoneSpec[stateObservableSymbol]) {\n            return zoneSpec[stateObservableSymbol];\n        }\n        // Since we intercept on environment creation and the fixture has been\n        // created before, we might have missed tasks scheduled before. Fortunately\n        // the proxy zone keeps track of the previous task state, so we can just pass\n        // this as initial state to the task zone interceptor.\n        const interceptor = new TaskStateZoneInterceptor(zoneSpec.lastTaskState);\n        const zoneSpecOnHasTask = zoneSpec.onHasTask.bind(zoneSpec);\n        // We setup the task state interceptor in the `ProxyZone`. Note that we cannot register\n        // the interceptor as a new proxy zone delegate because it would mean that other zone\n        // delegates (e.g. `FakeAsyncTestZone` or `AsyncTestZone`) can accidentally overwrite/disable\n        // our interceptor. Since we just intend to monitor the task state of the proxy zone, it is\n        // sufficient to just patch the proxy zone. This also avoids that we interfere with the task\n        // queue scheduling logic.\n        zoneSpec.onHasTask = function (...args) {\n            zoneSpecOnHasTask(...args);\n            interceptor.onHasTask(...args);\n        };\n        return (zoneSpec[stateObservableSymbol] = interceptor.state);\n    }\n}\n\n/** Used to generate unique IDs for events. */\nlet uniqueIds = 0;\n/**\n * Creates a browser MouseEvent with the specified options.\n * @docs-private\n */\nfunction createMouseEvent(type, clientX = 0, clientY = 0, offsetX = 0, offsetY = 0, button = 0, modifiers = {}) {\n    // Note: We cannot determine the position of the mouse event based on the screen\n    // because the dimensions and position of the browser window are not available\n    // To provide reasonable `screenX` and `screenY` coordinates, we simply use the\n    // client coordinates as if the browser is opened in fullscreen.\n    const screenX = clientX;\n    const screenY = clientY;\n    const event = new MouseEvent(type, {\n        bubbles: true,\n        cancelable: true,\n        composed: true, // Required for shadow DOM events.\n        view: window,\n        detail: 1,\n        relatedTarget: null,\n        screenX,\n        screenY,\n        clientX,\n        clientY,\n        ctrlKey: modifiers.control,\n        altKey: modifiers.alt,\n        shiftKey: modifiers.shift,\n        metaKey: modifiers.meta,\n        button: button,\n        buttons: 1,\n    });\n    // The `MouseEvent` constructor doesn't allow us to pass these properties into the constructor.\n    // Override them to `1`, because they're used for fake screen reader event detection.\n    if (offsetX != null) {\n        defineReadonlyEventProperty(event, 'offsetX', offsetX);\n    }\n    if (offsetY != null) {\n        defineReadonlyEventProperty(event, 'offsetY', offsetY);\n    }\n    return event;\n}\n/**\n * Creates a browser `PointerEvent` with the specified options. Pointer events\n * by default will appear as if they are the primary pointer of their type.\n * https://www.w3.org/TR/pointerevents2/#dom-pointerevent-isprimary.\n *\n * For example, if pointer events for a multi-touch interaction are created, the non-primary\n * pointer touches would need to be represented by non-primary pointer events.\n *\n * @docs-private\n */\nfunction createPointerEvent(type, clientX = 0, clientY = 0, offsetX, offsetY, options = { isPrimary: true }) {\n    const event = new PointerEvent(type, {\n        bubbles: true,\n        cancelable: true,\n        composed: true, // Required for shadow DOM events.\n        view: window,\n        clientX,\n        clientY,\n        ...options,\n    });\n    if (offsetX != null) {\n        defineReadonlyEventProperty(event, 'offsetX', offsetX);\n    }\n    if (offsetY != null) {\n        defineReadonlyEventProperty(event, 'offsetY', offsetY);\n    }\n    return event;\n}\n/**\n * Creates a browser TouchEvent with the specified pointer coordinates.\n * @docs-private\n */\nfunction createTouchEvent(type, pageX = 0, pageY = 0, clientX = 0, clientY = 0) {\n    // We cannot use the `TouchEvent` or `Touch` because Firefox and Safari lack support.\n    // TODO: Switch to the constructor API when it is available for Firefox and Safari.\n    const event = document.createEvent('UIEvent');\n    const touchDetails = { pageX, pageY, clientX, clientY, identifier: uniqueIds++ };\n    // TS3.6 removes the initUIEvent method and suggests porting to \"new UIEvent()\".\n    event.initUIEvent(type, true, true, window, 0);\n    // Most of the browsers don't have a \"initTouchEvent\" method that can be used to define\n    // the touch details.\n    defineReadonlyEventProperty(event, 'touches', [touchDetails]);\n    defineReadonlyEventProperty(event, 'targetTouches', [touchDetails]);\n    defineReadonlyEventProperty(event, 'changedTouches', [touchDetails]);\n    return event;\n}\n/**\n * Creates a keyboard event with the specified key and modifiers.\n * @docs-private\n */\nfunction createKeyboardEvent(type, keyCode = 0, key = '', modifiers = {}) {\n    return new KeyboardEvent(type, {\n        bubbles: true,\n        cancelable: true,\n        composed: true, // Required for shadow DOM events.\n        view: window,\n        keyCode: keyCode,\n        key: key,\n        shiftKey: modifiers.shift,\n        metaKey: modifiers.meta,\n        altKey: modifiers.alt,\n        ctrlKey: modifiers.control,\n    });\n}\n/**\n * Creates a fake event object with any desired event type.\n * @docs-private\n */\nfunction createFakeEvent(type, bubbles = false, cancelable = true, composed = true) {\n    return new Event(type, { bubbles, cancelable, composed });\n}\n/**\n * Defines a readonly property on the given event object. Readonly properties on an event object\n * are always set as configurable as that matches default readonly properties for DOM event objects.\n */\nfunction defineReadonlyEventProperty(event, propertyName, value) {\n    Object.defineProperty(event, propertyName, { get: () => value, configurable: true });\n}\n\n/**\n * Utility to dispatch any event on a Node.\n * @docs-private\n */\nfunction dispatchEvent(node, event) {\n    node.dispatchEvent(event);\n    return event;\n}\n/**\n * Shorthand to dispatch a fake event on a specified node.\n * @docs-private\n */\nfunction dispatchFakeEvent(node, type, bubbles) {\n    return dispatchEvent(node, createFakeEvent(type, bubbles));\n}\n/**\n * Shorthand to dispatch a keyboard event with a specified key code and\n * optional modifiers.\n * @docs-private\n */\nfunction dispatchKeyboardEvent(node, type, keyCode, key, modifiers) {\n    return dispatchEvent(node, createKeyboardEvent(type, keyCode, key, modifiers));\n}\n/**\n * Shorthand to dispatch a mouse event on the specified coordinates.\n * @docs-private\n */\nfunction dispatchMouseEvent(node, type, clientX = 0, clientY = 0, offsetX, offsetY, button, modifiers) {\n    return dispatchEvent(node, createMouseEvent(type, clientX, clientY, offsetX, offsetY, button, modifiers));\n}\n/**\n * Shorthand to dispatch a pointer event on the specified coordinates.\n * @docs-private\n */\nfunction dispatchPointerEvent(node, type, clientX = 0, clientY = 0, offsetX, offsetY, options) {\n    return dispatchEvent(node, createPointerEvent(type, clientX, clientY, offsetX, offsetY, options));\n}\n/**\n * Shorthand to dispatch a touch event on the specified coordinates.\n * @docs-private\n */\nfunction dispatchTouchEvent(node, type, pageX = 0, pageY = 0, clientX = 0, clientY = 0) {\n    return dispatchEvent(node, createTouchEvent(type, pageX, pageY, clientX, clientY));\n}\n\nfunction triggerFocusChange(element, event) {\n    let eventFired = false;\n    const handler = () => (eventFired = true);\n    element.addEventListener(event, handler);\n    element[event]();\n    element.removeEventListener(event, handler);\n    if (!eventFired) {\n        dispatchFakeEvent(element, event);\n    }\n}\n/**\n * Patches an elements focus and blur methods to emit events consistently and predictably.\n * This is necessary, because some browsers can call the focus handlers asynchronously,\n * while others won't fire them at all if the browser window is not focused.\n * @docs-private\n */\n// TODO: Check if this element focus patching is still needed for local testing,\n// where browser is not necessarily focused.\nfunction patchElementFocus(element) {\n    element.focus = () => dispatchFakeEvent(element, 'focus');\n    element.blur = () => dispatchFakeEvent(element, 'blur');\n}\n/** @docs-private */\nfunction triggerFocus(element) {\n    triggerFocusChange(element, 'focus');\n}\n/** @docs-private */\nfunction triggerBlur(element) {\n    triggerFocusChange(element, 'blur');\n}\n\n/** Input types for which the value can be entered incrementally. */\nconst incrementalInputTypes = new Set([\n    'text',\n    'email',\n    'hidden',\n    'password',\n    'search',\n    'tel',\n    'url',\n]);\n/**\n * Checks whether the given Element is a text input element.\n * @docs-private\n */\nfunction isTextInput(element) {\n    const nodeName = element.nodeName.toLowerCase();\n    return nodeName === 'input' || nodeName === 'textarea';\n}\nfunction typeInElement(element, ...modifiersAndKeys) {\n    const first = modifiersAndKeys[0];\n    let modifiers;\n    let rest;\n    if (first !== undefined &&\n        typeof first !== 'string' &&\n        first.keyCode === undefined &&\n        first.key === undefined) {\n        modifiers = first;\n        rest = modifiersAndKeys.slice(1);\n    }\n    else {\n        modifiers = {};\n        rest = modifiersAndKeys;\n    }\n    const isInput = isTextInput(element);\n    const inputType = element.getAttribute('type') || 'text';\n    const keys = rest\n        .map(k => typeof k === 'string'\n        ? k.split('').map(c => ({ keyCode: c.toUpperCase().charCodeAt(0), key: c }))\n        : [k])\n        .reduce((arr, k) => arr.concat(k), []);\n    // Throw an error if no keys have been specified. Calling this function with no\n    // keys should not result in a focus event being dispatched unexpectedly.\n    if (keys.length === 0) {\n        throw getNoKeysSpecifiedError();\n    }\n    // We simulate the user typing in a value by incrementally assigning the value below. The problem\n    // is that for some input types, the browser won't allow for an invalid value to be set via the\n    // `value` property which will always be the case when going character-by-character. If we detect\n    // such an input, we have to set the value all at once or listeners to the `input` event (e.g.\n    // the `ReactiveFormsModule` uses such an approach) won't receive the correct value.\n    const enterValueIncrementally = inputType === 'number'\n        ? // The value can be set character by character in number inputs if it doesn't have any decimals.\n            keys.every(key => key.key !== '.' && key.key !== '-' && key.keyCode !== PERIOD)\n        : incrementalInputTypes.has(inputType);\n    triggerFocus(element);\n    // When we aren't entering the value incrementally, assign it all at once ahead\n    // of time so that any listeners to the key events below will have access to it.\n    if (!enterValueIncrementally) {\n        element.value = keys.reduce((value, key) => value + (key.key || ''), '');\n    }\n    for (const key of keys) {\n        dispatchKeyboardEvent(element, 'keydown', key.keyCode, key.key, modifiers);\n        dispatchKeyboardEvent(element, 'keypress', key.keyCode, key.key, modifiers);\n        if (isInput && key.key && key.key.length === 1) {\n            if (enterValueIncrementally) {\n                element.value += key.key;\n                dispatchFakeEvent(element, 'input');\n            }\n        }\n        dispatchKeyboardEvent(element, 'keyup', key.keyCode, key.key, modifiers);\n    }\n    // Since we weren't dispatching `input` events while sending the keys, we have to do it now.\n    if (!enterValueIncrementally) {\n        dispatchFakeEvent(element, 'input');\n    }\n}\n/**\n * Clears the text in an input or textarea element.\n * @docs-private\n */\nfunction clearElement(element) {\n    triggerFocus(element);\n    element.value = '';\n    dispatchFakeEvent(element, 'input');\n}\n\n// These are private APIs that are used both by the public APIs inside of this package, as well\n\n/** Maps `TestKey` constants to the `keyCode` and `key` values used by native browser events. */\nconst keyMap = {\n    [TestKey.BACKSPACE]: { keyCode: keyCodes.BACKSPACE, key: 'Backspace' },\n    [TestKey.TAB]: { keyCode: keyCodes.TAB, key: 'Tab' },\n    [TestKey.ENTER]: { keyCode: keyCodes.ENTER, key: 'Enter' },\n    [TestKey.SHIFT]: { keyCode: keyCodes.SHIFT, key: 'Shift' },\n    [TestKey.CONTROL]: { keyCode: keyCodes.CONTROL, key: 'Control' },\n    [TestKey.ALT]: { keyCode: keyCodes.ALT, key: 'Alt' },\n    [TestKey.ESCAPE]: { keyCode: keyCodes.ESCAPE, key: 'Escape' },\n    [TestKey.PAGE_UP]: { keyCode: keyCodes.PAGE_UP, key: 'PageUp' },\n    [TestKey.PAGE_DOWN]: { keyCode: keyCodes.PAGE_DOWN, key: 'PageDown' },\n    [TestKey.END]: { keyCode: keyCodes.END, key: 'End' },\n    [TestKey.HOME]: { keyCode: keyCodes.HOME, key: 'Home' },\n    [TestKey.LEFT_ARROW]: { keyCode: keyCodes.LEFT_ARROW, key: 'ArrowLeft' },\n    [TestKey.UP_ARROW]: { keyCode: keyCodes.UP_ARROW, key: 'ArrowUp' },\n    [TestKey.RIGHT_ARROW]: { keyCode: keyCodes.RIGHT_ARROW, key: 'ArrowRight' },\n    [TestKey.DOWN_ARROW]: { keyCode: keyCodes.DOWN_ARROW, key: 'ArrowDown' },\n    [TestKey.INSERT]: { keyCode: keyCodes.INSERT, key: 'Insert' },\n    [TestKey.DELETE]: { keyCode: keyCodes.DELETE, key: 'Delete' },\n    [TestKey.F1]: { keyCode: keyCodes.F1, key: 'F1' },\n    [TestKey.F2]: { keyCode: keyCodes.F2, key: 'F2' },\n    [TestKey.F3]: { keyCode: keyCodes.F3, key: 'F3' },\n    [TestKey.F4]: { keyCode: keyCodes.F4, key: 'F4' },\n    [TestKey.F5]: { keyCode: keyCodes.F5, key: 'F5' },\n    [TestKey.F6]: { keyCode: keyCodes.F6, key: 'F6' },\n    [TestKey.F7]: { keyCode: keyCodes.F7, key: 'F7' },\n    [TestKey.F8]: { keyCode: keyCodes.F8, key: 'F8' },\n    [TestKey.F9]: { keyCode: keyCodes.F9, key: 'F9' },\n    [TestKey.F10]: { keyCode: keyCodes.F10, key: 'F10' },\n    [TestKey.F11]: { keyCode: keyCodes.F11, key: 'F11' },\n    [TestKey.F12]: { keyCode: keyCodes.F12, key: 'F12' },\n    [TestKey.META]: { keyCode: keyCodes.META, key: 'Meta' },\n    [TestKey.COMMA]: { keyCode: keyCodes.COMMA, key: ',' },\n};\n/** A `TestElement` implementation for unit tests. */\nclass UnitTestElement {\n    constructor(element, _stabilize) {\n        this.element = element;\n        this._stabilize = _stabilize;\n    }\n    /** Blur the element. */\n    async blur() {\n        triggerBlur(this.element);\n        await this._stabilize();\n    }\n    /** Clear the element's input (for input and textarea elements only). */\n    async clear() {\n        if (!isTextInput(this.element)) {\n            throw Error('Attempting to clear an invalid element');\n        }\n        clearElement(this.element);\n        await this._stabilize();\n    }\n    async click(...args) {\n        const isDisabled = this.element.disabled === true;\n        // If the element is `disabled` and has a `disabled` property, we emit the mouse event\n        // sequence but not dispatch the `click` event. This is necessary to keep the behavior\n        // consistent with an actual user interaction. The click event is not necessarily\n        // automatically prevented by the browser. There is mismatch between Firefox and Chromium:\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=329509.\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1115661.\n        await this._dispatchMouseEventSequence(isDisabled ? null : 'click', args, 0);\n        await this._stabilize();\n    }\n    async rightClick(...args) {\n        await this._dispatchMouseEventSequence('contextmenu', args, 2);\n        await this._stabilize();\n    }\n    /** Focus the element. */\n    async focus() {\n        triggerFocus(this.element);\n        await this._stabilize();\n    }\n    /** Get the computed value of the given CSS property for the element. */\n    async getCssValue(property) {\n        await this._stabilize();\n        // TODO(mmalerba): Consider adding value normalization if we run into common cases where its\n        //  needed.\n        return getComputedStyle(this.element).getPropertyValue(property);\n    }\n    /** Hovers the mouse over the element. */\n    async hover() {\n        this._dispatchPointerEventIfSupported('pointerenter');\n        dispatchMouseEvent(this.element, 'mouseover');\n        dispatchMouseEvent(this.element, 'mouseenter');\n        await this._stabilize();\n    }\n    /** Moves the mouse away from the element. */\n    async mouseAway() {\n        this._dispatchPointerEventIfSupported('pointerleave');\n        dispatchMouseEvent(this.element, 'mouseout');\n        dispatchMouseEvent(this.element, 'mouseleave');\n        await this._stabilize();\n    }\n    async sendKeys(...modifiersAndKeys) {\n        const args = modifiersAndKeys.map(k => (typeof k === 'number' ? keyMap[k] : k));\n        typeInElement(this.element, ...args);\n        await this._stabilize();\n    }\n    /**\n     * Gets the text from the element.\n     * @param options Options that affect what text is included.\n     */\n    async text(options) {\n        await this._stabilize();\n        if (options?.exclude) {\n            return _getTextWithExcludedElements(this.element, options.exclude);\n        }\n        return (this.element.textContent || '').trim();\n    }\n    /**\n     * Sets the value of a `contenteditable` element.\n     * @param value Value to be set on the element.\n     */\n    async setContenteditableValue(value) {\n        const contenteditableAttr = await this.getAttribute('contenteditable');\n        if (contenteditableAttr !== '' && contenteditableAttr !== 'true') {\n            throw new Error('setContenteditableValue can only be called on a `contenteditable` element.');\n        }\n        await this._stabilize();\n        this.element.textContent = value;\n    }\n    /** Gets the value for the given attribute from the element. */\n    async getAttribute(name) {\n        await this._stabilize();\n        return this.element.getAttribute(name);\n    }\n    /** Checks whether the element has the given class. */\n    async hasClass(name) {\n        await this._stabilize();\n        return this.element.classList.contains(name);\n    }\n    /** Gets the dimensions of the element. */\n    async getDimensions() {\n        await this._stabilize();\n        return this.element.getBoundingClientRect();\n    }\n    /** Gets the value of a property of an element. */\n    async getProperty(name) {\n        await this._stabilize();\n        return this.element[name];\n    }\n    /** Sets the value of a property of an input. */\n    async setInputValue(value) {\n        this.element.value = value;\n        await this._stabilize();\n    }\n    /** Selects the options at the specified indexes inside of a native `select` element. */\n    async selectOptions(...optionIndexes) {\n        let hasChanged = false;\n        const options = this.element.querySelectorAll('option');\n        const indexes = new Set(optionIndexes); // Convert to a set to remove duplicates.\n        for (let i = 0; i < options.length; i++) {\n            const option = options[i];\n            const wasSelected = option.selected;\n            // We have to go through `option.selected`, because `HTMLSelectElement.value` doesn't\n            // allow for multiple options to be selected, even in `multiple` mode.\n            option.selected = indexes.has(i);\n            if (option.selected !== wasSelected) {\n                hasChanged = true;\n                dispatchFakeEvent(this.element, 'change');\n            }\n        }\n        if (hasChanged) {\n            await this._stabilize();\n        }\n    }\n    /** Checks whether this element matches the given selector. */\n    async matchesSelector(selector) {\n        await this._stabilize();\n        const elementPrototype = Element.prototype;\n        return (elementPrototype['matches'] || elementPrototype['msMatchesSelector']).call(this.element, selector);\n    }\n    /** Checks whether the element is focused. */\n    async isFocused() {\n        await this._stabilize();\n        return document.activeElement === this.element;\n    }\n    /**\n     * Dispatches an event with a particular name.\n     * @param name Name of the event to be dispatched.\n     */\n    async dispatchEvent(name, data) {\n        const event = createFakeEvent(name);\n        if (data) {\n            // tslint:disable-next-line:ban Have to use `Object.assign` to preserve the original object.\n            Object.assign(event, data);\n        }\n        dispatchEvent(this.element, event);\n        await this._stabilize();\n    }\n    /**\n     * Dispatches a pointer event on the current element if the browser supports it.\n     * @param name Name of the pointer event to be dispatched.\n     * @param clientX Coordinate of the user's pointer along the X axis.\n     * @param clientY Coordinate of the user's pointer along the Y axis.\n     * @param button Mouse button that should be pressed when dispatching the event.\n     */\n    _dispatchPointerEventIfSupported(name, clientX, clientY, offsetX, offsetY, button) {\n        // The latest versions of all browsers we support have the new `PointerEvent` API.\n        // Though since we capture the two most recent versions of these browsers, we also\n        // need to support Safari 12 at time of writing. Safari 12 does not have support for this,\n        // so we need to conditionally create and dispatch these events based on feature detection.\n        if (typeof PointerEvent !== 'undefined' && PointerEvent) {\n            dispatchPointerEvent(this.element, name, clientX, clientY, offsetX, offsetY, {\n                isPrimary: true,\n                button,\n            });\n        }\n    }\n    /**\n     * Dispatches all the events that are part of a mouse event sequence\n     * and then emits a given primary event at the end, if speciifed.\n     */\n    async _dispatchMouseEventSequence(primaryEventName, args, button) {\n        let clientX = undefined;\n        let clientY = undefined;\n        let offsetX = undefined;\n        let offsetY = undefined;\n        let modifiers = {};\n        if (args.length && typeof args[args.length - 1] === 'object') {\n            modifiers = args.pop();\n        }\n        if (args.length) {\n            const { left, top, width, height } = await this.getDimensions();\n            offsetX = args[0] === 'center' ? width / 2 : args[0];\n            offsetY = args[0] === 'center' ? height / 2 : args[1];\n            // Round the computed click position as decimal pixels are not\n            // supported by mouse events and could lead to unexpected results.\n            clientX = Math.round(left + offsetX);\n            clientY = Math.round(top + offsetY);\n        }\n        this._dispatchPointerEventIfSupported('pointerdown', clientX, clientY, offsetX, offsetY, button);\n        dispatchMouseEvent(this.element, 'mousedown', clientX, clientY, offsetX, offsetY, button, modifiers);\n        this._dispatchPointerEventIfSupported('pointerup', clientX, clientY, offsetX, offsetY, button);\n        dispatchMouseEvent(this.element, 'mouseup', clientX, clientY, offsetX, offsetY, button, modifiers);\n        // If a primary event name is specified, emit it after the mouse event sequence.\n        if (primaryEventName !== null) {\n            dispatchMouseEvent(this.element, primaryEventName, clientX, clientY, offsetX, offsetY, button, modifiers);\n        }\n        // This call to _stabilize should not be needed since the callers will already do that them-\n        // selves. Nevertheless it breaks some tests in g3 without it. It needs to be investigated\n        // why removing breaks those tests.\n        // See: https://github.com/angular/components/pull/20758/files#r520886256.\n        await this._stabilize();\n    }\n}\n\n/** The default environment options. */\nconst defaultEnvironmentOptions = {\n    queryFn: (selector, root) => root.querySelectorAll(selector),\n};\n/** Whether auto change detection is currently disabled. */\nlet disableAutoChangeDetection = false;\n/**\n * The set of non-destroyed fixtures currently being used by `TestbedHarnessEnvironment` instances.\n */\nconst activeFixtures = new Set();\n/**\n * Installs a handler for change detection batching status changes for a specific fixture.\n * @param fixture The fixture to handle change detection batching for.\n */\nfunction installAutoChangeDetectionStatusHandler(fixture) {\n    if (!activeFixtures.size) {\n        handleAutoChangeDetectionStatus(({ isDisabled, onDetectChangesNow }) => {\n            disableAutoChangeDetection = isDisabled;\n            if (onDetectChangesNow) {\n                Promise.all(Array.from(activeFixtures).map(detectChanges)).then(onDetectChangesNow);\n            }\n        });\n    }\n    activeFixtures.add(fixture);\n}\n/**\n * Uninstalls a handler for change detection batching status changes for a specific fixture.\n * @param fixture The fixture to stop handling change detection batching for.\n */\nfunction uninstallAutoChangeDetectionStatusHandler(fixture) {\n    activeFixtures.delete(fixture);\n    if (!activeFixtures.size) {\n        stopHandlingAutoChangeDetectionStatus();\n    }\n}\n/** Whether we are currently in the fake async zone. */\nfunction isInFakeAsyncZone() {\n    return typeof Zone !== 'undefined' && Zone.current.get('FakeAsyncTestZoneSpec') != null;\n}\n/**\n * Triggers change detection for a specific fixture.\n * @param fixture The fixture to trigger change detection for.\n */\nasync function detectChanges(fixture) {\n    fixture.detectChanges();\n    if (isInFakeAsyncZone()) {\n        flush();\n    }\n    else {\n        await fixture.whenStable();\n    }\n}\n/** A `HarnessEnvironment` implementation for Angular's Testbed. */\nclass TestbedHarnessEnvironment extends HarnessEnvironment {\n    constructor(rawRootElement, _fixture, options) {\n        super(rawRootElement);\n        this._fixture = _fixture;\n        /** Whether the environment has been destroyed. */\n        this._destroyed = false;\n        this._options = { ...defaultEnvironmentOptions, ...options };\n        if (typeof Zone !== 'undefined') {\n            this._taskState = TaskStateZoneInterceptor.setup();\n        }\n        this._stabilizeCallback = () => this.forceStabilize();\n        installAutoChangeDetectionStatusHandler(_fixture);\n        _fixture.componentRef.onDestroy(() => {\n            uninstallAutoChangeDetectionStatusHandler(_fixture);\n            this._destroyed = true;\n        });\n    }\n    /** Creates a `HarnessLoader` rooted at the given fixture's root element. */\n    static loader(fixture, options) {\n        return new TestbedHarnessEnvironment(fixture.nativeElement, fixture, options);\n    }\n    /**\n     * Creates a `HarnessLoader` at the document root. This can be used if harnesses are\n     * located outside of a fixture (e.g. overlays appended to the document body).\n     */\n    static documentRootLoader(fixture, options) {\n        return new TestbedHarnessEnvironment(document.body, fixture, options);\n    }\n    /** Gets the native DOM element corresponding to the given TestElement. */\n    static getNativeElement(el) {\n        if (el instanceof UnitTestElement) {\n            return el.element;\n        }\n        throw Error('This TestElement was not created by the TestbedHarnessEnvironment');\n    }\n    /**\n     * Creates an instance of the given harness type, using the fixture's root element as the\n     * harness's host element. This method should be used when creating a harness for the root element\n     * of a fixture, as components do not have the correct selector when they are created as the root\n     * of the fixture.\n     */\n    static async harnessForFixture(fixture, harnessType, options) {\n        const environment = new TestbedHarnessEnvironment(fixture.nativeElement, fixture, options);\n        await environment.forceStabilize();\n        return environment.createComponentHarness(harnessType, fixture.nativeElement);\n    }\n    /**\n     * Flushes change detection and async tasks captured in the Angular zone.\n     * In most cases it should not be necessary to call this manually. However, there may be some edge\n     * cases where it is needed to fully flush animation events.\n     */\n    async forceStabilize() {\n        if (!disableAutoChangeDetection) {\n            if (this._destroyed) {\n                throw Error('Harness is attempting to use a fixture that has already been destroyed.');\n            }\n            await detectChanges(this._fixture);\n        }\n    }\n    /**\n     * Waits for all scheduled or running async tasks to complete. This allows harness\n     * authors to wait for async tasks outside of the Angular zone.\n     */\n    async waitForTasksOutsideAngular() {\n        // If we run in the fake async zone, we run \"flush\" to run any scheduled tasks. This\n        // ensures that the harnesses behave inside of the FakeAsyncTestZone similar to the\n        // \"AsyncTestZone\" and the root zone (i.e. neither fakeAsync or async). Note that we\n        // cannot just rely on the task state observable to become stable because the state will\n        // never change. This is because the task queue will be only drained if the fake async\n        // zone is being flushed.\n        if (isInFakeAsyncZone()) {\n            flush();\n        }\n        // Wait until the task queue has been drained and the zone is stable. Note that\n        // we cannot rely on \"fixture.whenStable\" since it does not catch tasks scheduled\n        // outside of the Angular zone. For test harnesses, we want to ensure that the\n        // app is fully stabilized and therefore need to use our own zone interceptor.\n        await this._taskState?.pipe(takeWhile(state => !state.stable)).toPromise();\n    }\n    /** Gets the root element for the document. */\n    getDocumentRoot() {\n        return document.body;\n    }\n    /** Creates a `TestElement` from a raw element. */\n    createTestElement(element) {\n        return new UnitTestElement(element, this._stabilizeCallback);\n    }\n    /** Creates a `HarnessLoader` rooted at the given raw element. */\n    createEnvironment(element) {\n        return new TestbedHarnessEnvironment(element, this._fixture, this._options);\n    }\n    /**\n     * Gets a list of all elements matching the given selector under this environment's root element.\n     */\n    async getAllRawElements(selector) {\n        await this.forceStabilize();\n        return Array.from(this._options.queryFn(selector, this.rawRootElement));\n    }\n}\n\nexport { TestbedHarnessEnvironment, UnitTestElement };\n//# sourceMappingURL=testbed.mjs.map\n"],
  "mappings": "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",
  "names": ["import_testing"]
}
