{
  "version": 3,
  "sources": ["/Users/macbook/karpov-work/TrueNAS/webui/node_modules/@angular/material/fesm2022/input/testing.mjs"],
  "sourcesContent": ["import { HarnessPredicate, parallel, ComponentHarness } from '@angular/cdk/testing';\nimport { MatFormFieldControlHarness } from '@angular/material/form-field/testing/control';\n\n/** Harness for interacting with a standard Material inputs in tests. */\nclass MatInputHarness extends MatFormFieldControlHarness {\n    // TODO: We do not want to handle `select` elements with `matNativeControl` because\n    // not all methods of this harness work reasonably for native select elements.\n    // For more details. See: https://github.com/angular/components/pull/18221.\n    static { this.hostSelector = '[matInput], input[matNativeControl], textarea[matNativeControl]'; }\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatInputHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which input instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options = {}) {\n        return new HarnessPredicate(MatInputHarness, options)\n            .addOption('value', options.value, (harness, value) => {\n            return HarnessPredicate.stringMatches(harness.getValue(), value);\n        })\n            .addOption('placeholder', options.placeholder, (harness, placeholder) => {\n            return HarnessPredicate.stringMatches(harness.getPlaceholder(), placeholder);\n        });\n    }\n    /** Whether the input is disabled. */\n    async isDisabled() {\n        return (await this.host()).getProperty('disabled');\n    }\n    /** Whether the input is required. */\n    async isRequired() {\n        return (await this.host()).getProperty('required');\n    }\n    /** Whether the input is readonly. */\n    async isReadonly() {\n        return (await this.host()).getProperty('readOnly');\n    }\n    /** Gets the value of the input. */\n    async getValue() {\n        // The \"value\" property of the native input is never undefined.\n        return await (await this.host()).getProperty('value');\n    }\n    /** Gets the name of the input. */\n    async getName() {\n        // The \"name\" property of the native input is never undefined.\n        return await (await this.host()).getProperty('name');\n    }\n    /**\n     * Gets the type of the input. Returns \"textarea\" if the input is\n     * a textarea.\n     */\n    async getType() {\n        // The \"type\" property of the native input is never undefined.\n        return await (await this.host()).getProperty('type');\n    }\n    /** Gets the placeholder of the input. */\n    async getPlaceholder() {\n        const host = await this.host();\n        const [nativePlaceholder, fallback] = await parallel(() => [\n            host.getProperty('placeholder'),\n            host.getAttribute('data-placeholder'),\n        ]);\n        return nativePlaceholder || fallback || '';\n    }\n    /** Gets the id of the input. */\n    async getId() {\n        // The input directive always assigns a unique id to the input in\n        // case no id has been explicitly specified.\n        return await (await this.host()).getProperty('id');\n    }\n    /**\n     * Focuses the input and returns a promise that indicates when the\n     * action is complete.\n     */\n    async focus() {\n        return (await this.host()).focus();\n    }\n    /**\n     * Blurs the input and returns a promise that indicates when the\n     * action is complete.\n     */\n    async blur() {\n        return (await this.host()).blur();\n    }\n    /** Whether the input is focused. */\n    async isFocused() {\n        return (await this.host()).isFocused();\n    }\n    /**\n     * Sets the value of the input. The value will be set by simulating\n     * keypresses that correspond to the given value.\n     */\n    async setValue(newValue) {\n        const inputEl = await this.host();\n        await inputEl.clear();\n        // We don't want to send keys for the value if the value is an empty\n        // string in order to clear the value. Sending keys with an empty string\n        // still results in unnecessary focus events.\n        if (newValue) {\n            await inputEl.sendKeys(newValue);\n        }\n        // Some input types won't respond to key presses (e.g. `color`) so to be sure that the\n        // value is set, we also set the property after the keyboard sequence. Note that we don't\n        // want to do it before, because it can cause the value to be entered twice.\n        await inputEl.setInputValue(newValue);\n    }\n}\n\n/** Harness for interacting with a native `option` in tests. */\nclass MatNativeOptionHarness extends ComponentHarness {\n    /** Selector used to locate option instances. */\n    static { this.hostSelector = 'select[matNativeControl] option'; }\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatNativeOptionHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which option instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options = {}) {\n        return new HarnessPredicate(MatNativeOptionHarness, options)\n            .addOption('text', options.text, async (harness, title) => HarnessPredicate.stringMatches(await harness.getText(), title))\n            .addOption('index', options.index, async (harness, index) => (await harness.getIndex()) === index)\n            .addOption('isSelected', options.isSelected, async (harness, isSelected) => (await harness.isSelected()) === isSelected);\n    }\n    /** Gets the option's label text. */\n    async getText() {\n        return (await this.host()).getProperty('label');\n    }\n    /** Index of the option within the native `select` element. */\n    async getIndex() {\n        return (await this.host()).getProperty('index');\n    }\n    /** Gets whether the option is disabled. */\n    async isDisabled() {\n        return (await this.host()).getProperty('disabled');\n    }\n    /** Gets whether the option is selected. */\n    async isSelected() {\n        return (await this.host()).getProperty('selected');\n    }\n}\n\n/** Harness for interacting with a native `select` in tests. */\nclass MatNativeSelectHarness extends MatFormFieldControlHarness {\n    static { this.hostSelector = 'select[matNativeControl]'; }\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatNativeSelectHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which select instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options = {}) {\n        return new HarnessPredicate(MatNativeSelectHarness, options);\n    }\n    /** Gets a boolean promise indicating if the select is disabled. */\n    async isDisabled() {\n        return (await this.host()).getProperty('disabled');\n    }\n    /** Gets a boolean promise indicating if the select is required. */\n    async isRequired() {\n        return (await this.host()).getProperty('required');\n    }\n    /** Gets a boolean promise indicating if the select is in multi-selection mode. */\n    async isMultiple() {\n        return (await this.host()).getProperty('multiple');\n    }\n    /** Gets the name of the select. */\n    async getName() {\n        // The \"name\" property of the native select is never undefined.\n        return await (await this.host()).getProperty('name');\n    }\n    /** Gets the id of the select. */\n    async getId() {\n        // We're guaranteed to have an id, because the `matNativeControl` always assigns one.\n        return await (await this.host()).getProperty('id');\n    }\n    /** Focuses the select and returns a void promise that indicates when the action is complete. */\n    async focus() {\n        return (await this.host()).focus();\n    }\n    /** Blurs the select and returns a void promise that indicates when the action is complete. */\n    async blur() {\n        return (await this.host()).blur();\n    }\n    /** Whether the select is focused. */\n    async isFocused() {\n        return (await this.host()).isFocused();\n    }\n    /** Gets the options inside the select panel. */\n    async getOptions(filter = {}) {\n        return this.locatorForAll(MatNativeOptionHarness.with(filter))();\n    }\n    /**\n     * Selects the options that match the passed-in filter. If the select is in multi-selection\n     * mode all options will be clicked, otherwise the harness will pick the first matching option.\n     */\n    async selectOptions(filter = {}) {\n        const [isMultiple, options] = await parallel(() => {\n            return [this.isMultiple(), this.getOptions(filter)];\n        });\n        if (options.length === 0) {\n            throw Error('Select does not have options matching the specified filter');\n        }\n        const [host, optionIndexes] = await parallel(() => [\n            this.host(),\n            parallel(() => options.slice(0, isMultiple ? undefined : 1).map(option => option.getIndex())),\n        ]);\n        await host.selectOptions(...optionIndexes);\n    }\n}\n\nexport { MatInputHarness, MatNativeOptionHarness, MatNativeSelectHarness };\n//# sourceMappingURL=testing.mjs.map\n"],
  "mappings": "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",
  "names": []
}
