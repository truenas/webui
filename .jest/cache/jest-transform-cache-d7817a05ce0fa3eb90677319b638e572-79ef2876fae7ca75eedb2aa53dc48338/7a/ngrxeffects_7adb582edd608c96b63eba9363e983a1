a16cfef572de0abd63c48ce7df12e7a8
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ngrx_effects_exports = {};
__export(ngrx_effects_exports, {
  Actions: () => Actions,
  EFFECTS_ERROR_HANDLER: () => EFFECTS_ERROR_HANDLER,
  EffectSources: () => EffectSources,
  EffectsFeatureModule: () => EffectsFeatureModule,
  EffectsModule: () => EffectsModule,
  EffectsRootModule: () => EffectsRootModule,
  EffectsRunner: () => EffectsRunner,
  ROOT_EFFECTS_INIT: () => ROOT_EFFECTS_INIT,
  USER_PROVIDED_EFFECTS: () => USER_PROVIDED_EFFECTS,
  act: () => act,
  createEffect: () => createEffect,
  defaultEffectsErrorHandler: () => defaultEffectsErrorHandler,
  getEffectsMetadata: () => getEffectsMetadata,
  mergeEffects: () => mergeEffects,
  ofType: () => ofType,
  provideEffects: () => provideEffects,
  rootEffectsInit: () => rootEffectsInit
});
module.exports = __toCommonJS(ngrx_effects_exports);
var i1 = __toESM(require("rxjs"), 1);
var import_rxjs = require("rxjs");
var import_operators = require("rxjs/operators");
var i0 = __toESM(require("@angular/core"), 1);
var import_core = require("@angular/core");
var i3 = __toESM(require("@ngrx/store"), 1);
var import_store = require("@ngrx/store");
const DEFAULT_EFFECT_CONFIG = {
  dispatch: true,
  functional: false,
  useEffectsErrorHandler: true
};
const CREATE_EFFECT_METADATA_KEY = "__@ngrx/effects_create__";
function createEffect(source, config = {}) {
  const effect = config.functional ? source : source();
  const value = __spreadValues(__spreadValues({}, DEFAULT_EFFECT_CONFIG), config);
  Object.defineProperty(effect, CREATE_EFFECT_METADATA_KEY, {
    value
  });
  return effect;
}
function getCreateEffectMetadata(instance) {
  const propertyNames = Object.getOwnPropertyNames(instance);
  const metadata = propertyNames.filter((propertyName) => {
    if (instance[propertyName] && instance[propertyName].hasOwnProperty(CREATE_EFFECT_METADATA_KEY)) {
      const property = instance[propertyName];
      return property[CREATE_EFFECT_METADATA_KEY].hasOwnProperty("dispatch");
    }
    return false;
  }).map((propertyName) => {
    const metaData = instance[propertyName][CREATE_EFFECT_METADATA_KEY];
    return __spreadValues({
      propertyName
    }, metaData);
  });
  return metadata;
}
function getEffectsMetadata(instance) {
  return getSourceMetadata(instance).reduce((acc, { propertyName, dispatch, useEffectsErrorHandler }) => {
    acc[propertyName] = { dispatch, useEffectsErrorHandler };
    return acc;
  }, {});
}
function getSourceMetadata(instance) {
  return getCreateEffectMetadata(instance);
}
function getSourceForInstance(instance) {
  return Object.getPrototypeOf(instance);
}
function isClassInstance(obj) {
  return !!obj.constructor && obj.constructor.name !== "Object" && obj.constructor.name !== "Function";
}
function isClass(classOrRecord) {
  return typeof classOrRecord === "function";
}
function getClasses(classesAndRecords) {
  return classesAndRecords.filter(isClass);
}
function isToken(tokenOrRecord) {
  return tokenOrRecord instanceof import_core.InjectionToken || isClass(tokenOrRecord);
}
function mergeEffects(sourceInstance, globalErrorHandler, effectsErrorHandler) {
  const source = getSourceForInstance(sourceInstance);
  const isClassBasedEffect = !!source && source.constructor.name !== "Object";
  const sourceName = isClassBasedEffect ? source.constructor.name : null;
  const observables$ = getSourceMetadata(sourceInstance).map(({ propertyName, dispatch, useEffectsErrorHandler }) => {
    const observable$ = typeof sourceInstance[propertyName] === "function" ? sourceInstance[propertyName]() : sourceInstance[propertyName];
    const effectAction$ = useEffectsErrorHandler ? effectsErrorHandler(observable$, globalErrorHandler) : observable$;
    if (dispatch === false) {
      return effectAction$.pipe((0, import_operators.ignoreElements)());
    }
    const materialized$ = effectAction$.pipe((0, import_operators.materialize)());
    return materialized$.pipe((0, import_operators.map)((notification) => ({
      effect: sourceInstance[propertyName],
      notification,
      propertyName,
      sourceName,
      sourceInstance
    })));
  });
  return (0, import_rxjs.merge)(...observables$);
}
const MAX_NUMBER_OF_RETRY_ATTEMPTS = 10;
function defaultEffectsErrorHandler(observable$, errorHandler, retryAttemptLeft = MAX_NUMBER_OF_RETRY_ATTEMPTS) {
  return observable$.pipe((0, import_operators.catchError)((error) => {
    if (errorHandler)
      errorHandler.handleError(error);
    if (retryAttemptLeft <= 1) {
      return observable$;
    }
    return defaultEffectsErrorHandler(observable$, errorHandler, retryAttemptLeft - 1);
  }));
}
const _Actions = class _Actions extends import_rxjs.Observable {
  constructor(source) {
    super();
    if (source) {
      this.source = source;
    }
  }
  lift(operator) {
    const observable = new _Actions();
    observable.source = this;
    observable.operator = operator;
    return observable;
  }
};
_Actions.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _Actions, deps: [{ token: import_store.ScannedActionsSubject }], target: i0.\u0275\u0275FactoryTarget.Injectable });
_Actions.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _Actions, providedIn: "root" });
let Actions = _Actions;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: Actions, decorators: [{
  type: import_core.Injectable,
  args: [{ providedIn: "root" }]
}], ctorParameters: () => [{ type: i1.Observable, decorators: [{
  type: import_core.Inject,
  args: [import_store.ScannedActionsSubject]
}] }] });
function ofType(...allowedTypes) {
  return (0, import_operators.filter)((action) => allowedTypes.some((typeOrActionCreator) => {
    if (typeof typeOrActionCreator === "string") {
      return typeOrActionCreator === action.type;
    }
    return typeOrActionCreator.type === action.type;
  }));
}
const _ROOT_EFFECTS_GUARD = new import_core.InjectionToken("@ngrx/effects Internal Root Guard");
const USER_PROVIDED_EFFECTS = new import_core.InjectionToken("@ngrx/effects User Provided Effects");
const _ROOT_EFFECTS = new import_core.InjectionToken("@ngrx/effects Internal Root Effects");
const _ROOT_EFFECTS_INSTANCES = new import_core.InjectionToken("@ngrx/effects Internal Root Effects Instances");
const _FEATURE_EFFECTS = new import_core.InjectionToken("@ngrx/effects Internal Feature Effects");
const _FEATURE_EFFECTS_INSTANCE_GROUPS = new import_core.InjectionToken("@ngrx/effects Internal Feature Effects Instance Groups");
const EFFECTS_ERROR_HANDLER = new import_core.InjectionToken("@ngrx/effects Effects Error Handler", { providedIn: "root", factory: () => defaultEffectsErrorHandler });
const ROOT_EFFECTS_INIT = "@ngrx/effects/init";
const rootEffectsInit = (0, import_store.createAction)(ROOT_EFFECTS_INIT);
function reportInvalidActions(output, reporter) {
  if (output.notification.kind === "N") {
    const action = output.notification.value;
    const isInvalidAction = !isAction(action);
    if (isInvalidAction) {
      reporter.handleError(new Error(`Effect ${getEffectName(output)} dispatched an invalid action: ${stringify(action)}`));
    }
  }
}
function isAction(action) {
  return typeof action !== "function" && action && action.type && typeof action.type === "string";
}
function getEffectName({ propertyName, sourceInstance, sourceName }) {
  const isMethod = typeof sourceInstance[propertyName] === "function";
  const isClassBasedEffect = !!sourceName;
  return isClassBasedEffect ? `"${sourceName}.${String(propertyName)}${isMethod ? "()" : ""}"` : `"${String(propertyName)}()"`;
}
function stringify(action) {
  try {
    return JSON.stringify(action);
  } catch (e) {
    return action;
  }
}
const onIdentifyEffectsKey = "ngrxOnIdentifyEffects";
function isOnIdentifyEffects(instance) {
  return isFunction(instance, onIdentifyEffectsKey);
}
const onRunEffectsKey = "ngrxOnRunEffects";
function isOnRunEffects(instance) {
  return isFunction(instance, onRunEffectsKey);
}
const onInitEffects = "ngrxOnInitEffects";
function isOnInitEffects(instance) {
  return isFunction(instance, onInitEffects);
}
function isFunction(instance, functionName) {
  return instance && functionName in instance && typeof instance[functionName] === "function";
}
const _EffectSources = class _EffectSources extends import_rxjs.Subject {
  constructor(errorHandler, effectsErrorHandler) {
    super();
    this.errorHandler = errorHandler;
    this.effectsErrorHandler = effectsErrorHandler;
  }
  addEffects(effectSourceInstance) {
    this.next(effectSourceInstance);
  }
  /**
   * @internal
   */
  toActions() {
    return this.pipe((0, import_operators.groupBy)((effectsInstance2) => isClassInstance(effectsInstance2) ? getSourceForInstance(effectsInstance2) : effectsInstance2), (0, import_operators.mergeMap)((source$) => {
      return source$.pipe((0, import_operators.groupBy)(effectsInstance));
    }), (0, import_operators.mergeMap)((source$) => {
      const effect$ = source$.pipe((0, import_operators.exhaustMap)((sourceInstance) => {
        return resolveEffectSource(this.errorHandler, this.effectsErrorHandler)(sourceInstance);
      }), (0, import_operators.map)((output) => {
        reportInvalidActions(output, this.errorHandler);
        return output.notification;
      }), (0, import_operators.filter)((notification) => notification.kind === "N" && notification.value != null), (0, import_operators.dematerialize)());
      const init$ = source$.pipe((0, import_operators.take)(1), (0, import_operators.filter)(isOnInitEffects), (0, import_operators.map)((instance) => instance.ngrxOnInitEffects()));
      return (0, import_rxjs.merge)(effect$, init$);
    }));
  }
};
_EffectSources.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _EffectSources, deps: [{ token: i0.ErrorHandler }, { token: EFFECTS_ERROR_HANDLER }], target: i0.\u0275\u0275FactoryTarget.Injectable });
_EffectSources.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _EffectSources, providedIn: "root" });
let EffectSources = _EffectSources;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: EffectSources, decorators: [{
  type: import_core.Injectable,
  args: [{ providedIn: "root" }]
}], ctorParameters: () => [{ type: i0.ErrorHandler }, { type: void 0, decorators: [{
  type: import_core.Inject,
  args: [EFFECTS_ERROR_HANDLER]
}] }] });
function effectsInstance(sourceInstance) {
  if (isOnIdentifyEffects(sourceInstance)) {
    return sourceInstance.ngrxOnIdentifyEffects();
  }
  return "";
}
function resolveEffectSource(errorHandler, effectsErrorHandler) {
  return (sourceInstance) => {
    const mergedEffects$ = mergeEffects(sourceInstance, errorHandler, effectsErrorHandler);
    if (isOnRunEffects(sourceInstance)) {
      return sourceInstance.ngrxOnRunEffects(mergedEffects$);
    }
    return mergedEffects$;
  };
}
const _EffectsRunner = class _EffectsRunner {
  get isStarted() {
    return !!this.effectsSubscription;
  }
  constructor(effectSources, store) {
    this.effectSources = effectSources;
    this.store = store;
    this.effectsSubscription = null;
  }
  start() {
    if (!this.effectsSubscription) {
      this.effectsSubscription = this.effectSources.toActions().subscribe(this.store);
    }
  }
  ngOnDestroy() {
    if (this.effectsSubscription) {
      this.effectsSubscription.unsubscribe();
      this.effectsSubscription = null;
    }
  }
};
_EffectsRunner.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _EffectsRunner, deps: [{ token: EffectSources }, { token: i3.Store }], target: i0.\u0275\u0275FactoryTarget.Injectable });
_EffectsRunner.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _EffectsRunner, providedIn: "root" });
let EffectsRunner = _EffectsRunner;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: EffectsRunner, decorators: [{
  type: import_core.Injectable,
  args: [{ providedIn: "root" }]
}], ctorParameters: () => [{ type: EffectSources }, { type: i3.Store }] });
const _EffectsRootModule = class _EffectsRootModule {
  constructor(sources, runner, store, rootEffectsInstances, storeRootModule, storeFeatureModule, guard) {
    this.sources = sources;
    runner.start();
    for (const effectsInstance2 of rootEffectsInstances) {
      sources.addEffects(effectsInstance2);
    }
    store.dispatch({ type: ROOT_EFFECTS_INIT });
  }
  addEffects(effectsInstance2) {
    this.sources.addEffects(effectsInstance2);
  }
};
_EffectsRootModule.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _EffectsRootModule, deps: [{ token: EffectSources }, { token: EffectsRunner }, { token: i3.Store }, { token: _ROOT_EFFECTS_INSTANCES }, { token: i3.StoreRootModule, optional: true }, { token: i3.StoreFeatureModule, optional: true }, { token: _ROOT_EFFECTS_GUARD, optional: true }], target: i0.\u0275\u0275FactoryTarget.NgModule });
_EffectsRootModule.\u0275mod = i0.\u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "18.0.0", ngImport: i0, type: _EffectsRootModule });
_EffectsRootModule.\u0275inj = i0.\u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _EffectsRootModule });
let EffectsRootModule = _EffectsRootModule;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: EffectsRootModule, decorators: [{
  type: import_core.NgModule,
  args: [{}]
}], ctorParameters: () => [{ type: EffectSources }, { type: EffectsRunner }, { type: i3.Store }, { type: void 0, decorators: [{
  type: import_core.Inject,
  args: [_ROOT_EFFECTS_INSTANCES]
}] }, { type: i3.StoreRootModule, decorators: [{
  type: import_core.Optional
}] }, { type: i3.StoreFeatureModule, decorators: [{
  type: import_core.Optional
}] }, { type: void 0, decorators: [{
  type: import_core.Optional
}, {
  type: import_core.Inject,
  args: [_ROOT_EFFECTS_GUARD]
}] }] });
const _EffectsFeatureModule = class _EffectsFeatureModule {
  constructor(effectsRootModule, effectsInstanceGroups, storeRootModule, storeFeatureModule) {
    const effectsInstances = effectsInstanceGroups.flat();
    for (const effectsInstance2 of effectsInstances) {
      effectsRootModule.addEffects(effectsInstance2);
    }
  }
};
_EffectsFeatureModule.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _EffectsFeatureModule, deps: [{ token: EffectsRootModule }, { token: _FEATURE_EFFECTS_INSTANCE_GROUPS }, { token: i3.StoreRootModule, optional: true }, { token: i3.StoreFeatureModule, optional: true }], target: i0.\u0275\u0275FactoryTarget.NgModule });
_EffectsFeatureModule.\u0275mod = i0.\u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "18.0.0", ngImport: i0, type: _EffectsFeatureModule });
_EffectsFeatureModule.\u0275inj = i0.\u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _EffectsFeatureModule });
let EffectsFeatureModule = _EffectsFeatureModule;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: EffectsFeatureModule, decorators: [{
  type: import_core.NgModule,
  args: [{}]
}], ctorParameters: () => [{ type: EffectsRootModule }, { type: void 0, decorators: [{
  type: import_core.Inject,
  args: [_FEATURE_EFFECTS_INSTANCE_GROUPS]
}] }, { type: i3.StoreRootModule, decorators: [{
  type: import_core.Optional
}] }, { type: i3.StoreFeatureModule, decorators: [{
  type: import_core.Optional
}] }] });
const _EffectsModule = class _EffectsModule {
  static forFeature(...featureEffects) {
    const effects = featureEffects.flat();
    const effectsClasses = getClasses(effects);
    return {
      ngModule: EffectsFeatureModule,
      providers: [
        effectsClasses,
        {
          provide: _FEATURE_EFFECTS,
          multi: true,
          useValue: effects
        },
        {
          provide: USER_PROVIDED_EFFECTS,
          multi: true,
          useValue: []
        },
        {
          provide: _FEATURE_EFFECTS_INSTANCE_GROUPS,
          multi: true,
          useFactory: createEffectsInstances,
          deps: [_FEATURE_EFFECTS, USER_PROVIDED_EFFECTS]
        }
      ]
    };
  }
  static forRoot(...rootEffects) {
    const effects = rootEffects.flat();
    const effectsClasses = getClasses(effects);
    return {
      ngModule: EffectsRootModule,
      providers: [
        effectsClasses,
        {
          provide: _ROOT_EFFECTS,
          useValue: [effects]
        },
        {
          provide: _ROOT_EFFECTS_GUARD,
          useFactory: _provideForRootGuard
        },
        {
          provide: USER_PROVIDED_EFFECTS,
          multi: true,
          useValue: []
        },
        {
          provide: _ROOT_EFFECTS_INSTANCES,
          useFactory: createEffectsInstances,
          deps: [_ROOT_EFFECTS, USER_PROVIDED_EFFECTS]
        }
      ]
    };
  }
};
_EffectsModule.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _EffectsModule, deps: [], target: i0.\u0275\u0275FactoryTarget.NgModule });
_EffectsModule.\u0275mod = i0.\u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "18.0.0", ngImport: i0, type: _EffectsModule });
_EffectsModule.\u0275inj = i0.\u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _EffectsModule });
let EffectsModule = _EffectsModule;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: EffectsModule, decorators: [{
  type: import_core.NgModule,
  args: [{}]
}] });
function createEffectsInstances(effectsGroups, userProvidedEffectsGroups) {
  const effects = [];
  for (const effectsGroup of effectsGroups) {
    effects.push(...effectsGroup);
  }
  for (const userProvidedEffectsGroup of userProvidedEffectsGroups) {
    effects.push(...userProvidedEffectsGroup);
  }
  return effects.map((effectsTokenOrRecord) => isToken(effectsTokenOrRecord) ? (0, import_core.inject)(effectsTokenOrRecord) : effectsTokenOrRecord);
}
function _provideForRootGuard() {
  const runner = (0, import_core.inject)(EffectsRunner, { optional: true, skipSelf: true });
  const rootEffects = (0, import_core.inject)(_ROOT_EFFECTS, { self: true });
  const hasEffects = !(rootEffects.length === 1 && rootEffects[0].length === 0);
  if (hasEffects && runner) {
    throw new TypeError(`EffectsModule.forRoot() called twice. Feature modules should use EffectsModule.forFeature() instead.`);
  }
  return "guarded";
}
function act(configOrProject, errorFn) {
  const { project, error, complete, operator, unsubscribe } = typeof configOrProject === "function" ? {
    project: configOrProject,
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    error: errorFn,
    operator: import_operators.concatMap,
    complete: void 0,
    unsubscribe: void 0
  } : __spreadProps(__spreadValues({}, configOrProject), { operator: configOrProject.operator || import_operators.concatMap });
  return (source) => (0, import_rxjs.defer)(() => {
    const subject = new import_rxjs.Subject();
    return (0, import_rxjs.merge)(source.pipe(operator((input, index) => (0, import_rxjs.defer)(() => {
      let completed = false;
      let errored = false;
      let projectedCount = 0;
      return project(input, index).pipe((0, import_operators.materialize)(), (0, import_operators.map)((notification) => {
        switch (notification.kind) {
          case "E":
            errored = true;
            return {
              kind: "N",
              value: error(notification.error, input)
            };
          case "C":
            completed = true;
            return complete ? {
              kind: "N",
              value: complete(projectedCount, input)
            } : void 0;
          default:
            ++projectedCount;
            return notification;
        }
      }), (0, import_operators.filter)((n) => n != null), (0, import_operators.dematerialize)(), (0, import_operators.finalize)(() => {
        if (!completed && !errored && unsubscribe) {
          subject.next(unsubscribe(projectedCount, input));
        }
      }));
    }))), subject);
  });
}
function provideEffects(...effects) {
  const effectsClassesAndRecords = effects.flat();
  const effectsClasses = getClasses(effectsClassesAndRecords);
  return (0, import_core.makeEnvironmentProviders)([
    effectsClasses,
    {
      provide: import_core.ENVIRONMENT_INITIALIZER,
      multi: true,
      useValue: () => {
        (0, import_core.inject)(import_store.ROOT_STORE_PROVIDER);
        (0, import_core.inject)(import_store.FEATURE_STATE_PROVIDER, { optional: true });
        const effectsRunner = (0, import_core.inject)(EffectsRunner);
        const effectSources = (0, import_core.inject)(EffectSources);
        const shouldInitEffects = !effectsRunner.isStarted;
        if (shouldInitEffects) {
          effectsRunner.start();
        }
        for (const effectsClassOrRecord of effectsClassesAndRecords) {
          const effectsInstance2 = isClass(effectsClassOrRecord) ? (0, import_core.inject)(effectsClassOrRecord) : effectsClassOrRecord;
          effectSources.addEffects(effectsInstance2);
        }
        if (shouldInitEffects) {
          const store = (0, import_core.inject)(import_store.Store);
          store.dispatch(rootEffectsInit());
        }
      }
    }
  ]);
}
