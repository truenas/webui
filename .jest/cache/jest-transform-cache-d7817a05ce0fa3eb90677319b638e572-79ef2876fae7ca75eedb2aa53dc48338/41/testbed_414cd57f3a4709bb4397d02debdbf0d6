4a7d58a91d25b152ac6d88355de3c5b4
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var testbed_exports = {};
__export(testbed_exports, {
  TestbedHarnessEnvironment: () => TestbedHarnessEnvironment,
  UnitTestElement: () => UnitTestElement
});
module.exports = __toCommonJS(testbed_exports);
var import_testing = require("@angular/cdk/testing");
var import_testing2 = require("@angular/core/testing");
var import_operators = require("rxjs/operators");
var import_rxjs = require("rxjs");
var keyCodes = __toESM(require("@angular/cdk/keycodes"), 1);
var import_keycodes = require("@angular/cdk/keycodes");
const stateObservableSymbol = Symbol("ProxyZone_PATCHED#stateObservable");
class TaskStateZoneInterceptor {
  constructor(_lastState) {
    this._lastState = _lastState;
    this._stateSubject = new import_rxjs.BehaviorSubject(this._lastState ? this._getTaskStateFromInternalZoneState(this._lastState) : { stable: true });
    this.state = this._stateSubject;
  }
  /** This will be called whenever the task state changes in the intercepted zone. */
  onHasTask(delegate, current, target, hasTaskState) {
    if (current === target) {
      this._stateSubject.next(this._getTaskStateFromInternalZoneState(hasTaskState));
    }
  }
  /** Gets the task state from the internal ZoneJS task state. */
  _getTaskStateFromInternalZoneState(state) {
    return { stable: !state.macroTask && !state.microTask };
  }
  /**
   * Sets up the custom task state Zone interceptor in the  `ProxyZone`. Throws if
   * no `ProxyZone` could be found.
   * @returns an observable that emits whenever the task state changes.
   */
  static setup() {
    if (Zone === void 0) {
      throw Error("Could not find ZoneJS. For test harnesses running in TestBed, ZoneJS needs to be installed.");
    }
    const ProxyZoneSpec = Zone["ProxyZoneSpec"];
    if (!ProxyZoneSpec) {
      throw Error("ProxyZoneSpec is needed for the test harnesses but could not be found. Please make sure that your environment includes zone.js/dist/zone-testing.js");
    }
    const zoneSpec = ProxyZoneSpec.assertPresent();
    if (zoneSpec[stateObservableSymbol]) {
      return zoneSpec[stateObservableSymbol];
    }
    const interceptor = new TaskStateZoneInterceptor(zoneSpec.lastTaskState);
    const zoneSpecOnHasTask = zoneSpec.onHasTask.bind(zoneSpec);
    zoneSpec.onHasTask = function(...args) {
      zoneSpecOnHasTask(...args);
      interceptor.onHasTask(...args);
    };
    return zoneSpec[stateObservableSymbol] = interceptor.state;
  }
}
let uniqueIds = 0;
function createMouseEvent(type, clientX = 0, clientY = 0, offsetX = 0, offsetY = 0, button = 0, modifiers = {}) {
  const screenX = clientX;
  const screenY = clientY;
  const event = new MouseEvent(type, {
    bubbles: true,
    cancelable: true,
    composed: true,
    // Required for shadow DOM events.
    view: window,
    detail: 1,
    relatedTarget: null,
    screenX,
    screenY,
    clientX,
    clientY,
    ctrlKey: modifiers.control,
    altKey: modifiers.alt,
    shiftKey: modifiers.shift,
    metaKey: modifiers.meta,
    button,
    buttons: 1
  });
  if (offsetX != null) {
    defineReadonlyEventProperty(event, "offsetX", offsetX);
  }
  if (offsetY != null) {
    defineReadonlyEventProperty(event, "offsetY", offsetY);
  }
  return event;
}
function createPointerEvent(type, clientX = 0, clientY = 0, offsetX, offsetY, options = { isPrimary: true }) {
  const event = new PointerEvent(type, __spreadValues({
    bubbles: true,
    cancelable: true,
    composed: true,
    // Required for shadow DOM events.
    view: window,
    clientX,
    clientY
  }, options));
  if (offsetX != null) {
    defineReadonlyEventProperty(event, "offsetX", offsetX);
  }
  if (offsetY != null) {
    defineReadonlyEventProperty(event, "offsetY", offsetY);
  }
  return event;
}
function createTouchEvent(type, pageX = 0, pageY = 0, clientX = 0, clientY = 0) {
  const event = document.createEvent("UIEvent");
  const touchDetails = { pageX, pageY, clientX, clientY, identifier: uniqueIds++ };
  event.initUIEvent(type, true, true, window, 0);
  defineReadonlyEventProperty(event, "touches", [touchDetails]);
  defineReadonlyEventProperty(event, "targetTouches", [touchDetails]);
  defineReadonlyEventProperty(event, "changedTouches", [touchDetails]);
  return event;
}
function createKeyboardEvent(type, keyCode = 0, key = "", modifiers = {}) {
  return new KeyboardEvent(type, {
    bubbles: true,
    cancelable: true,
    composed: true,
    // Required for shadow DOM events.
    view: window,
    keyCode,
    key,
    shiftKey: modifiers.shift,
    metaKey: modifiers.meta,
    altKey: modifiers.alt,
    ctrlKey: modifiers.control
  });
}
function createFakeEvent(type, bubbles = false, cancelable = true, composed = true) {
  return new Event(type, { bubbles, cancelable, composed });
}
function defineReadonlyEventProperty(event, propertyName, value) {
  Object.defineProperty(event, propertyName, { get: () => value, configurable: true });
}
function dispatchEvent(node, event) {
  node.dispatchEvent(event);
  return event;
}
function dispatchFakeEvent(node, type, bubbles) {
  return dispatchEvent(node, createFakeEvent(type, bubbles));
}
function dispatchKeyboardEvent(node, type, keyCode, key, modifiers) {
  return dispatchEvent(node, createKeyboardEvent(type, keyCode, key, modifiers));
}
function dispatchMouseEvent(node, type, clientX = 0, clientY = 0, offsetX, offsetY, button, modifiers) {
  return dispatchEvent(node, createMouseEvent(type, clientX, clientY, offsetX, offsetY, button, modifiers));
}
function dispatchPointerEvent(node, type, clientX = 0, clientY = 0, offsetX, offsetY, options) {
  return dispatchEvent(node, createPointerEvent(type, clientX, clientY, offsetX, offsetY, options));
}
function dispatchTouchEvent(node, type, pageX = 0, pageY = 0, clientX = 0, clientY = 0) {
  return dispatchEvent(node, createTouchEvent(type, pageX, pageY, clientX, clientY));
}
function triggerFocusChange(element, event) {
  let eventFired = false;
  const handler = () => eventFired = true;
  element.addEventListener(event, handler);
  element[event]();
  element.removeEventListener(event, handler);
  if (!eventFired) {
    dispatchFakeEvent(element, event);
  }
}
function patchElementFocus(element) {
  element.focus = () => dispatchFakeEvent(element, "focus");
  element.blur = () => dispatchFakeEvent(element, "blur");
}
function triggerFocus(element) {
  triggerFocusChange(element, "focus");
}
function triggerBlur(element) {
  triggerFocusChange(element, "blur");
}
const incrementalInputTypes = /* @__PURE__ */ new Set([
  "text",
  "email",
  "hidden",
  "password",
  "search",
  "tel",
  "url"
]);
function isTextInput(element) {
  const nodeName = element.nodeName.toLowerCase();
  return nodeName === "input" || nodeName === "textarea";
}
function typeInElement(element, ...modifiersAndKeys) {
  const first = modifiersAndKeys[0];
  let modifiers;
  let rest;
  if (first !== void 0 && typeof first !== "string" && first.keyCode === void 0 && first.key === void 0) {
    modifiers = first;
    rest = modifiersAndKeys.slice(1);
  } else {
    modifiers = {};
    rest = modifiersAndKeys;
  }
  const isInput = isTextInput(element);
  const inputType = element.getAttribute("type") || "text";
  const keys = rest.map((k) => typeof k === "string" ? k.split("").map((c) => ({ keyCode: c.toUpperCase().charCodeAt(0), key: c })) : [k]).reduce((arr, k) => arr.concat(k), []);
  if (keys.length === 0) {
    throw (0, import_testing.getNoKeysSpecifiedError)();
  }
  const enterValueIncrementally = inputType === "number" ? (
    // The value can be set character by character in number inputs if it doesn't have any decimals.
    keys.every((key) => key.key !== "." && key.key !== "-" && key.keyCode !== import_keycodes.PERIOD)
  ) : incrementalInputTypes.has(inputType);
  triggerFocus(element);
  if (!enterValueIncrementally) {
    element.value = keys.reduce((value, key) => value + (key.key || ""), "");
  }
  for (const key of keys) {
    dispatchKeyboardEvent(element, "keydown", key.keyCode, key.key, modifiers);
    dispatchKeyboardEvent(element, "keypress", key.keyCode, key.key, modifiers);
    if (isInput && key.key && key.key.length === 1) {
      if (enterValueIncrementally) {
        element.value += key.key;
        dispatchFakeEvent(element, "input");
      }
    }
    dispatchKeyboardEvent(element, "keyup", key.keyCode, key.key, modifiers);
  }
  if (!enterValueIncrementally) {
    dispatchFakeEvent(element, "input");
  }
}
function clearElement(element) {
  triggerFocus(element);
  element.value = "";
  dispatchFakeEvent(element, "input");
}
const keyMap = {
  [import_testing.TestKey.BACKSPACE]: { keyCode: keyCodes.BACKSPACE, key: "Backspace" },
  [import_testing.TestKey.TAB]: { keyCode: keyCodes.TAB, key: "Tab" },
  [import_testing.TestKey.ENTER]: { keyCode: keyCodes.ENTER, key: "Enter" },
  [import_testing.TestKey.SHIFT]: { keyCode: keyCodes.SHIFT, key: "Shift" },
  [import_testing.TestKey.CONTROL]: { keyCode: keyCodes.CONTROL, key: "Control" },
  [import_testing.TestKey.ALT]: { keyCode: keyCodes.ALT, key: "Alt" },
  [import_testing.TestKey.ESCAPE]: { keyCode: keyCodes.ESCAPE, key: "Escape" },
  [import_testing.TestKey.PAGE_UP]: { keyCode: keyCodes.PAGE_UP, key: "PageUp" },
  [import_testing.TestKey.PAGE_DOWN]: { keyCode: keyCodes.PAGE_DOWN, key: "PageDown" },
  [import_testing.TestKey.END]: { keyCode: keyCodes.END, key: "End" },
  [import_testing.TestKey.HOME]: { keyCode: keyCodes.HOME, key: "Home" },
  [import_testing.TestKey.LEFT_ARROW]: { keyCode: keyCodes.LEFT_ARROW, key: "ArrowLeft" },
  [import_testing.TestKey.UP_ARROW]: { keyCode: keyCodes.UP_ARROW, key: "ArrowUp" },
  [import_testing.TestKey.RIGHT_ARROW]: { keyCode: keyCodes.RIGHT_ARROW, key: "ArrowRight" },
  [import_testing.TestKey.DOWN_ARROW]: { keyCode: keyCodes.DOWN_ARROW, key: "ArrowDown" },
  [import_testing.TestKey.INSERT]: { keyCode: keyCodes.INSERT, key: "Insert" },
  [import_testing.TestKey.DELETE]: { keyCode: keyCodes.DELETE, key: "Delete" },
  [import_testing.TestKey.F1]: { keyCode: keyCodes.F1, key: "F1" },
  [import_testing.TestKey.F2]: { keyCode: keyCodes.F2, key: "F2" },
  [import_testing.TestKey.F3]: { keyCode: keyCodes.F3, key: "F3" },
  [import_testing.TestKey.F4]: { keyCode: keyCodes.F4, key: "F4" },
  [import_testing.TestKey.F5]: { keyCode: keyCodes.F5, key: "F5" },
  [import_testing.TestKey.F6]: { keyCode: keyCodes.F6, key: "F6" },
  [import_testing.TestKey.F7]: { keyCode: keyCodes.F7, key: "F7" },
  [import_testing.TestKey.F8]: { keyCode: keyCodes.F8, key: "F8" },
  [import_testing.TestKey.F9]: { keyCode: keyCodes.F9, key: "F9" },
  [import_testing.TestKey.F10]: { keyCode: keyCodes.F10, key: "F10" },
  [import_testing.TestKey.F11]: { keyCode: keyCodes.F11, key: "F11" },
  [import_testing.TestKey.F12]: { keyCode: keyCodes.F12, key: "F12" },
  [import_testing.TestKey.META]: { keyCode: keyCodes.META, key: "Meta" },
  [import_testing.TestKey.COMMA]: { keyCode: keyCodes.COMMA, key: "," }
};
class UnitTestElement {
  constructor(element, _stabilize) {
    this.element = element;
    this._stabilize = _stabilize;
  }
  /** Blur the element. */
  blur() {
    return __async(this, null, function* () {
      triggerBlur(this.element);
      yield this._stabilize();
    });
  }
  /** Clear the element's input (for input and textarea elements only). */
  clear() {
    return __async(this, null, function* () {
      if (!isTextInput(this.element)) {
        throw Error("Attempting to clear an invalid element");
      }
      clearElement(this.element);
      yield this._stabilize();
    });
  }
  click(...args) {
    return __async(this, null, function* () {
      const isDisabled = this.element.disabled === true;
      yield this._dispatchMouseEventSequence(isDisabled ? null : "click", args, 0);
      yield this._stabilize();
    });
  }
  rightClick(...args) {
    return __async(this, null, function* () {
      yield this._dispatchMouseEventSequence("contextmenu", args, 2);
      yield this._stabilize();
    });
  }
  /** Focus the element. */
  focus() {
    return __async(this, null, function* () {
      triggerFocus(this.element);
      yield this._stabilize();
    });
  }
  /** Get the computed value of the given CSS property for the element. */
  getCssValue(property) {
    return __async(this, null, function* () {
      yield this._stabilize();
      return getComputedStyle(this.element).getPropertyValue(property);
    });
  }
  /** Hovers the mouse over the element. */
  hover() {
    return __async(this, null, function* () {
      this._dispatchPointerEventIfSupported("pointerenter");
      dispatchMouseEvent(this.element, "mouseover");
      dispatchMouseEvent(this.element, "mouseenter");
      yield this._stabilize();
    });
  }
  /** Moves the mouse away from the element. */
  mouseAway() {
    return __async(this, null, function* () {
      this._dispatchPointerEventIfSupported("pointerleave");
      dispatchMouseEvent(this.element, "mouseout");
      dispatchMouseEvent(this.element, "mouseleave");
      yield this._stabilize();
    });
  }
  sendKeys(...modifiersAndKeys) {
    return __async(this, null, function* () {
      const args = modifiersAndKeys.map((k) => typeof k === "number" ? keyMap[k] : k);
      typeInElement(this.element, ...args);
      yield this._stabilize();
    });
  }
  /**
   * Gets the text from the element.
   * @param options Options that affect what text is included.
   */
  text(options) {
    return __async(this, null, function* () {
      yield this._stabilize();
      if (options == null ? void 0 : options.exclude) {
        return (0, import_testing._getTextWithExcludedElements)(this.element, options.exclude);
      }
      return (this.element.textContent || "").trim();
    });
  }
  /**
   * Sets the value of a `contenteditable` element.
   * @param value Value to be set on the element.
   */
  setContenteditableValue(value) {
    return __async(this, null, function* () {
      const contenteditableAttr = yield this.getAttribute("contenteditable");
      if (contenteditableAttr !== "" && contenteditableAttr !== "true") {
        throw new Error("setContenteditableValue can only be called on a `contenteditable` element.");
      }
      yield this._stabilize();
      this.element.textContent = value;
    });
  }
  /** Gets the value for the given attribute from the element. */
  getAttribute(name) {
    return __async(this, null, function* () {
      yield this._stabilize();
      return this.element.getAttribute(name);
    });
  }
  /** Checks whether the element has the given class. */
  hasClass(name) {
    return __async(this, null, function* () {
      yield this._stabilize();
      return this.element.classList.contains(name);
    });
  }
  /** Gets the dimensions of the element. */
  getDimensions() {
    return __async(this, null, function* () {
      yield this._stabilize();
      return this.element.getBoundingClientRect();
    });
  }
  /** Gets the value of a property of an element. */
  getProperty(name) {
    return __async(this, null, function* () {
      yield this._stabilize();
      return this.element[name];
    });
  }
  /** Sets the value of a property of an input. */
  setInputValue(value) {
    return __async(this, null, function* () {
      this.element.value = value;
      yield this._stabilize();
    });
  }
  /** Selects the options at the specified indexes inside of a native `select` element. */
  selectOptions(...optionIndexes) {
    return __async(this, null, function* () {
      let hasChanged = false;
      const options = this.element.querySelectorAll("option");
      const indexes = new Set(optionIndexes);
      for (let i = 0; i < options.length; i++) {
        const option = options[i];
        const wasSelected = option.selected;
        option.selected = indexes.has(i);
        if (option.selected !== wasSelected) {
          hasChanged = true;
          dispatchFakeEvent(this.element, "change");
        }
      }
      if (hasChanged) {
        yield this._stabilize();
      }
    });
  }
  /** Checks whether this element matches the given selector. */
  matchesSelector(selector) {
    return __async(this, null, function* () {
      yield this._stabilize();
      const elementPrototype = Element.prototype;
      return (elementPrototype["matches"] || elementPrototype["msMatchesSelector"]).call(this.element, selector);
    });
  }
  /** Checks whether the element is focused. */
  isFocused() {
    return __async(this, null, function* () {
      yield this._stabilize();
      return document.activeElement === this.element;
    });
  }
  /**
   * Dispatches an event with a particular name.
   * @param name Name of the event to be dispatched.
   */
  dispatchEvent(name, data) {
    return __async(this, null, function* () {
      const event = createFakeEvent(name);
      if (data) {
        Object.assign(event, data);
      }
      dispatchEvent(this.element, event);
      yield this._stabilize();
    });
  }
  /**
   * Dispatches a pointer event on the current element if the browser supports it.
   * @param name Name of the pointer event to be dispatched.
   * @param clientX Coordinate of the user's pointer along the X axis.
   * @param clientY Coordinate of the user's pointer along the Y axis.
   * @param button Mouse button that should be pressed when dispatching the event.
   */
  _dispatchPointerEventIfSupported(name, clientX, clientY, offsetX, offsetY, button) {
    if (typeof PointerEvent !== "undefined" && PointerEvent) {
      dispatchPointerEvent(this.element, name, clientX, clientY, offsetX, offsetY, {
        isPrimary: true,
        button
      });
    }
  }
  /**
   * Dispatches all the events that are part of a mouse event sequence
   * and then emits a given primary event at the end, if speciifed.
   */
  _dispatchMouseEventSequence(primaryEventName, args, button) {
    return __async(this, null, function* () {
      let clientX = void 0;
      let clientY = void 0;
      let offsetX = void 0;
      let offsetY = void 0;
      let modifiers = {};
      if (args.length && typeof args[args.length - 1] === "object") {
        modifiers = args.pop();
      }
      if (args.length) {
        const { left, top, width, height } = yield this.getDimensions();
        offsetX = args[0] === "center" ? width / 2 : args[0];
        offsetY = args[0] === "center" ? height / 2 : args[1];
        clientX = Math.round(left + offsetX);
        clientY = Math.round(top + offsetY);
      }
      this._dispatchPointerEventIfSupported("pointerdown", clientX, clientY, offsetX, offsetY, button);
      dispatchMouseEvent(this.element, "mousedown", clientX, clientY, offsetX, offsetY, button, modifiers);
      this._dispatchPointerEventIfSupported("pointerup", clientX, clientY, offsetX, offsetY, button);
      dispatchMouseEvent(this.element, "mouseup", clientX, clientY, offsetX, offsetY, button, modifiers);
      if (primaryEventName !== null) {
        dispatchMouseEvent(this.element, primaryEventName, clientX, clientY, offsetX, offsetY, button, modifiers);
      }
      yield this._stabilize();
    });
  }
}
const defaultEnvironmentOptions = {
  queryFn: (selector, root) => root.querySelectorAll(selector)
};
let disableAutoChangeDetection = false;
const activeFixtures = /* @__PURE__ */ new Set();
function installAutoChangeDetectionStatusHandler(fixture) {
  if (!activeFixtures.size) {
    (0, import_testing.handleAutoChangeDetectionStatus)(({ isDisabled, onDetectChangesNow }) => {
      disableAutoChangeDetection = isDisabled;
      if (onDetectChangesNow) {
        Promise.all(Array.from(activeFixtures).map(detectChanges)).then(onDetectChangesNow);
      }
    });
  }
  activeFixtures.add(fixture);
}
function uninstallAutoChangeDetectionStatusHandler(fixture) {
  activeFixtures.delete(fixture);
  if (!activeFixtures.size) {
    (0, import_testing.stopHandlingAutoChangeDetectionStatus)();
  }
}
function isInFakeAsyncZone() {
  return typeof Zone !== "undefined" && Zone.current.get("FakeAsyncTestZoneSpec") != null;
}
function detectChanges(fixture) {
  return __async(this, null, function* () {
    fixture.detectChanges();
    if (isInFakeAsyncZone()) {
      (0, import_testing2.flush)();
    } else {
      yield fixture.whenStable();
    }
  });
}
class TestbedHarnessEnvironment extends import_testing.HarnessEnvironment {
  constructor(rawRootElement, _fixture, options) {
    super(rawRootElement);
    this._fixture = _fixture;
    this._destroyed = false;
    this._options = __spreadValues(__spreadValues({}, defaultEnvironmentOptions), options);
    if (typeof Zone !== "undefined") {
      this._taskState = TaskStateZoneInterceptor.setup();
    }
    this._stabilizeCallback = () => this.forceStabilize();
    installAutoChangeDetectionStatusHandler(_fixture);
    _fixture.componentRef.onDestroy(() => {
      uninstallAutoChangeDetectionStatusHandler(_fixture);
      this._destroyed = true;
    });
  }
  /** Creates a `HarnessLoader` rooted at the given fixture's root element. */
  static loader(fixture, options) {
    return new TestbedHarnessEnvironment(fixture.nativeElement, fixture, options);
  }
  /**
   * Creates a `HarnessLoader` at the document root. This can be used if harnesses are
   * located outside of a fixture (e.g. overlays appended to the document body).
   */
  static documentRootLoader(fixture, options) {
    return new TestbedHarnessEnvironment(document.body, fixture, options);
  }
  /** Gets the native DOM element corresponding to the given TestElement. */
  static getNativeElement(el) {
    if (el instanceof UnitTestElement) {
      return el.element;
    }
    throw Error("This TestElement was not created by the TestbedHarnessEnvironment");
  }
  /**
   * Creates an instance of the given harness type, using the fixture's root element as the
   * harness's host element. This method should be used when creating a harness for the root element
   * of a fixture, as components do not have the correct selector when they are created as the root
   * of the fixture.
   */
  static harnessForFixture(fixture, harnessType, options) {
    return __async(this, null, function* () {
      const environment = new TestbedHarnessEnvironment(fixture.nativeElement, fixture, options);
      yield environment.forceStabilize();
      return environment.createComponentHarness(harnessType, fixture.nativeElement);
    });
  }
  /**
   * Flushes change detection and async tasks captured in the Angular zone.
   * In most cases it should not be necessary to call this manually. However, there may be some edge
   * cases where it is needed to fully flush animation events.
   */
  forceStabilize() {
    return __async(this, null, function* () {
      if (!disableAutoChangeDetection) {
        if (this._destroyed) {
          throw Error("Harness is attempting to use a fixture that has already been destroyed.");
        }
        yield detectChanges(this._fixture);
      }
    });
  }
  /**
   * Waits for all scheduled or running async tasks to complete. This allows harness
   * authors to wait for async tasks outside of the Angular zone.
   */
  waitForTasksOutsideAngular() {
    return __async(this, null, function* () {
      var _a;
      if (isInFakeAsyncZone()) {
        (0, import_testing2.flush)();
      }
      yield (_a = this._taskState) == null ? void 0 : _a.pipe((0, import_operators.takeWhile)((state) => !state.stable)).toPromise();
    });
  }
  /** Gets the root element for the document. */
  getDocumentRoot() {
    return document.body;
  }
  /** Creates a `TestElement` from a raw element. */
  createTestElement(element) {
    return new UnitTestElement(element, this._stabilizeCallback);
  }
  /** Creates a `HarnessLoader` rooted at the given raw element. */
  createEnvironment(element) {
    return new TestbedHarnessEnvironment(element, this._fixture, this._options);
  }
  /**
   * Gets a list of all elements matching the given selector under this environment's root element.
   */
  getAllRawElements(selector) {
    return __async(this, null, function* () {
      yield this.forceStabilize();
      return Array.from(this._options.queryFn(selector, this.rawRootElement));
    });
  }
}
