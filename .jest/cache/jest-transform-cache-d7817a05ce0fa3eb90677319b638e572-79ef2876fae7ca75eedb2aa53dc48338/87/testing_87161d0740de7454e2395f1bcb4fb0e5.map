{
  "version": 3,
  "sources": ["/Users/macbook/karpov-work/TrueNAS/webui/node_modules/@angular/material/fesm2022/radio/testing.mjs"],
  "sourcesContent": ["import { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ComponentHarness, HarnessPredicate } from '@angular/cdk/testing';\n\n/** Harness for interacting with a mat-radio-group in tests. */\nclass MatRadioGroupHarness extends ComponentHarness {\n    constructor() {\n        super(...arguments);\n        this._buttonClass = MatRadioButtonHarness;\n    }\n    /** The selector for the host element of a `MatRadioGroup` instance. */\n    static { this.hostSelector = '.mat-mdc-radio-group'; }\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a radio group with specific\n     * attributes.\n     * @param options Options for filtering which radio group instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options = {}) {\n        return new HarnessPredicate(this, options).addOption('name', options.name, MatRadioGroupHarness._checkRadioGroupName);\n    }\n    /** Gets the name of the radio-group. */\n    async getName() {\n        const hostName = await this._getGroupNameFromHost();\n        // It's not possible to always determine the \"name\" of a radio-group by reading\n        // the attribute. This is because the radio-group does not set the \"name\" as an\n        // element attribute if the \"name\" value is set through a binding.\n        if (hostName !== null) {\n            return hostName;\n        }\n        // In case we couldn't determine the \"name\" of a radio-group by reading the\n        // \"name\" attribute, we try to determine the \"name\" of the group by going\n        // through all radio buttons.\n        const radioNames = await this._getNamesFromRadioButtons();\n        if (!radioNames.length) {\n            return null;\n        }\n        if (!this._checkRadioNamesInGroupEqual(radioNames)) {\n            throw Error('Radio buttons in radio-group have mismatching names.');\n        }\n        return radioNames[0];\n    }\n    /** Gets the id of the radio-group. */\n    async getId() {\n        return (await this.host()).getProperty('id');\n    }\n    /** Gets the checked radio-button in a radio-group. */\n    async getCheckedRadioButton() {\n        for (let radioButton of await this.getRadioButtons()) {\n            if (await radioButton.isChecked()) {\n                return radioButton;\n            }\n        }\n        return null;\n    }\n    /** Gets the checked value of the radio-group. */\n    async getCheckedValue() {\n        const checkedRadio = await this.getCheckedRadioButton();\n        if (!checkedRadio) {\n            return null;\n        }\n        return checkedRadio.getValue();\n    }\n    /**\n     * Gets a list of radio buttons which are part of the radio-group.\n     * @param filter Optionally filters which radio buttons are included.\n     */\n    async getRadioButtons(filter) {\n        return this.locatorForAll(this._buttonClass.with(filter))();\n    }\n    /**\n     * Checks a radio button in this group.\n     * @param filter An optional filter to apply to the child radio buttons. The first tab matching\n     *     the filter will be selected.\n     */\n    async checkRadioButton(filter) {\n        const radioButtons = await this.getRadioButtons(filter);\n        if (!radioButtons.length) {\n            throw Error(`Could not find radio button matching ${JSON.stringify(filter)}`);\n        }\n        return radioButtons[0].check();\n    }\n    /** Gets the name attribute of the host element. */\n    async _getGroupNameFromHost() {\n        return (await this.host()).getAttribute('name');\n    }\n    /** Gets a list of the name attributes of all child radio buttons. */\n    async _getNamesFromRadioButtons() {\n        const groupNames = [];\n        for (let radio of await this.getRadioButtons()) {\n            const radioName = await radio.getName();\n            if (radioName !== null) {\n                groupNames.push(radioName);\n            }\n        }\n        return groupNames;\n    }\n    /** Checks if the specified radio names are all equal. */\n    _checkRadioNamesInGroupEqual(radioNames) {\n        let groupName = null;\n        for (let radioName of radioNames) {\n            if (groupName === null) {\n                groupName = radioName;\n            }\n            else if (groupName !== radioName) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Checks if a radio-group harness has the given name. Throws if a radio-group with\n     * matching name could be found but has mismatching radio-button names.\n     */\n    static async _checkRadioGroupName(harness, name) {\n        // Check if there is a radio-group which has the \"name\" attribute set\n        // to the expected group name. It's not possible to always determine\n        // the \"name\" of a radio-group by reading the attribute. This is because\n        // the radio-group does not set the \"name\" as an element attribute if the\n        // \"name\" value is set through a binding.\n        if ((await harness._getGroupNameFromHost()) === name) {\n            return true;\n        }\n        // Check if there is a group with radio-buttons that all have the same\n        // expected name. This implies that the group has the given name. It's\n        // not possible to always determine the name of a radio-group through\n        // the attribute because there is\n        const radioNames = await harness._getNamesFromRadioButtons();\n        if (radioNames.indexOf(name) === -1) {\n            return false;\n        }\n        if (!harness._checkRadioNamesInGroupEqual(radioNames)) {\n            throw Error(`The locator found a radio-group with name \"${name}\", but some ` +\n                `radio-button's within the group have mismatching names, which is invalid.`);\n        }\n        return true;\n    }\n}\n/** Harness for interacting with a mat-radio-button in tests. */\nclass MatRadioButtonHarness extends ComponentHarness {\n    constructor() {\n        super(...arguments);\n        this._textLabel = this.locatorFor('label');\n        this._clickLabel = this._textLabel;\n        this._input = this.locatorFor('input');\n    }\n    /** The selector for the host element of a `MatRadioButton` instance. */\n    static { this.hostSelector = '.mat-mdc-radio-button'; }\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a radio button with specific\n     * attributes.\n     * @param options Options for filtering which radio button instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options = {}) {\n        return new HarnessPredicate(this, options)\n            .addOption('label', options.label, (harness, label) => HarnessPredicate.stringMatches(harness.getLabelText(), label))\n            .addOption('name', options.name, async (harness, name) => (await harness.getName()) === name)\n            .addOption('checked', options.checked, async (harness, checked) => (await harness.isChecked()) == checked);\n    }\n    /** Whether the radio-button is checked. */\n    async isChecked() {\n        const checked = (await this._input()).getProperty('checked');\n        return coerceBooleanProperty(await checked);\n    }\n    /** Whether the radio-button is disabled. */\n    async isDisabled() {\n        const input = await this._input();\n        const disabled = await input.getAttribute('disabled');\n        if (disabled !== null) {\n            return coerceBooleanProperty(disabled);\n        }\n        return (await input.getAttribute('aria-disabled')) === 'true';\n    }\n    /** Whether the radio-button is required. */\n    async isRequired() {\n        const required = (await this._input()).getAttribute('required');\n        return coerceBooleanProperty(await required);\n    }\n    /** Gets the radio-button's name. */\n    async getName() {\n        return (await this._input()).getAttribute('name');\n    }\n    /** Gets the radio-button's id. */\n    async getId() {\n        return (await this.host()).getProperty('id');\n    }\n    /**\n     * Gets the value of the radio-button. The radio-button value will be converted to a string.\n     *\n     * Note: This means that for radio-button's with an object as a value `[object Object]` is\n     * intentionally returned.\n     */\n    async getValue() {\n        return (await this._input()).getProperty('value');\n    }\n    /** Gets the radio-button's label text. */\n    async getLabelText() {\n        return (await this._textLabel()).text();\n    }\n    /** Focuses the radio-button. */\n    async focus() {\n        return (await this._input()).focus();\n    }\n    /** Blurs the radio-button. */\n    async blur() {\n        return (await this._input()).blur();\n    }\n    /** Whether the radio-button is focused. */\n    async isFocused() {\n        return (await this._input()).isFocused();\n    }\n    /**\n     * Puts the radio-button in a checked state by clicking it if it is currently unchecked,\n     * or doing nothing if it is already checked.\n     */\n    async check() {\n        if (!(await this.isChecked())) {\n            return (await this._clickLabel()).click();\n        }\n    }\n}\n\nexport { MatRadioButtonHarness, MatRadioGroupHarness };\n//# sourceMappingURL=testing.mjs.map\n"],
  "mappings": "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",
  "names": []
}
