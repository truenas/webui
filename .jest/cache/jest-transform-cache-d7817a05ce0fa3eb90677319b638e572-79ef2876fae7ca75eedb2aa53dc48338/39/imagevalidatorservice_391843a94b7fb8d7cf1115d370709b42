54405eb2dfba1787c75b8dcc0219f7ea
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImageValidatorService = void 0;
const core_1 = require("@angular/core");
const core_2 = require("@ngx-translate/core");
const rxjs_1 = require("rxjs");
const bytes_constant_1 = require("app/constants/bytes.constant");
const ix_errors_component_1 = require("app/modules/forms/ix-forms/components/ix-errors/ix-errors.component");
let ImageValidatorService = class ImageValidatorService {
    constructor(translate) {
        this.translate = translate;
    }
    getImagesValidator(fileSizeLimitBytes) {
        return (control) => {
            return this.validateImages(control.value, fileSizeLimitBytes).pipe((0, rxjs_1.map)((validatedFiles) => {
                const invalidFiles = validatedFiles
                    .filter((file) => file.error)
                    .map((file) => file.error);
                if (!invalidFiles.length) {
                    return null;
                }
                const message = invalidFiles.map((error) => `${error.name} â€“ ${error.errorMessage}`).join('\n');
                return { [ix_errors_component_1.ixManualValidateError]: { message } };
            }));
        };
    }
    validateImages(screenshots, sizeLimitBytes) {
        return (0, rxjs_1.from)(screenshots).pipe((0, rxjs_1.take)(screenshots.length), (0, rxjs_1.concatMap)((file) => {
            return this.validateImage(file, sizeLimitBytes).pipe((0, rxjs_1.catchError)((error) => (0, rxjs_1.of)(error)));
        }), (0, rxjs_1.toArray)());
    }
    validateImage(file, sizeLimitBytes) {
        const fileReader = new FileReader();
        const { type, name, size } = file;
        return new rxjs_1.Observable((observer) => {
            if (sizeLimitBytes != null
                && !Number.isNaN(sizeLimitBytes)
                && size > sizeLimitBytes) {
                observer.error({
                    error: {
                        name,
                        errorMessage: this.translate.instant('File size is limited to {n} MiB.', { n: sizeLimitBytes / bytes_constant_1.MiB }),
                    },
                });
            }
            fileReader.readAsDataURL(file);
            fileReader.onload = () => {
                if (type.startsWith('image/')) {
                    const image = new Image();
                    image.onload = () => {
                        observer.next({ file });
                        observer.complete();
                    };
                    image.onerror = () => {
                        observer.error({ error: { name, errorMessage: this.translate.instant('Invalid image') } });
                    };
                    image.src = fileReader.result;
                }
                else {
                    observer.next({ file });
                    observer.complete();
                }
            };
            fileReader.onerror = () => {
                observer.error({ error: { name, errorMessage: this.translate.instant('Invalid file') } });
            };
        });
    }
};
exports.ImageValidatorService = ImageValidatorService;
ImageValidatorService.ctorParameters = () => [
    { type: core_2.TranslateService }
];
exports.ImageValidatorService = ImageValidatorService = __decorate([
    (0, core_1.Injectable)({
        providedIn: 'root',
    })
], ImageValidatorService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL21hY2Jvb2sva2FycG92LXdvcmsvVHJ1ZU5BUy93ZWJ1aS9zcmMvYXBwL21vZHVsZXMvZm9ybXMvaXgtZm9ybXMvdmFsaWRhdG9ycy9pbWFnZS12YWxpZGF0b3IvaW1hZ2UtdmFsaWRhdG9yLnNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsd0NBQTJDO0FBRTNDLDhDQUF1RDtBQUN2RCwrQkFLYztBQUNkLGlFQUFtRDtBQUVuRCw2R0FBNEc7QUFLckcsSUFBTSxxQkFBcUIsR0FBM0IsTUFBTSxxQkFBcUI7SUFDaEMsWUFDVSxTQUEyQjtRQUEzQixjQUFTLEdBQVQsU0FBUyxDQUFrQjtJQUNqQyxDQUFDO0lBRUwsa0JBQWtCLENBQUMsa0JBQTBCO1FBQzNDLE9BQU8sQ0FBQyxPQUE0QixFQUF1QyxFQUFFO1lBQzNFLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLGtCQUFrQixDQUFDLENBQUMsSUFBSSxDQUNoRSxJQUFBLFVBQUcsRUFBQyxDQUFDLGNBQWMsRUFBRSxFQUFFO2dCQUNyQixNQUFNLFlBQVksR0FBRyxjQUFjO3FCQUNoQyxNQUFNLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7cUJBQzVCLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUU3QixJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDO29CQUN6QixPQUFPLElBQUksQ0FBQztnQkFDZCxDQUFDO2dCQUVELE1BQU0sT0FBTyxHQUFHLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLElBQUksTUFBTSxLQUFLLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ2hHLE9BQU8sRUFBRSxDQUFDLDJDQUFxQixDQUFDLEVBQUUsRUFB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Z0NBQXJCLHFCQUFxQjtJQUhqQyxJQUFBLGlCQUFVLEVBQUM7UUFDVixVQUFVLEVBQUUsTUFBTTtLQUNuQixDQUFDO0dBQ1cscUJBQXFCLENBMkVqQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvbWFjYm9vay9rYXJwb3Ytd29yay9UcnVlTkFTL3dlYnVpL3NyYy9hcHAvbW9kdWxlcy9mb3Jtcy9peC1mb3Jtcy92YWxpZGF0b3JzL2ltYWdlLXZhbGlkYXRvci9pbWFnZS12YWxpZGF0b3Iuc2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBc3luY1ZhbGlkYXRvckZuLCBGb3JtQ29udHJvbCwgVmFsaWRhdGlvbkVycm9ycyB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IFRyYW5zbGF0ZVNlcnZpY2UgfSBmcm9tICdAbmd4LXRyYW5zbGF0ZS9jb3JlJztcbmltcG9ydCB7XG4gIGNhdGNoRXJyb3IsXG4gIGNvbmNhdE1hcCxcbiAgZnJvbSxcbiAgbWFwLCBPYnNlcnZhYmxlLCBPYnNlcnZlciwgb2YsIHRha2UsIHRvQXJyYXksXG59IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTWlCIH0gZnJvbSAnYXBwL2NvbnN0YW50cy9ieXRlcy5jb25zdGFudCc7XG5pbXBvcnQgeyBWYWxpZGF0ZWRGaWxlIH0gZnJvbSAnYXBwL2ludGVyZmFjZXMvdmFsaWRhdGVkLWZpbGUuaW50ZXJmYWNlJztcbmltcG9ydCB7IGl4TWFudWFsVmFsaWRhdGVFcnJvciB9IGZyb20gJ2FwcC9tb2R1bGVzL2Zvcm1zL2l4LWZvcm1zL2NvbXBvbmVudHMvaXgtZXJyb3JzL2l4LWVycm9ycy5jb21wb25lbnQnO1xuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgSW1hZ2VWYWxpZGF0b3JTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSB0cmFuc2xhdGU6IFRyYW5zbGF0ZVNlcnZpY2UsXG4gICkgeyB9XG5cbiAgZ2V0SW1hZ2VzVmFsaWRhdG9yKGZpbGVTaXplTGltaXRCeXRlczogbnVtYmVyKTogQXN5bmNWYWxpZGF0b3JGbiB7XG4gICAgcmV0dXJuIChjb250cm9sOiBGb3JtQ29udHJvbDxGaWxlW10+KTogT2JzZXJ2YWJsZTxWYWxpZGF0aW9uRXJyb3JzPiB8IG51bGwgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVJbWFnZXMoY29udHJvbC52YWx1ZSwgZmlsZVNpemVMaW1pdEJ5dGVzKS5waXBlKFxuICAgICAgICBtYXAoKHZhbGlkYXRlZEZpbGVzKSA9PiB7XG4gICAgICAgICAgY29uc3QgaW52YWxpZEZpbGVzID0gdmFsaWRhdGVkRmlsZXNcbiAgICAgICAgICAgIC5maWx0ZXIoKGZpbGUpID0+IGZpbGUuZXJyb3IpXG4gICAgICAgICAgICAubWFwKChmaWxlKSA9PiBmaWxlLmVycm9yKTtcblxuICAgICAgICAgIGlmICghaW52YWxpZEZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGludmFsaWRGaWxlcy5tYXAoKGVycm9yKSA9PiBgJHtlcnJvci5uYW1lfSDigJMgJHtlcnJvci5lcnJvck1lc3NhZ2V9YCkuam9pbignXFxuJyk7XG4gICAgICAgICAgcmV0dXJuIHsgW2l4TWFudWFsVmFsaWRhdGVFcnJvcl06IHsgbWVzc2FnZSB9IH07XG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSB2YWxpZGF0ZUltYWdlcyhzY3JlZW5zaG90czogRmlsZVtdLCBzaXplTGltaXRCeXRlczogbnVtYmVyKTogT2JzZXJ2YWJsZTxWYWxpZGF0ZWRGaWxlW10+IHtcbiAgICByZXR1cm4gZnJvbShzY3JlZW5zaG90cykucGlwZShcbiAgICAgIHRha2Uoc2NyZWVuc2hvdHMubGVuZ3RoKSxcbiAgICAgIGNvbmNhdE1hcCgoZmlsZTogRmlsZSk6IE9ic2VydmFibGU8VmFsaWRhdGVkRmlsZT4gPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZUltYWdlKGZpbGUsIHNpemVMaW1pdEJ5dGVzKS5waXBlKFxuICAgICAgICAgIGNhdGNoRXJyb3IoKGVycm9yOiBWYWxpZGF0ZWRGaWxlKSA9PiBvZihlcnJvcikpLFxuICAgICAgICApO1xuICAgICAgfSksXG4gICAgICB0b0FycmF5KCksXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgdmFsaWRhdGVJbWFnZShmaWxlOiBGaWxlLCBzaXplTGltaXRCeXRlczogbnVtYmVyKTogT2JzZXJ2YWJsZTxWYWxpZGF0ZWRGaWxlPiB7XG4gICAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgY29uc3QgeyB0eXBlLCBuYW1lLCBzaXplIH0gPSBmaWxlO1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZSgob2JzZXJ2ZXI6IE9ic2VydmVyPFZhbGlkYXRlZEZpbGU+KSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIHNpemVMaW1pdEJ5dGVzICE9IG51bGxcbiAgICAgICAgJiYgIU51bWJlci5pc05hTihzaXplTGltaXRCeXRlcylcbiAgICAgICAgJiYgc2l6ZSA+IHNpemVMaW1pdEJ5dGVzXG4gICAgICApIHtcbiAgICAgICAgb2JzZXJ2ZXIuZXJyb3Ioe1xuICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiB0aGlzLnRyYW5zbGF0ZS5pbnN0YW50KCdGaWxlIHNpemUgaXMgbGltaXRlZCB0byB7bn0gTWlCLicsIHsgbjogc2l6ZUxpbWl0Qnl0ZXMgLyBNaUIgfSksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZpbGVSZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICBpZiAodHlwZS5zdGFydHNXaXRoKCdpbWFnZS8nKSkge1xuICAgICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgaW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh7IGZpbGUgfSk7XG4gICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaW1hZ2Uub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKHsgZXJyb3I6IHsgbmFtZSwgZXJyb3JNZXNzYWdlOiB0aGlzLnRyYW5zbGF0ZS5pbnN0YW50KCdJbnZhbGlkIGltYWdlJykgfSB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGltYWdlLnNyYyA9IGZpbGVSZWFkZXIucmVzdWx0IGFzIHN0cmluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYnNlcnZlci5uZXh0KHsgZmlsZSB9KTtcbiAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZmlsZVJlYWRlci5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICBvYnNlcnZlci5lcnJvcih7IGVycm9yOiB7IG5hbWUsIGVycm9yTWVzc2FnZTogdGhpcy50cmFuc2xhdGUuaW5zdGFudCgnSW52YWxpZCBmaWxlJykgfSB9KTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbn1cbiJdLCJ2ZXJzaW9uIjozfQ==