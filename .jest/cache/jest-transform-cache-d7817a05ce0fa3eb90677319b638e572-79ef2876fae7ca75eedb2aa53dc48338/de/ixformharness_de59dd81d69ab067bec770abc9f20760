c7d9d6e93e72e0067f511e115784c35b
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IxFormHarness = void 0;
const testing_1 = require("@angular/cdk/testing");
const control_harnesses_helpers_1 = require("app/modules/forms/ix-forms/testing/control-harnesses.helpers");
/**
 * This class provides sugar syntax to make it easier to work with forms.
 * When possibilities of this class are not enough, use individual harnesses such as IxInputHarness, etc.
 */
class IxFormHarness extends testing_1.ComponentHarness {
    constructor() {
        super(...arguments);
        this.getControlHarnesses = this.locatorForAll(...control_harnesses_helpers_1.supportedFormControlSelectors);
    }
    /**
     * Returns a dictionary of form control harnesses indexed by their labels.
     */
    getControlHarnessesDict() {
        return __awaiter(this, void 0, void 0, function* () {
            const controls = yield this.getControlHarnesses();
            return (0, control_harnesses_helpers_1.indexControlsByLabel)(controls);
        });
    }
    getControl(label) {
        return __awaiter(this, void 0, void 0, function* () {
            const controlsDict = yield this.getControlHarnessesDict();
            return controlsDict[label];
        });
    }
    getValues() {
        return __awaiter(this, void 0, void 0, function* () {
            const controlsDict = yield this.getControlHarnessesDict();
            return (0, control_harnesses_helpers_1.getControlValues)(controlsDict);
        });
    }
    getLabels() {
        return __awaiter(this, void 0, void 0, function* () {
            const controls = yield this.getControlHarnesses();
            return (0, testing_1.parallel)(() => controls.map((control) => control.getLabelText()));
        });
    }
    /**
     * Sequentially fill in the form.
     * Argument is a dictionary, where key is label:
     * ```
     * {
     *   'First Name': 'John',
     *   'Last Name': 'Smith',
     *   'Receive email updates': true,
     * }
     * ```
     */
    fillForm(values) {
        return __awaiter(this, void 0, void 0, function* () {
            const labels = Object.keys(values);
            for (const label of labels) {
                const controlsDict = yield this.getControlHarnessesDict();
                const control = controlsDict[label];
                if (!control) {
                    throw new Error(`Could not find control with label ${label}.`);
                }
                yield control.setValue(values[label]);
            }
        });
    }
    getDisabledState() {
        return __awaiter(this, void 0, void 0, function* () {
            const controls = yield this.getControlHarnessesDict();
            return (0, control_harnesses_helpers_1.getDisabledStates)(controls);
        });
    }
}
exports.IxFormHarness = IxFormHarness;
IxFormHarness.hostSelector = 'form';
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL21hY2Jvb2sva2FycG92LXdvcmsvVHJ1ZU5BUy93ZWJ1aS9zcmMvYXBwL21vZHVsZXMvZm9ybXMvaXgtZm9ybXMvdGVzdGluZy9peC1mb3JtLmhhcm5lc3MudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsa0RBRzhCO0FBRTlCLDRHQUlzRTtBQUV0RTs7O0dBR0c7QUFDSCxNQUFhLGFBQWMsU0FBUSwwQkFBZ0I7SUFBbkQ7O1FBR0Usd0JBQW1CLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLHlEQUE2QixDQUFDLENBQUM7SUFxRDdFLENBQUM7SUFuREM7O09BRUc7SUFDRyx1QkFBdUI7O1lBQzNCLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7WUFDbEQsT0FBTyxJQUFBLGdEQUFvQixFQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ3hDLENBQUM7S0FBQTtJQUVLLFVBQVUsQ0FBQyxLQUFhOztZQUM1QixNQUFNLFlBQVksR0FBRyxNQUFNLElBQUksQ0FBQyx1QkFBdUIsRUFBRSxDQUFDO1lBQzFELE9BQU8sWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzdCLENBQUM7S0FBQTtJQUVLLFNBQVM7O1lBQ2IsTUFBTSxZQUFZLEdBQUcsTUFBTSxJQUFJLENBQUMsdUJBQXVCLEVBQUUsQ0FBQztZQUMxRCxPQUFPLElBQUEsNENBQWdCLEVBQUMsWUFBWSxDQUFDLENBQUM7UUFDeEMsQ0FBQztLQUFBO0lBRUssU0FBUzs7WUFDYixNQUFNLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO1lBRWxELE9BQU8sSUFBQSxrQkFBUSxFQUFDLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDM0UsQ0FBQztLQUFBO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNHLFFBQVEsQ0FBQyxNQUErQjs7WUFDNUMsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNuQyxLQUFLLE1BQU0sS0FBSyxJQUFJLE1BQU0sRUFBRSxDQUFDO2dCQUMzQixNQUFNLFlBQVksR0FBRyxNQUFNLElBQUksQ0FBQyx1QkFBdUIsRUFBRSxDQUFDO2dCQUMxRCxNQUFNLE9BQU8sR0FBRyxZQUFZLENBQUMsS0FBSyxDQUF5QixDQUFDO2dCQUM1RCxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7b0JBQ2IsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQ0FBcUMsS0FBSyxHQUFHLENBQUMsQ0FBQztnQkFDakUsQ0FBQztnQkFDRCxNQUFNLE9BQU8sQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFDeEMsQ0FBQztRQUNILENBQUM7S0FBQTtJQUVLLGdCQUFnQjs7WUFDcEIsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsdUJBQXVCLEVBQUUsQ0FBQztZQUN0RCxPQUFPLElBQUEsNkNBQWlCLEVBQUMsUUFBUSxDQUFDLENBQUM7UUFDckMsQ0FBQztLQUFBOztBQXZESCxzQ0F3REM7QUF2RGlCLDBCQUFZLEdBQUcsTUFBTSxBQUFULENBQVUiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL21hY2Jvb2sva2FycG92LXdvcmsvVHJ1ZU5BUy93ZWJ1aS9zcmMvYXBwL21vZHVsZXMvZm9ybXMvaXgtZm9ybXMvdGVzdGluZy9peC1mb3JtLmhhcm5lc3MudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29tcG9uZW50SGFybmVzcyxcbiAgcGFyYWxsZWwsXG59IGZyb20gJ0Bhbmd1bGFyL2Nkay90ZXN0aW5nJztcbmltcG9ydCB7IEl4Rm9ybUNvbnRyb2xIYXJuZXNzIH0gZnJvbSAnYXBwL21vZHVsZXMvZm9ybXMvaXgtZm9ybXMvaW50ZXJmYWNlcy9peC1mb3JtLWNvbnRyb2wtaGFybmVzcy5pbnRlcmZhY2UnO1xuaW1wb3J0IHtcbiAgc3VwcG9ydGVkRm9ybUNvbnRyb2xTZWxlY3RvcnMsXG4gIFN1cHBvcnRlZEZvcm1Db250cm9sSGFybmVzcyxcbiAgaW5kZXhDb250cm9sc0J5TGFiZWwsIGdldENvbnRyb2xWYWx1ZXMsIEl4Rm9ybUJhc2ljVmFsdWVUeXBlLCBnZXREaXNhYmxlZFN0YXRlcyxcbn0gZnJvbSAnYXBwL21vZHVsZXMvZm9ybXMvaXgtZm9ybXMvdGVzdGluZy9jb250cm9sLWhhcm5lc3Nlcy5oZWxwZXJzJztcblxuLyoqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIHN1Z2FyIHN5bnRheCB0byBtYWtlIGl0IGVhc2llciB0byB3b3JrIHdpdGggZm9ybXMuXG4gKiBXaGVuIHBvc3NpYmlsaXRpZXMgb2YgdGhpcyBjbGFzcyBhcmUgbm90IGVub3VnaCwgdXNlIGluZGl2aWR1YWwgaGFybmVzc2VzIHN1Y2ggYXMgSXhJbnB1dEhhcm5lc3MsIGV0Yy5cbiAqL1xuZXhwb3J0IGNsYXNzIEl4Rm9ybUhhcm5lc3MgZXh0ZW5kcyBDb21wb25lbnRIYXJuZXNzIHtcbiAgc3RhdGljIHJlYWRvbmx5IGhvc3RTZWxlY3RvciA9ICdmb3JtJztcblxuICBnZXRDb250cm9sSGFybmVzc2VzID0gdGhpcy5sb2NhdG9yRm9yQWxsKC4uLnN1cHBvcnRlZEZvcm1Db250cm9sU2VsZWN0b3JzKTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIGRpY3Rpb25hcnkgb2YgZm9ybSBjb250cm9sIGhhcm5lc3NlcyBpbmRleGVkIGJ5IHRoZWlyIGxhYmVscy5cbiAgICovXG4gIGFzeW5jIGdldENvbnRyb2xIYXJuZXNzZXNEaWN0KCk6IFByb21pc2U8UmVjb3JkPHN0cmluZywgU3VwcG9ydGVkRm9ybUNvbnRyb2xIYXJuZXNzPj4ge1xuICAgIGNvbnN0IGNvbnRyb2xzID0gYXdhaXQgdGhpcy5nZXRDb250cm9sSGFybmVzc2VzKCk7XG4gICAgcmV0dXJuIGluZGV4Q29udHJvbHNCeUxhYmVsKGNvbnRyb2xzKTtcbiAgfVxuXG4gIGFzeW5jIGdldENvbnRyb2wobGFiZWw6IHN0cmluZyk6IFByb21pc2U8U3VwcG9ydGVkRm9ybUNvbnRyb2xIYXJuZXNzPiB7XG4gICAgY29uc3QgY29udHJvbHNEaWN0ID0gYXdhaXQgdGhpcy5nZXRDb250cm9sSGFybmVzc2VzRGljdCgpO1xuICAgIHJldHVybiBjb250cm9sc0RpY3RbbGFiZWxdO1xuICB9XG5cbiAgYXN5bmMgZ2V0VmFsdWVzKCk6IFByb21pc2U8UmVjb3JkPHN0cmluZywgSXhGb3JtQmFzaWNWYWx1ZVR5cGU+PiB7XG4gICAgY29uc3QgY29udHJvbHNEaWN0ID0gYXdhaXQgdGhpcy5nZXRDb250cm9sSGFybmVzc2VzRGljdCgpO1xuICAgIHJldHVybiBnZXRDb250cm9sVmFsdWVzKGNvbnRyb2xzRGljdCk7XG4gIH1cblxuICBhc3luYyBnZXRMYWJlbHMoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGNvbnN0IGNvbnRyb2xzID0gYXdhaXQgdGhpcy5nZXRDb250cm9sSGFybmVzc2VzKCk7XG5cbiAgICByZXR1cm4gcGFyYWxsZWwoKCkgPT4gY29udHJvbHMubWFwKChjb250cm9sKSA9PiBjb250cm9sLmdldExhYmVsVGV4dCgpKSk7XG4gIH1cblxuICAvKipcbiAgICogU2VxdWVudGlhbGx5IGZpbGwgaW4gdGhlIGZvcm0uXG4gICAqIEFyZ3VtZW50IGlzIGEgZGljdGlvbmFyeSwgd2hlcmUga2V5IGlzIGxhYmVsOlxuICAgKiBgYGBcbiAgICoge1xuICAgKiAgICdGaXJzdCBOYW1lJzogJ0pvaG4nLFxuICAgKiAgICdMYXN0IE5hbWUnOiAnU21pdGgnLFxuICAgKiAgICdSZWNlaXZlIGVtYWlsIHVwZGF0ZXMnOiB0cnVlLFxuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgZmlsbEZvcm0odmFsdWVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGxhYmVscyA9IE9iamVjdC5rZXlzKHZhbHVlcyk7XG4gICAgZm9yIChjb25zdCBsYWJlbCBvZiBsYWJlbHMpIHtcbiAgICAgIGNvbnN0IGNvbnRyb2xzRGljdCA9IGF3YWl0IHRoaXMuZ2V0Q29udHJvbEhhcm5lc3Nlc0RpY3QoKTtcbiAgICAgIGNvbnN0IGNvbnRyb2wgPSBjb250cm9sc0RpY3RbbGFiZWxdIGFzIEl4Rm9ybUNvbnRyb2xIYXJuZXNzO1xuICAgICAgaWYgKCFjb250cm9sKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgY29udHJvbCB3aXRoIGxhYmVsICR7bGFiZWx9LmApO1xuICAgICAgfVxuICAgICAgYXdhaXQgY29udHJvbC5zZXRWYWx1ZSh2YWx1ZXNbbGFiZWxdKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXREaXNhYmxlZFN0YXRlKCk6IFByb21pc2U8UmVjb3JkPHN0cmluZywgYm9vbGVhbj4+IHtcbiAgICBjb25zdCBjb250cm9scyA9IGF3YWl0IHRoaXMuZ2V0Q29udHJvbEhhcm5lc3Nlc0RpY3QoKTtcbiAgICByZXR1cm4gZ2V0RGlzYWJsZWRTdGF0ZXMoY29udHJvbHMpO1xuICB9XG59XG4iXSwidmVyc2lvbiI6M30=