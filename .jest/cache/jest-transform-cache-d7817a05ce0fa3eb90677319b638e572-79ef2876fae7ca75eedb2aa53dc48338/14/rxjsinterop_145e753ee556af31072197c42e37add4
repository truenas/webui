71f0706fcd219c37d46158cb1a1e0716
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var rxjs_interop_exports = {};
__export(rxjs_interop_exports, {
  outputFromObservable: () => outputFromObservable,
  outputToObservable: () => outputToObservable,
  takeUntilDestroyed: () => takeUntilDestroyed,
  toObservable: () => toObservable,
  toSignal: () => toSignal
});
module.exports = __toCommonJS(rxjs_interop_exports);
var import_core = require("@angular/core");
var import_rxjs = require("rxjs");
var import_operators = require("rxjs/operators");
/**
 * @license Angular v18.2.4
 * (c) 2010-2024 Google LLC. https://angular.io/
 * License: MIT
 */
function takeUntilDestroyed(destroyRef) {
  if (!destroyRef) {
    (0, import_core.assertInInjectionContext)(takeUntilDestroyed);
    destroyRef = (0, import_core.inject)(import_core.DestroyRef);
  }
  const destroyed$ = new import_rxjs.Observable((observer) => {
    const unregisterFn = destroyRef.onDestroy(observer.next.bind(observer));
    return unregisterFn;
  });
  return (source) => {
    return source.pipe((0, import_operators.takeUntil)(destroyed$));
  };
}
class OutputFromObservableRef {
  constructor(source) {
    this.source = source;
    this.destroyed = false;
    this.destroyRef = (0, import_core.inject)(import_core.DestroyRef);
    this.destroyRef.onDestroy(() => {
      this.destroyed = true;
    });
  }
  subscribe(callbackFn) {
    if (this.destroyed) {
      throw new import_core.\u0275RuntimeError(953, ngDevMode && "Unexpected subscription to destroyed `OutputRef`. The owning directive/component is destroyed.");
    }
    const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({
      next: (value) => callbackFn(value)
    });
    return {
      unsubscribe: () => subscription.unsubscribe()
    };
  }
}
function outputFromObservable(observable, opts) {
  ngDevMode && (0, import_core.assertInInjectionContext)(outputFromObservable);
  return new OutputFromObservableRef(observable);
}
function outputToObservable(ref) {
  const destroyRef = (0, import_core.\u0275getOutputDestroyRef)(ref);
  return new import_rxjs.Observable((observer) => {
    destroyRef == null ? void 0 : destroyRef.onDestroy(() => observer.complete());
    const subscription = ref.subscribe((v) => observer.next(v));
    return () => subscription.unsubscribe();
  });
}
function toObservable(source, options) {
  var _a;
  !(options == null ? void 0 : options.injector) && (0, import_core.assertInInjectionContext)(toObservable);
  const injector = (_a = options == null ? void 0 : options.injector) != null ? _a : (0, import_core.inject)(import_core.Injector);
  const subject = new import_rxjs.ReplaySubject(1);
  const watcher = (0, import_core.effect)(() => {
    let value;
    try {
      value = source();
    } catch (err) {
      (0, import_core.untracked)(() => subject.error(err));
      return;
    }
    (0, import_core.untracked)(() => subject.next(value));
  }, { injector, manualCleanup: true });
  injector.get(import_core.DestroyRef).onDestroy(() => {
    watcher.destroy();
    subject.complete();
  });
  return subject.asObservable();
}
function toSignal(source, options) {
  var _a, _b;
  ngDevMode && (0, import_core.assertNotInReactiveContext)(toSignal, "Invoking `toSignal` causes new subscriptions every time. Consider moving `toSignal` outside of the reactive context and read the signal value where needed.");
  const requiresCleanup = !(options == null ? void 0 : options.manualCleanup);
  requiresCleanup && !(options == null ? void 0 : options.injector) && (0, import_core.assertInInjectionContext)(toSignal);
  const cleanupRef = requiresCleanup ? (_b = (_a = options == null ? void 0 : options.injector) == null ? void 0 : _a.get(import_core.DestroyRef)) != null ? _b : (0, import_core.inject)(import_core.DestroyRef) : null;
  const equal = makeToSignalEqual(options == null ? void 0 : options.equal);
  let state;
  if (options == null ? void 0 : options.requireSync) {
    state = (0, import_core.signal)({
      kind: 0
      /* StateKind.NoValue */
    }, { equal });
  } else {
    state = (0, import_core.signal)({ kind: 1, value: options == null ? void 0 : options.initialValue }, { equal });
  }
  const sub = source.subscribe({
    next: (value) => state.set({ kind: 1, value }),
    error: (error) => {
      if (options == null ? void 0 : options.rejectErrors) {
        throw error;
      }
      state.set({ kind: 2, error });
    }
    // Completion of the Observable is meaningless to the signal. Signals don't have a concept of
    // "complete".
  });
  if ((options == null ? void 0 : options.requireSync) && state().kind === 0) {
    throw new import_core.\u0275RuntimeError(601, (typeof ngDevMode === "undefined" || ngDevMode) && "`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.");
  }
  cleanupRef == null ? void 0 : cleanupRef.onDestroy(sub.unsubscribe.bind(sub));
  return (0, import_core.computed)(() => {
    const current = state();
    switch (current.kind) {
      case 1:
        return current.value;
      case 2:
        throw current.error;
      case 0:
        throw new import_core.\u0275RuntimeError(601, (typeof ngDevMode === "undefined" || ngDevMode) && "`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.");
    }
  }, { equal: options == null ? void 0 : options.equal });
}
function makeToSignalEqual(userEquality = Object.is) {
  return (a, b) => a.kind === 1 && b.kind === 1 && userEquality(a.value, b.value);
}
