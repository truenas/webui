{
  "version": 3,
  "sources": ["/Users/macbook/karpov-work/TrueNAS/webui/node_modules/@angular/core/fesm2022/testing.mjs"],
  "sourcesContent": ["/**\n * @license Angular v18.2.4\n * (c) 2010-2024 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport * as i0 from '@angular/core';\nimport { \u0275DeferBlockState, \u0275triggerResourceLoading, \u0275renderDeferBlockState, \u0275CONTAINER_HEADER_OFFSET, \u0275getDeferBlocks, \u0275DeferBlockBehavior, InjectionToken, inject as inject$1, NgZone, ErrorHandler, Injectable, \u0275NoopNgZone, \u0275EffectScheduler, ApplicationRef, \u0275PendingTasks, getDebugNode, RendererFactory2, \u0275detectChangesInViewIfRequired, \u0275stringify, \u0275ReflectionCapabilities, Directive, Component, Pipe, NgModule, \u0275getAsyncClassMetadataFn, \u0275generateStandaloneInDeclarationsError, \u0275USE_RUNTIME_DEPS_TRACKER_FOR_JIT, \u0275depsTracker, \u0275getInjectableDef, resolveForwardRef, \u0275NG_COMP_DEF, \u0275isComponentDefPendingResolution, \u0275resolveComponentResources, \u0275Render3NgModuleRef, ApplicationInitStatus, LOCALE_ID, \u0275DEFAULT_LOCALE_ID, \u0275setLocaleId, \u0275Render3ComponentFactory, \u0275compileComponent, \u0275NG_DIR_DEF, \u0275compileDirective, \u0275NG_PIPE_DEF, \u0275compilePipe, \u0275NG_MOD_DEF, \u0275transitiveScopesFor, \u0275patchComponentDefWithScope, \u0275NG_INJ_DEF, \u0275compileNgModuleDefs, \u0275clearResolutionOfComponentResourcesQueue, \u0275restoreComponentResolutionQueue, \u0275internalProvideZoneChangeDetection, \u0275INTERNAL_APPLICATION_ERROR_HANDLER, \u0275ZONELESS_ENABLED, \u0275ChangeDetectionScheduler, \u0275ChangeDetectionSchedulerImpl, Compiler, \u0275DEFER_BLOCK_CONFIG, COMPILER_OPTIONS, Injector, \u0275isEnvironmentProviders, \u0275NgModuleFactory, ModuleWithComponentFactories, \u0275convertToBitFlags, InjectFlags, \u0275setAllowDuplicateNgModuleIdsForTest, \u0275resetCompiledComponents, \u0275setUnknownElementStrictMode, \u0275setUnknownPropertyStrictMode, \u0275getUnknownElementStrictMode, \u0275getUnknownPropertyStrictMode, runInInjectionContext, EnvironmentInjector, \u0275flushModuleScopingQueueAsMuchAsPossible } from '@angular/core';\nexport { \u0275DeferBlockBehavior as DeferBlockBehavior, \u0275DeferBlockState as DeferBlockState } from '@angular/core';\nimport { Subscription } from 'rxjs';\nimport { ResourceLoader } from '@angular/compiler';\n\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```\n * it('...', waitForAsync(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * })));\n * ```\n *\n * @publicApi\n */\nfunction waitForAsync(fn) {\n    const _Zone = typeof Zone !== 'undefined' ? Zone : null;\n    if (!_Zone) {\n        return function () {\n            return Promise.reject('Zone is needed for the waitForAsync() test helper but could not be found. ' +\n                'Please make sure that your environment includes zone.js');\n        };\n    }\n    const asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\n    if (typeof asyncTest === 'function') {\n        return asyncTest(fn);\n    }\n    return function () {\n        return Promise.reject('zone-testing.js is needed for the async() test helper but could not be found. ' +\n            'Please make sure that your environment includes zone.js/testing');\n    };\n}\n\n/**\n * Represents an individual defer block for testing purposes.\n *\n * @publicApi\n */\nclass DeferBlockFixture {\n    /** @nodoc */\n    constructor(block, componentFixture) {\n        this.block = block;\n        this.componentFixture = componentFixture;\n    }\n    /**\n     * Renders the specified state of the defer fixture.\n     * @param state the defer state to render\n     */\n    async render(state) {\n        if (!hasStateTemplate(state, this.block)) {\n            const stateAsString = getDeferBlockStateNameFromEnum(state);\n            throw new Error(`Tried to render this defer block in the \\`${stateAsString}\\` state, ` +\n                `but there was no @${stateAsString.toLowerCase()} block defined in a template.`);\n        }\n        if (state === \u0275DeferBlockState.Complete) {\n            await \u0275triggerResourceLoading(this.block.tDetails, this.block.lView, this.block.tNode);\n        }\n        // If the `render` method is used explicitly - skip timer-based scheduling for\n        // `@placeholder` and `@loading` blocks and render them immediately.\n        const skipTimerScheduling = true;\n        \u0275renderDeferBlockState(state, this.block.tNode, this.block.lContainer, skipTimerScheduling);\n        this.componentFixture.detectChanges();\n    }\n    /**\n     * Retrieves all nested child defer block fixtures\n     * in a given defer block.\n     */\n    getDeferBlocks() {\n        const deferBlocks = [];\n        // An LContainer that represents a defer block has at most 1 view, which is\n        // located right after an LContainer header. Get a hold of that view and inspect\n        // it for nested defer blocks.\n        const deferBlockFixtures = [];\n        if (this.block.lContainer.length >= \u0275CONTAINER_HEADER_OFFSET) {\n            const lView = this.block.lContainer[\u0275CONTAINER_HEADER_OFFSET];\n            \u0275getDeferBlocks(lView, deferBlocks);\n            for (const block of deferBlocks) {\n                deferBlockFixtures.push(new DeferBlockFixture(block, this.componentFixture));\n            }\n        }\n        return Promise.resolve(deferBlockFixtures);\n    }\n}\nfunction hasStateTemplate(state, block) {\n    switch (state) {\n        case \u0275DeferBlockState.Placeholder:\n            return block.tDetails.placeholderTmplIndex !== null;\n        case \u0275DeferBlockState.Loading:\n            return block.tDetails.loadingTmplIndex !== null;\n        case \u0275DeferBlockState.Error:\n            return block.tDetails.errorTmplIndex !== null;\n        case \u0275DeferBlockState.Complete:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction getDeferBlockStateNameFromEnum(state) {\n    switch (state) {\n        case \u0275DeferBlockState.Placeholder:\n            return 'Placeholder';\n        case \u0275DeferBlockState.Loading:\n            return 'Loading';\n        case \u0275DeferBlockState.Error:\n            return 'Error';\n        default:\n            return 'Main';\n    }\n}\n\n/** Whether test modules should be torn down by default. */\nconst TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT = true;\n/** Whether unknown elements in templates should throw by default. */\nconst THROW_ON_UNKNOWN_ELEMENTS_DEFAULT = false;\n/** Whether unknown properties in templates should throw by default. */\nconst THROW_ON_UNKNOWN_PROPERTIES_DEFAULT = false;\n/** Whether defer blocks should use manual triggering or play through normally. */\nconst DEFER_BLOCK_DEFAULT_BEHAVIOR = \u0275DeferBlockBehavior.Playthrough;\n/**\n * An abstract class for inserting the root test component element in a platform independent way.\n *\n * @publicApi\n */\nclass TestComponentRenderer {\n    insertRootElement(rootElementId) { }\n    removeAllRootElements() { }\n}\n/**\n * @publicApi\n */\nconst ComponentFixtureAutoDetect = new InjectionToken('ComponentFixtureAutoDetect');\n/**\n * @publicApi\n */\nconst ComponentFixtureNoNgZone = new InjectionToken('ComponentFixtureNoNgZone');\n\nconst RETHROW_APPLICATION_ERRORS = new InjectionToken('rethrow application errors');\nclass TestBedApplicationErrorHandler {\n    constructor() {\n        this.zone = inject$1(NgZone);\n        this.userErrorHandler = inject$1(ErrorHandler);\n        this.whenStableRejectFunctions = new Set();\n    }\n    handleError(e) {\n        try {\n            this.zone.runOutsideAngular(() => this.userErrorHandler.handleError(e));\n        }\n        catch (userError) {\n            e = userError;\n        }\n        // Instead of throwing the error when there are outstanding `fixture.whenStable` promises,\n        // reject those promises with the error. This allows developers to write\n        // expectAsync(fix.whenStable()).toBeRejected();\n        if (this.whenStableRejectFunctions.size > 0) {\n            for (const fn of this.whenStableRejectFunctions.values()) {\n                fn(e);\n            }\n            this.whenStableRejectFunctions.clear();\n        }\n        else {\n            throw e;\n        }\n    }\n    static { this.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.4\", ngImport: i0, type: TestBedApplicationErrorHandler, deps: [], target: i0.\u0275\u0275FactoryTarget.Injectable }); }\n    static { this.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"18.2.4\", ngImport: i0, type: TestBedApplicationErrorHandler }); }\n}\ni0.\u0275\u0275ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.4\", ngImport: i0, type: TestBedApplicationErrorHandler, decorators: [{\n            type: Injectable\n        }] });\n\n/**\n * Fixture for debugging and testing a component.\n *\n * @publicApi\n */\nclass ComponentFixture {\n    /** @nodoc */\n    constructor(componentRef) {\n        this.componentRef = componentRef;\n        this._isDestroyed = false;\n        /** @internal */\n        this._noZoneOptionIsSet = inject$1(ComponentFixtureNoNgZone, { optional: true });\n        /** @internal */\n        this._ngZone = this._noZoneOptionIsSet ? new \u0275NoopNgZone() : inject$1(NgZone);\n        /** @internal */\n        this._effectRunner = inject$1(\u0275EffectScheduler);\n        // Inject ApplicationRef to ensure NgZone stableness causes after render hooks to run\n        // This will likely happen as a result of fixture.detectChanges because it calls ngZone.run\n        // This is a crazy way of doing things but hey, it's the world we live in.\n        // The zoneless scheduler should instead do this more imperatively by attaching\n        // the `ComponentRef` to `ApplicationRef` and calling `appRef.tick` as the `detectChanges`\n        // behavior.\n        /** @internal */\n        this._appRef = inject$1(ApplicationRef);\n        /** @internal */\n        this._testAppRef = this._appRef;\n        this.pendingTasks = inject$1(\u0275PendingTasks);\n        this.appErrorHandler = inject$1(TestBedApplicationErrorHandler);\n        // TODO(atscott): Remove this from public API\n        this.ngZone = this._noZoneOptionIsSet ? null : this._ngZone;\n        this.changeDetectorRef = componentRef.changeDetectorRef;\n        this.elementRef = componentRef.location;\n        this.debugElement = getDebugNode(this.elementRef.nativeElement);\n        this.componentInstance = componentRef.instance;\n        this.nativeElement = this.elementRef.nativeElement;\n        this.componentRef = componentRef;\n    }\n    /**\n     * Do a change detection run to make sure there were no changes.\n     */\n    checkNoChanges() {\n        this.changeDetectorRef.checkNoChanges();\n    }\n    /**\n     * Return whether the fixture is currently stable or has async tasks that have not been completed\n     * yet.\n     */\n    isStable() {\n        return !this.pendingTasks.hasPendingTasks.value;\n    }\n    /**\n     * Get a promise that resolves when the fixture is stable.\n     *\n     * This can be used to resume testing after events have triggered asynchronous activity or\n     * asynchronous change detection.\n     */\n    whenStable() {\n        if (this.isStable()) {\n            return Promise.resolve(false);\n        }\n        return new Promise((resolve, reject) => {\n            this.appErrorHandler.whenStableRejectFunctions.add(reject);\n            this._appRef.whenStable().then(() => {\n                this.appErrorHandler.whenStableRejectFunctions.delete(reject);\n                resolve(true);\n            });\n        });\n    }\n    /**\n     * Retrieves all defer block fixtures in the component fixture.\n     */\n    getDeferBlocks() {\n        const deferBlocks = [];\n        const lView = this.componentRef.hostView['_lView'];\n        \u0275getDeferBlocks(lView, deferBlocks);\n        const deferBlockFixtures = [];\n        for (const block of deferBlocks) {\n            deferBlockFixtures.push(new DeferBlockFixture(block, this));\n        }\n        return Promise.resolve(deferBlockFixtures);\n    }\n    _getRenderer() {\n        if (this._renderer === undefined) {\n            this._renderer = this.componentRef.injector.get(RendererFactory2, null);\n        }\n        return this._renderer;\n    }\n    /**\n     * Get a promise that resolves when the ui state is stable following animations.\n     */\n    whenRenderingDone() {\n        const renderer = this._getRenderer();\n        if (renderer && renderer.whenRenderingDone) {\n            return renderer.whenRenderingDone();\n        }\n        return this.whenStable();\n    }\n    /**\n     * Trigger component destruction.\n     */\n    destroy() {\n        if (!this._isDestroyed) {\n            this.componentRef.destroy();\n            this._isDestroyed = true;\n        }\n    }\n}\n/**\n * ComponentFixture behavior that actually attaches the component to the application to ensure\n * behaviors between fixture and application do not diverge. `detectChanges` is disabled by default\n * (instead, tests should wait for the scheduler to detect changes), `whenStable` is directly the\n * `ApplicationRef.isStable`, and `autoDetectChanges` cannot be disabled.\n */\nclass ScheduledComponentFixture extends ComponentFixture {\n    constructor() {\n        super(...arguments);\n        this._autoDetect = inject$1(ComponentFixtureAutoDetect, { optional: true }) ?? true;\n    }\n    initialize() {\n        if (this._autoDetect) {\n            this._appRef.attachView(this.componentRef.hostView);\n        }\n    }\n    detectChanges(checkNoChanges = true) {\n        if (!checkNoChanges) {\n            throw new Error('Cannot disable `checkNoChanges` in this configuration. ' +\n                'Use `fixture.componentRef.hostView.changeDetectorRef.detectChanges()` instead.');\n        }\n        this._effectRunner.flush();\n        this._appRef.tick();\n        this._effectRunner.flush();\n    }\n    autoDetectChanges(autoDetect = true) {\n        if (!autoDetect) {\n            throw new Error('Cannot disable autoDetect after it has been enabled when using the zoneless scheduler. ' +\n                'To disable autoDetect, add `{provide: ComponentFixtureAutoDetect, useValue: false}` to the TestBed providers.');\n        }\n        else if (!this._autoDetect) {\n            this._autoDetect = autoDetect;\n            this._appRef.attachView(this.componentRef.hostView);\n        }\n        this.detectChanges();\n    }\n}\n/**\n * ComponentFixture behavior that attempts to act as a \"mini application\".\n */\nclass PseudoApplicationComponentFixture extends ComponentFixture {\n    constructor() {\n        super(...arguments);\n        this._subscriptions = new Subscription();\n        this._autoDetect = inject$1(ComponentFixtureAutoDetect, { optional: true }) ?? false;\n        this.afterTickSubscription = undefined;\n        this.beforeRenderSubscription = undefined;\n    }\n    initialize() {\n        if (this._autoDetect) {\n            this.subscribeToAppRefEvents();\n        }\n        this.componentRef.hostView.onDestroy(() => {\n            this.unsubscribeFromAppRefEvents();\n        });\n        // Create subscriptions outside the NgZone so that the callbacks run outside\n        // of NgZone.\n        this._ngZone.runOutsideAngular(() => {\n            this._subscriptions.add(this._ngZone.onError.subscribe({\n                next: (error) => {\n                    throw error;\n                },\n            }));\n        });\n    }\n    detectChanges(checkNoChanges = true) {\n        this._effectRunner.flush();\n        // Run the change detection inside the NgZone so that any async tasks as part of the change\n        // detection are captured by the zone and can be waited for in isStable.\n        this._ngZone.run(() => {\n            this.changeDetectorRef.detectChanges();\n            if (checkNoChanges) {\n                this.checkNoChanges();\n            }\n        });\n        // Run any effects that were created/dirtied during change detection. Such effects might become\n        // dirty in response to input signals changing.\n        this._effectRunner.flush();\n    }\n    autoDetectChanges(autoDetect = true) {\n        if (this._noZoneOptionIsSet) {\n            throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set.');\n        }\n        if (autoDetect !== this._autoDetect) {\n            if (autoDetect) {\n                this.subscribeToAppRefEvents();\n            }\n            else {\n                this.unsubscribeFromAppRefEvents();\n            }\n        }\n        this._autoDetect = autoDetect;\n        this.detectChanges();\n    }\n    subscribeToAppRefEvents() {\n        this._ngZone.runOutsideAngular(() => {\n            this.afterTickSubscription = this._testAppRef.afterTick.subscribe(() => {\n                this.checkNoChanges();\n            });\n            this.beforeRenderSubscription = this._testAppRef.beforeRender.subscribe((isFirstPass) => {\n                try {\n                    \u0275detectChangesInViewIfRequired(this.componentRef.hostView._lView, this.componentRef.hostView.notifyErrorHandler, isFirstPass, false /** zoneless enabled */);\n                }\n                catch (e) {\n                    // If an error occurred during change detection, remove the test view from the application\n                    // ref tracking. Note that this isn't exactly desirable but done this way because of how\n                    // things used to work with `autoDetect` and uncaught errors. Ideally we would surface\n                    // this error to the error handler instead and continue refreshing the view like\n                    // what would happen in the application.\n                    this.unsubscribeFromAppRefEvents();\n                    throw e;\n                }\n            });\n            this._testAppRef.externalTestViews.add(this.componentRef.hostView);\n        });\n    }\n    unsubscribeFromAppRefEvents() {\n        this.afterTickSubscription?.unsubscribe();\n        this.beforeRenderSubscription?.unsubscribe();\n        this.afterTickSubscription = undefined;\n        this.beforeRenderSubscription = undefined;\n        this._testAppRef.externalTestViews.delete(this.componentRef.hostView);\n    }\n    destroy() {\n        this.unsubscribeFromAppRefEvents();\n        this._subscriptions.unsubscribe();\n        super.destroy();\n    }\n}\n\nconst _Zone = typeof Zone !== 'undefined' ? Zone : null;\nconst fakeAsyncTestModule = _Zone && _Zone[_Zone.__symbol__('fakeAsyncTest')];\nconst fakeAsyncTestModuleNotLoadedErrorMessage = `zone-testing.js is needed for the fakeAsync() test helper but could not be found.\n        Please make sure that your environment includes zone.js/testing`;\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @publicApi\n */\nfunction resetFakeAsyncZone() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.resetFakeAsyncZone();\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\nfunction resetFakeAsyncZoneIfExists() {\n    if (fakeAsyncTestModule) {\n        fakeAsyncTestModule.resetFakeAsyncZone();\n    }\n}\n/**\n * Wraps a function to be executed in the `fakeAsync` zone:\n * - Microtasks are manually executed by calling `flushMicrotasks()`.\n * - Timers are synchronous; `tick()` simulates the asynchronous passage of time.\n *\n * Can be used to wrap `inject()` calls.\n *\n * @param fn The function that you want to wrap in the `fakeAsync` zone.\n * @param options\n *   - flush: When true, will drain the macrotask queue after the test function completes.\n *     When false, will throw an exception at the end of the function if there are pending timers.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n *\n * @returns The function wrapped to be executed in the `fakeAsync` zone.\n * Any arguments passed when calling this returned function will be passed through to the `fn`\n * function in the parameters when it is called.\n *\n * @publicApi\n */\nfunction fakeAsync(fn, options) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.fakeAsync(fn, options);\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the `fakeAsync` zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * @param millis The number of milliseconds to advance the virtual timer.\n * @param tickOptions The options to pass to the `tick()` function.\n *\n * @usageNotes\n *\n * The `tick()` option is a flag called `processNewMacroTasksSynchronously`,\n * which determines whether or not to invoke new macroTasks.\n *\n * If you provide a `tickOptions` object, but do not specify a\n * `processNewMacroTasksSynchronously` property (`tick(100, {})`),\n * then `processNewMacroTasksSynchronously` defaults to true.\n *\n * If you omit the `tickOptions` parameter (`tick(100))`), then\n * `tickOptions` defaults to `{processNewMacroTasksSynchronously: true}`.\n *\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * The following example includes a nested timeout (new macroTask), and\n * the `tickOptions` parameter is allowed to default. In this case,\n * `processNewMacroTasksSynchronously` defaults to true, and the nested\n * function is executed on each tick.\n *\n * ```\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick();\n *   expect(nestedTimeoutInvoked).toBe(true);\n * }));\n * ```\n *\n * In the following case, `processNewMacroTasksSynchronously` is explicitly\n * set to false, so the nested timeout function is not invoked.\n *\n * ```\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick(0, {processNewMacroTasksSynchronously: false});\n *   expect(nestedTimeoutInvoked).toBe(false);\n * }));\n * ```\n *\n *\n * @publicApi\n */\nfunction tick(millis = 0, tickOptions = {\n    processNewMacroTasksSynchronously: true,\n}) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.tick(millis, tickOptions);\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Flushes any pending microtasks and simulates the asynchronous passage of time for the timers in\n * the `fakeAsync` zone by\n * draining the macrotask queue until it is empty.\n *\n * @param maxTurns The maximum number of times the scheduler attempts to clear its queue before\n *     throwing an error.\n * @returns The simulated time elapsed, in milliseconds.\n *\n * @publicApi\n */\nfunction flush(maxTurns) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.flush(maxTurns);\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Discard all remaining periodic tasks.\n *\n * @publicApi\n */\nfunction discardPeriodicTasks() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.discardPeriodicTasks();\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Flush any pending microtasks.\n *\n * @publicApi\n */\nfunction flushMicrotasks() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.flushMicrotasks();\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n\nlet _nextReferenceId = 0;\nclass MetadataOverrider {\n    constructor() {\n        this._references = new Map();\n    }\n    /**\n     * Creates a new instance for the given metadata class\n     * based on an old instance and overrides.\n     */\n    overrideMetadata(metadataClass, oldMetadata, override) {\n        const props = {};\n        if (oldMetadata) {\n            _valueProps(oldMetadata).forEach((prop) => (props[prop] = oldMetadata[prop]));\n        }\n        if (override.set) {\n            if (override.remove || override.add) {\n                throw new Error(`Cannot set and add/remove ${\u0275stringify(metadataClass)} at the same time!`);\n            }\n            setMetadata(props, override.set);\n        }\n        if (override.remove) {\n            removeMetadata(props, override.remove, this._references);\n        }\n        if (override.add) {\n            addMetadata(props, override.add);\n        }\n        return new metadataClass(props);\n    }\n}\nfunction removeMetadata(metadata, remove, references) {\n    const removeObjects = new Set();\n    for (const prop in remove) {\n        const removeValue = remove[prop];\n        if (Array.isArray(removeValue)) {\n            removeValue.forEach((value) => {\n                removeObjects.add(_propHashKey(prop, value, references));\n            });\n        }\n        else {\n            removeObjects.add(_propHashKey(prop, removeValue, references));\n        }\n    }\n    for (const prop in metadata) {\n        const propValue = metadata[prop];\n        if (Array.isArray(propValue)) {\n            metadata[prop] = propValue.filter((value) => !removeObjects.has(_propHashKey(prop, value, references)));\n        }\n        else {\n            if (removeObjects.has(_propHashKey(prop, propValue, references))) {\n                metadata[prop] = undefined;\n            }\n        }\n    }\n}\nfunction addMetadata(metadata, add) {\n    for (const prop in add) {\n        const addValue = add[prop];\n        const propValue = metadata[prop];\n        if (propValue != null && Array.isArray(propValue)) {\n            metadata[prop] = propValue.concat(addValue);\n        }\n        else {\n            metadata[prop] = addValue;\n        }\n    }\n}\nfunction setMetadata(metadata, set) {\n    for (const prop in set) {\n        metadata[prop] = set[prop];\n    }\n}\nfunction _propHashKey(propName, propValue, references) {\n    let nextObjectId = 0;\n    const objectIds = new Map();\n    const replacer = (key, value) => {\n        if (value !== null && typeof value === 'object') {\n            if (objectIds.has(value)) {\n                return objectIds.get(value);\n            }\n            // Record an id for this object such that any later references use the object's id instead\n            // of the object itself, in order to break cyclic pointers in objects.\n            objectIds.set(value, `\u0275obj#${nextObjectId++}`);\n            // The first time an object is seen the object itself is serialized.\n            return value;\n        }\n        else if (typeof value === 'function') {\n            value = _serializeReference(value, references);\n        }\n        return value;\n    };\n    return `${propName}:${JSON.stringify(propValue, replacer)}`;\n}\nfunction _serializeReference(ref, references) {\n    let id = references.get(ref);\n    if (!id) {\n        id = `${\u0275stringify(ref)}${_nextReferenceId++}`;\n        references.set(ref, id);\n    }\n    return id;\n}\nfunction _valueProps(obj) {\n    const props = [];\n    // regular public props\n    Object.keys(obj).forEach((prop) => {\n        if (!prop.startsWith('_')) {\n            props.push(prop);\n        }\n    });\n    // getters\n    let proto = obj;\n    while ((proto = Object.getPrototypeOf(proto))) {\n        Object.keys(proto).forEach((protoProp) => {\n            const desc = Object.getOwnPropertyDescriptor(proto, protoProp);\n            if (!protoProp.startsWith('_') && desc && 'get' in desc) {\n                props.push(protoProp);\n            }\n        });\n    }\n    return props;\n}\n\nconst reflection = new \u0275ReflectionCapabilities();\n/**\n * Allows to override ivy metadata for tests (via the `TestBed`).\n */\nclass OverrideResolver {\n    constructor() {\n        this.overrides = new Map();\n        this.resolved = new Map();\n    }\n    addOverride(type, override) {\n        const overrides = this.overrides.get(type) || [];\n        overrides.push(override);\n        this.overrides.set(type, overrides);\n        this.resolved.delete(type);\n    }\n    setOverrides(overrides) {\n        this.overrides.clear();\n        overrides.forEach(([type, override]) => {\n            this.addOverride(type, override);\n        });\n    }\n    getAnnotation(type) {\n        const annotations = reflection.annotations(type);\n        // Try to find the nearest known Type annotation and make sure that this annotation is an\n        // instance of the type we are looking for, so we can use it for resolution. Note: there might\n        // be multiple known annotations found due to the fact that Components can extend Directives (so\n        // both Directive and Component annotations would be present), so we always check if the known\n        // annotation has the right type.\n        for (let i = annotations.length - 1; i >= 0; i--) {\n            const annotation = annotations[i];\n            const isKnownType = annotation instanceof Directive ||\n                annotation instanceof Component ||\n                annotation instanceof Pipe ||\n                annotation instanceof NgModule;\n            if (isKnownType) {\n                return annotation instanceof this.type ? annotation : null;\n            }\n        }\n        return null;\n    }\n    resolve(type) {\n        let resolved = this.resolved.get(type) || null;\n        if (!resolved) {\n            resolved = this.getAnnotation(type);\n            if (resolved) {\n                const overrides = this.overrides.get(type);\n                if (overrides) {\n                    const overrider = new MetadataOverrider();\n                    overrides.forEach((override) => {\n                        resolved = overrider.overrideMetadata(this.type, resolved, override);\n                    });\n                }\n            }\n            this.resolved.set(type, resolved);\n        }\n        return resolved;\n    }\n}\nclass DirectiveResolver extends OverrideResolver {\n    get type() {\n        return Directive;\n    }\n}\nclass ComponentResolver extends OverrideResolver {\n    get type() {\n        return Component;\n    }\n}\nclass PipeResolver extends OverrideResolver {\n    get type() {\n        return Pipe;\n    }\n}\nclass NgModuleResolver extends OverrideResolver {\n    get type() {\n        return NgModule;\n    }\n}\n\nvar TestingModuleOverride;\n(function (TestingModuleOverride) {\n    TestingModuleOverride[TestingModuleOverride[\"DECLARATION\"] = 0] = \"DECLARATION\";\n    TestingModuleOverride[TestingModuleOverride[\"OVERRIDE_TEMPLATE\"] = 1] = \"OVERRIDE_TEMPLATE\";\n})(TestingModuleOverride || (TestingModuleOverride = {}));\nfunction isTestingModuleOverride(value) {\n    return (value === TestingModuleOverride.DECLARATION || value === TestingModuleOverride.OVERRIDE_TEMPLATE);\n}\nfunction assertNoStandaloneComponents(types, resolver, location) {\n    types.forEach((type) => {\n        if (!\u0275getAsyncClassMetadataFn(type)) {\n            const component = resolver.resolve(type);\n            if (component && component.standalone) {\n                throw new Error(\u0275generateStandaloneInDeclarationsError(type, location));\n            }\n        }\n    });\n}\nclass TestBedCompiler {\n    constructor(platform, additionalModuleTypes) {\n        this.platform = platform;\n        this.additionalModuleTypes = additionalModuleTypes;\n        this.originalComponentResolutionQueue = null;\n        // Testing module configuration\n        this.declarations = [];\n        this.imports = [];\n        this.providers = [];\n        this.schemas = [];\n        // Queues of components/directives/pipes that should be recompiled.\n        this.pendingComponents = new Set();\n        this.pendingDirectives = new Set();\n        this.pendingPipes = new Set();\n        // Set of components with async metadata, i.e. components with `@defer` blocks\n        // in their templates.\n        this.componentsWithAsyncMetadata = new Set();\n        // Keep track of all components and directives, so we can patch Providers onto defs later.\n        this.seenComponents = new Set();\n        this.seenDirectives = new Set();\n        // Keep track of overridden modules, so that we can collect all affected ones in the module tree.\n        this.overriddenModules = new Set();\n        // Store resolved styles for Components that have template overrides present and `styleUrls`\n        // defined at the same time.\n        this.existingComponentStyles = new Map();\n        this.resolvers = initResolvers();\n        // Map of component type to an NgModule that declares it.\n        //\n        // There are a couple special cases:\n        // - for standalone components, the module scope value is `null`\n        // - when a component is declared in `TestBed.configureTestingModule()` call or\n        //   a component's template is overridden via `TestBed.overrideTemplateUsingTestingModule()`.\n        //   we use a special value from the `TestingModuleOverride` enum.\n        this.componentToModuleScope = new Map();\n        // Map that keeps initial version of component/directive/pipe defs in case\n        // we compile a Type again, thus overriding respective static fields. This is\n        // required to make sure we restore defs to their initial states between test runs.\n        // Note: one class may have multiple defs (for example: \u0275mod and \u0275inj in case of an\n        // NgModule), store all of them in a map.\n        this.initialNgDefs = new Map();\n        // Array that keeps cleanup operations for initial versions of component/directive/pipe/module\n        // defs in case TestBed makes changes to the originals.\n        this.defCleanupOps = [];\n        this._injector = null;\n        this.compilerProviders = null;\n        this.providerOverrides = [];\n        this.rootProviderOverrides = [];\n        // Overrides for injectables with `{providedIn: SomeModule}` need to be tracked and added to that\n        // module's provider list.\n        this.providerOverridesByModule = new Map();\n        this.providerOverridesByToken = new Map();\n        this.scopesWithOverriddenProviders = new Set();\n        this.testModuleRef = null;\n        this.deferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n        class DynamicTestModule {\n        }\n        this.testModuleType = DynamicTestModule;\n    }\n    setCompilerProviders(providers) {\n        this.compilerProviders = providers;\n        this._injector = null;\n    }\n    configureTestingModule(moduleDef) {\n        // Enqueue any compilation tasks for the directly declared component.\n        if (moduleDef.declarations !== undefined) {\n            // Verify that there are no standalone components\n            assertNoStandaloneComponents(moduleDef.declarations, this.resolvers.component, '\"TestBed.configureTestingModule\" call');\n            this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);\n            this.declarations.push(...moduleDef.declarations);\n        }\n        // Enqueue any compilation tasks for imported modules.\n        if (moduleDef.imports !== undefined) {\n            this.queueTypesFromModulesArray(moduleDef.imports);\n            this.imports.push(...moduleDef.imports);\n        }\n        if (moduleDef.providers !== undefined) {\n            this.providers.push(...moduleDef.providers);\n        }\n        this.providers.push({\n            provide: RETHROW_APPLICATION_ERRORS,\n            useValue: moduleDef._rethrowApplicationTickErrors ?? false,\n        });\n        if (moduleDef.schemas !== undefined) {\n            this.schemas.push(...moduleDef.schemas);\n        }\n        this.deferBlockBehavior = moduleDef.deferBlockBehavior ?? DEFER_BLOCK_DEFAULT_BEHAVIOR;\n    }\n    overrideModule(ngModule, override) {\n        if (\u0275USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {\n            \u0275depsTracker.clearScopeCacheFor(ngModule);\n        }\n        this.overriddenModules.add(ngModule);\n        // Compile the module right away.\n        this.resolvers.module.addOverride(ngModule, override);\n        const metadata = this.resolvers.module.resolve(ngModule);\n        if (metadata === null) {\n            throw invalidTypeError(ngModule.name, 'NgModule');\n        }\n        this.recompileNgModule(ngModule, metadata);\n        // At this point, the module has a valid module def (\u0275mod), but the override may have introduced\n        // new declarations or imported modules. Ingest any possible new types and add them to the\n        // current queue.\n        this.queueTypesFromModulesArray([ngModule]);\n    }\n    overrideComponent(component, override) {\n        this.verifyNoStandaloneFlagOverrides(component, override);\n        this.resolvers.component.addOverride(component, override);\n        this.pendingComponents.add(component);\n        // If this is a component with async metadata (i.e. a component with a `@defer` block\n        // in a template) - store it for future processing.\n        this.maybeRegisterComponentWithAsyncMetadata(component);\n    }\n    overrideDirective(directive, override) {\n        this.verifyNoStandaloneFlagOverrides(directive, override);\n        this.resolvers.directive.addOverride(directive, override);\n        this.pendingDirectives.add(directive);\n    }\n    overridePipe(pipe, override) {\n        this.verifyNoStandaloneFlagOverrides(pipe, override);\n        this.resolvers.pipe.addOverride(pipe, override);\n        this.pendingPipes.add(pipe);\n    }\n    verifyNoStandaloneFlagOverrides(type, override) {\n        if (override.add?.hasOwnProperty('standalone') ||\n            override.set?.hasOwnProperty('standalone') ||\n            override.remove?.hasOwnProperty('standalone')) {\n            throw new Error(`An override for the ${type.name} class has the \\`standalone\\` flag. ` +\n                `Changing the \\`standalone\\` flag via TestBed overrides is not supported.`);\n        }\n    }\n    overrideProvider(token, provider) {\n        let providerDef;\n        if (provider.useFactory !== undefined) {\n            providerDef = {\n                provide: token,\n                useFactory: provider.useFactory,\n                deps: provider.deps || [],\n                multi: provider.multi,\n            };\n        }\n        else if (provider.useValue !== undefined) {\n            providerDef = { provide: token, useValue: provider.useValue, multi: provider.multi };\n        }\n        else {\n            providerDef = { provide: token };\n        }\n        const injectableDef = typeof token !== 'string' ? \u0275getInjectableDef(token) : null;\n        const providedIn = injectableDef === null ? null : resolveForwardRef(injectableDef.providedIn);\n        const overridesBucket = providedIn === 'root' ? this.rootProviderOverrides : this.providerOverrides;\n        overridesBucket.push(providerDef);\n        // Keep overrides grouped by token as well for fast lookups using token\n        this.providerOverridesByToken.set(token, providerDef);\n        if (injectableDef !== null && providedIn !== null && typeof providedIn !== 'string') {\n            const existingOverrides = this.providerOverridesByModule.get(providedIn);\n            if (existingOverrides !== undefined) {\n                existingOverrides.push(providerDef);\n            }\n            else {\n                this.providerOverridesByModule.set(providedIn, [providerDef]);\n            }\n        }\n    }\n    overrideTemplateUsingTestingModule(type, template) {\n        const def = type[\u0275NG_COMP_DEF];\n        const hasStyleUrls = () => {\n            const metadata = this.resolvers.component.resolve(type);\n            return !!metadata.styleUrl || !!metadata.styleUrls?.length;\n        };\n        const overrideStyleUrls = !!def && !\u0275isComponentDefPendingResolution(type) && hasStyleUrls();\n        // In Ivy, compiling a component does not require knowing the module providing the\n        // component's scope, so overrideTemplateUsingTestingModule can be implemented purely via\n        // overrideComponent. Important: overriding template requires full Component re-compilation,\n        // which may fail in case styleUrls are also present (thus Component is considered as required\n        // resolution). In order to avoid this, we preemptively set styleUrls to an empty array,\n        // preserve current styles available on Component def and restore styles back once compilation\n        // is complete.\n        const override = overrideStyleUrls\n            ? { template, styles: [], styleUrls: [], styleUrl: undefined }\n            : { template };\n        this.overrideComponent(type, { set: override });\n        if (overrideStyleUrls && def.styles && def.styles.length > 0) {\n            this.existingComponentStyles.set(type, def.styles);\n        }\n        // Set the component's scope to be the testing module.\n        this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);\n    }\n    async resolvePendingComponentsWithAsyncMetadata() {\n        if (this.componentsWithAsyncMetadata.size === 0)\n            return;\n        const promises = [];\n        for (const component of this.componentsWithAsyncMetadata) {\n            const asyncMetadataFn = \u0275getAsyncClassMetadataFn(component);\n            if (asyncMetadataFn) {\n                promises.push(asyncMetadataFn());\n            }\n        }\n        this.componentsWithAsyncMetadata.clear();\n        const resolvedDeps = await Promise.all(promises);\n        const flatResolvedDeps = resolvedDeps.flat(2);\n        this.queueTypesFromModulesArray(flatResolvedDeps);\n        // Loaded standalone components might contain imports of NgModules\n        // with providers, make sure we override providers there too.\n        for (const component of flatResolvedDeps) {\n            this.applyProviderOverridesInScope(component);\n        }\n    }\n    async compileComponents() {\n        this.clearComponentResolutionQueue();\n        // Wait for all async metadata for components that were\n        // overridden, we need resolved metadata to perform an override\n        // and re-compile a component.\n        await this.resolvePendingComponentsWithAsyncMetadata();\n        // Verify that there were no standalone components present in the `declarations` field\n        // during the `TestBed.configureTestingModule` call. We perform this check here in addition\n        // to the logic in the `configureTestingModule` function, since at this point we have\n        // all async metadata resolved.\n        assertNoStandaloneComponents(this.declarations, this.resolvers.component, '\"TestBed.configureTestingModule\" call');\n        // Run compilers for all queued types.\n        let needsAsyncResources = this.compileTypesSync();\n        // compileComponents() should not be async unless it needs to be.\n        if (needsAsyncResources) {\n            let resourceLoader;\n            let resolver = (url) => {\n                if (!resourceLoader) {\n                    resourceLoader = this.injector.get(ResourceLoader);\n                }\n                return Promise.resolve(resourceLoader.get(url));\n            };\n            await \u0275resolveComponentResources(resolver);\n        }\n    }\n    finalize() {\n        // One last compile\n        this.compileTypesSync();\n        // Create the testing module itself.\n        this.compileTestModule();\n        this.applyTransitiveScopes();\n        this.applyProviderOverrides();\n        // Patch previously stored `styles` Component values (taken from \u0275cmp), in case these\n        // Components have `styleUrls` fields defined and template override was requested.\n        this.patchComponentsWithExistingStyles();\n        // Clear the componentToModuleScope map, so that future compilations don't reset the scope of\n        // every component.\n        this.componentToModuleScope.clear();\n        const parentInjector = this.platform.injector;\n        this.testModuleRef = new \u0275Render3NgModuleRef(this.testModuleType, parentInjector, []);\n        // ApplicationInitStatus.runInitializers() is marked @internal to core.\n        // Cast it to any before accessing it.\n        this.testModuleRef.injector.get(ApplicationInitStatus).runInitializers();\n        // Set locale ID after running app initializers, since locale information might be updated while\n        // running initializers. This is also consistent with the execution order while bootstrapping an\n        // app (see `packages/core/src/application_ref.ts` file).\n        const localeId = this.testModuleRef.injector.get(LOCALE_ID, \u0275DEFAULT_LOCALE_ID);\n        \u0275setLocaleId(localeId);\n        return this.testModuleRef;\n    }\n    /**\n     * @internal\n     */\n    _compileNgModuleSync(moduleType) {\n        this.queueTypesFromModulesArray([moduleType]);\n        this.compileTypesSync();\n        this.applyProviderOverrides();\n        this.applyProviderOverridesInScope(moduleType);\n        this.applyTransitiveScopes();\n    }\n    /**\n     * @internal\n     */\n    async _compileNgModuleAsync(moduleType) {\n        this.queueTypesFromModulesArray([moduleType]);\n        await this.compileComponents();\n        this.applyProviderOverrides();\n        this.applyProviderOverridesInScope(moduleType);\n        this.applyTransitiveScopes();\n    }\n    /**\n     * @internal\n     */\n    _getModuleResolver() {\n        return this.resolvers.module;\n    }\n    /**\n     * @internal\n     */\n    _getComponentFactories(moduleType) {\n        return maybeUnwrapFn(moduleType.\u0275mod.declarations).reduce((factories, declaration) => {\n            const componentDef = declaration.\u0275cmp;\n            componentDef && factories.push(new \u0275Render3ComponentFactory(componentDef, this.testModuleRef));\n            return factories;\n        }, []);\n    }\n    compileTypesSync() {\n        // Compile all queued components, directives, pipes.\n        let needsAsyncResources = false;\n        this.pendingComponents.forEach((declaration) => {\n            if (\u0275getAsyncClassMetadataFn(declaration)) {\n                throw new Error(`Component '${declaration.name}' has unresolved metadata. ` +\n                    `Please call \\`await TestBed.compileComponents()\\` before running this test.`);\n            }\n            needsAsyncResources = needsAsyncResources || \u0275isComponentDefPendingResolution(declaration);\n            const metadata = this.resolvers.component.resolve(declaration);\n            if (metadata === null) {\n                throw invalidTypeError(declaration.name, 'Component');\n            }\n            this.maybeStoreNgDef(\u0275NG_COMP_DEF, declaration);\n            if (\u0275USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {\n                \u0275depsTracker.clearScopeCacheFor(declaration);\n            }\n            \u0275compileComponent(declaration, metadata);\n        });\n        this.pendingComponents.clear();\n        this.pendingDirectives.forEach((declaration) => {\n            const metadata = this.resolvers.directive.resolve(declaration);\n            if (metadata === null) {\n                throw invalidTypeError(declaration.name, 'Directive');\n            }\n            this.maybeStoreNgDef(\u0275NG_DIR_DEF, declaration);\n            \u0275compileDirective(declaration, metadata);\n        });\n        this.pendingDirectives.clear();\n        this.pendingPipes.forEach((declaration) => {\n            const metadata = this.resolvers.pipe.resolve(declaration);\n            if (metadata === null) {\n                throw invalidTypeError(declaration.name, 'Pipe');\n            }\n            this.maybeStoreNgDef(\u0275NG_PIPE_DEF, declaration);\n            \u0275compilePipe(declaration, metadata);\n        });\n        this.pendingPipes.clear();\n        return needsAsyncResources;\n    }\n    applyTransitiveScopes() {\n        if (this.overriddenModules.size > 0) {\n            // Module overrides (via `TestBed.overrideModule`) might affect scopes that were previously\n            // calculated and stored in `transitiveCompileScopes`. If module overrides are present,\n            // collect all affected modules and reset scopes to force their re-calculation.\n            const testingModuleDef = this.testModuleType[\u0275NG_MOD_DEF];\n            const affectedModules = this.collectModulesAffectedByOverrides(testingModuleDef.imports);\n            if (affectedModules.size > 0) {\n                affectedModules.forEach((moduleType) => {\n                    if (!\u0275USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {\n                        this.storeFieldOfDefOnType(moduleType, \u0275NG_MOD_DEF, 'transitiveCompileScopes');\n                        moduleType[\u0275NG_MOD_DEF].transitiveCompileScopes = null;\n                    }\n                    else {\n                        \u0275depsTracker.clearScopeCacheFor(moduleType);\n                    }\n                });\n            }\n        }\n        const moduleToScope = new Map();\n        const getScopeOfModule = (moduleType) => {\n            if (!moduleToScope.has(moduleType)) {\n                const isTestingModule = isTestingModuleOverride(moduleType);\n                const realType = isTestingModule ? this.testModuleType : moduleType;\n                moduleToScope.set(moduleType, \u0275transitiveScopesFor(realType));\n            }\n            return moduleToScope.get(moduleType);\n        };\n        this.componentToModuleScope.forEach((moduleType, componentType) => {\n            if (moduleType !== null) {\n                const moduleScope = getScopeOfModule(moduleType);\n                this.storeFieldOfDefOnType(componentType, \u0275NG_COMP_DEF, 'directiveDefs');\n                this.storeFieldOfDefOnType(componentType, \u0275NG_COMP_DEF, 'pipeDefs');\n                \u0275patchComponentDefWithScope(getComponentDef(componentType), moduleScope);\n            }\n            // `tView` that is stored on component def contains information about directives and pipes\n            // that are in the scope of this component. Patching component scope will cause `tView` to be\n            // changed. Store original `tView` before patching scope, so the `tView` (including scope\n            // information) is restored back to its previous/original state before running next test.\n            // Resetting `tView` is also needed for cases when we apply provider overrides and those\n            // providers are defined on component's level, in which case they may end up included into\n            // `tView.blueprint`.\n            this.storeFieldOfDefOnType(componentType, \u0275NG_COMP_DEF, 'tView');\n        });\n        this.componentToModuleScope.clear();\n    }\n    applyProviderOverrides() {\n        const maybeApplyOverrides = (field) => (type) => {\n            const resolver = field === \u0275NG_COMP_DEF ? this.resolvers.component : this.resolvers.directive;\n            const metadata = resolver.resolve(type);\n            if (this.hasProviderOverrides(metadata.providers)) {\n                this.patchDefWithProviderOverrides(type, field);\n            }\n        };\n        this.seenComponents.forEach(maybeApplyOverrides(\u0275NG_COMP_DEF));\n        this.seenDirectives.forEach(maybeApplyOverrides(\u0275NG_DIR_DEF));\n        this.seenComponents.clear();\n        this.seenDirectives.clear();\n    }\n    /**\n     * Applies provider overrides to a given type (either an NgModule or a standalone component)\n     * and all imported NgModules and standalone components recursively.\n     */\n    applyProviderOverridesInScope(type) {\n        const hasScope = isStandaloneComponent(type) || isNgModule(type);\n        // The function can be re-entered recursively while inspecting dependencies\n        // of an NgModule or a standalone component. Exit early if we come across a\n        // type that can not have a scope (directive or pipe) or the type is already\n        // processed earlier.\n        if (!hasScope || this.scopesWithOverriddenProviders.has(type)) {\n            return;\n        }\n        this.scopesWithOverriddenProviders.add(type);\n        // NOTE: the line below triggers JIT compilation of the module injector,\n        // which also invokes verification of the NgModule semantics, which produces\n        // detailed error messages. The fact that the code relies on this line being\n        // present here is suspicious and should be refactored in a way that the line\n        // below can be moved (for ex. after an early exit check below).\n        const injectorDef = type[\u0275NG_INJ_DEF];\n        // No provider overrides, exit early.\n        if (this.providerOverridesByToken.size === 0)\n            return;\n        if (isStandaloneComponent(type)) {\n            // Visit all component dependencies and override providers there.\n            const def = getComponentDef(type);\n            const dependencies = maybeUnwrapFn(def.dependencies ?? []);\n            for (const dependency of dependencies) {\n                this.applyProviderOverridesInScope(dependency);\n            }\n        }\n        else {\n            const providers = [\n                ...injectorDef.providers,\n                ...(this.providerOverridesByModule.get(type) || []),\n            ];\n            if (this.hasProviderOverrides(providers)) {\n                this.maybeStoreNgDef(\u0275NG_INJ_DEF, type);\n                this.storeFieldOfDefOnType(type, \u0275NG_INJ_DEF, 'providers');\n                injectorDef.providers = this.getOverriddenProviders(providers);\n            }\n            // Apply provider overrides to imported modules recursively\n            const moduleDef = type[\u0275NG_MOD_DEF];\n            const imports = maybeUnwrapFn(moduleDef.imports);\n            for (const importedModule of imports) {\n                this.applyProviderOverridesInScope(importedModule);\n            }\n            // Also override the providers on any ModuleWithProviders imports since those don't appear in\n            // the moduleDef.\n            for (const importedModule of flatten(injectorDef.imports)) {\n                if (isModuleWithProviders(importedModule)) {\n                    this.defCleanupOps.push({\n                        object: importedModule,\n                        fieldName: 'providers',\n                        originalValue: importedModule.providers,\n                    });\n                    importedModule.providers = this.getOverriddenProviders(importedModule.providers);\n                }\n            }\n        }\n    }\n    patchComponentsWithExistingStyles() {\n        this.existingComponentStyles.forEach((styles, type) => (type[\u0275NG_COMP_DEF].styles = styles));\n        this.existingComponentStyles.clear();\n    }\n    queueTypeArray(arr, moduleType) {\n        for (const value of arr) {\n            if (Array.isArray(value)) {\n                this.queueTypeArray(value, moduleType);\n            }\n            else {\n                this.queueType(value, moduleType);\n            }\n        }\n    }\n    recompileNgModule(ngModule, metadata) {\n        // Cache the initial ngModuleDef as it will be overwritten.\n        this.maybeStoreNgDef(\u0275NG_MOD_DEF, ngModule);\n        this.maybeStoreNgDef(\u0275NG_INJ_DEF, ngModule);\n        \u0275compileNgModuleDefs(ngModule, metadata);\n    }\n    maybeRegisterComponentWithAsyncMetadata(type) {\n        const asyncMetadataFn = \u0275getAsyncClassMetadataFn(type);\n        if (asyncMetadataFn) {\n            this.componentsWithAsyncMetadata.add(type);\n        }\n    }\n    queueType(type, moduleType) {\n        // If this is a component with async metadata (i.e. a component with a `@defer` block\n        // in a template) - store it for future processing.\n        this.maybeRegisterComponentWithAsyncMetadata(type);\n        const component = this.resolvers.component.resolve(type);\n        if (component) {\n            // Check whether a give Type has respective NG def (\u0275cmp) and compile if def is\n            // missing. That might happen in case a class without any Angular decorators extends another\n            // class where Component/Directive/Pipe decorator is defined.\n            if (\u0275isComponentDefPendingResolution(type) || !type.hasOwnProperty(\u0275NG_COMP_DEF)) {\n                this.pendingComponents.add(type);\n            }\n            this.seenComponents.add(type);\n            // Keep track of the module which declares this component, so later the component's scope\n            // can be set correctly. If the component has already been recorded here, then one of several\n            // cases is true:\n            // * the module containing the component was imported multiple times (common).\n            // * the component is declared in multiple modules (which is an error).\n            // * the component was in 'declarations' of the testing module, and also in an imported module\n            //   in which case the module scope will be TestingModuleOverride.DECLARATION.\n            // * overrideTemplateUsingTestingModule was called for the component in which case the module\n            //   scope will be TestingModuleOverride.OVERRIDE_TEMPLATE.\n            //\n            // If the component was previously in the testing module's 'declarations' (meaning the\n            // current value is TestingModuleOverride.DECLARATION), then `moduleType` is the component's\n            // real module, which was imported. This pattern is understood to mean that the component\n            // should use its original scope, but that the testing module should also contain the\n            // component in its scope.\n            if (!this.componentToModuleScope.has(type) ||\n                this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION) {\n                this.componentToModuleScope.set(type, moduleType);\n            }\n            return;\n        }\n        const directive = this.resolvers.directive.resolve(type);\n        if (directive) {\n            if (!type.hasOwnProperty(\u0275NG_DIR_DEF)) {\n                this.pendingDirectives.add(type);\n            }\n            this.seenDirectives.add(type);\n            return;\n        }\n        const pipe = this.resolvers.pipe.resolve(type);\n        if (pipe && !type.hasOwnProperty(\u0275NG_PIPE_DEF)) {\n            this.pendingPipes.add(type);\n            return;\n        }\n    }\n    queueTypesFromModulesArray(arr) {\n        // Because we may encounter the same NgModule or a standalone Component while processing\n        // the dependencies of an NgModule or a standalone Component, we cache them in this set so we\n        // can skip ones that have already been seen encountered. In some test setups, this caching\n        // resulted in 10X runtime improvement.\n        const processedDefs = new Set();\n        const queueTypesFromModulesArrayRecur = (arr) => {\n            for (const value of arr) {\n                if (Array.isArray(value)) {\n                    queueTypesFromModulesArrayRecur(value);\n                }\n                else if (hasNgModuleDef(value)) {\n                    const def = value.\u0275mod;\n                    if (processedDefs.has(def)) {\n                        continue;\n                    }\n                    processedDefs.add(def);\n                    // Look through declarations, imports, and exports, and queue\n                    // everything found there.\n                    this.queueTypeArray(maybeUnwrapFn(def.declarations), value);\n                    queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports));\n                    queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports));\n                }\n                else if (isModuleWithProviders(value)) {\n                    queueTypesFromModulesArrayRecur([value.ngModule]);\n                }\n                else if (isStandaloneComponent(value)) {\n                    this.queueType(value, null);\n                    const def = getComponentDef(value);\n                    if (processedDefs.has(def)) {\n                        continue;\n                    }\n                    processedDefs.add(def);\n                    const dependencies = maybeUnwrapFn(def.dependencies ?? []);\n                    dependencies.forEach((dependency) => {\n                        // Note: in AOT, the `dependencies` might also contain regular\n                        // (NgModule-based) Component, Directive and Pipes, so we handle\n                        // them separately and proceed with recursive process for standalone\n                        // Components and NgModules only.\n                        if (isStandaloneComponent(dependency) || hasNgModuleDef(dependency)) {\n                            queueTypesFromModulesArrayRecur([dependency]);\n                        }\n                        else {\n                            this.queueType(dependency, null);\n                        }\n                    });\n                }\n            }\n        };\n        queueTypesFromModulesArrayRecur(arr);\n    }\n    // When module overrides (via `TestBed.overrideModule`) are present, it might affect all modules\n    // that import (even transitively) an overridden one. For all affected modules we need to\n    // recalculate their scopes for a given test run and restore original scopes at the end. The goal\n    // of this function is to collect all affected modules in a set for further processing. Example:\n    // if we have the following module hierarchy: A -> B -> C (where `->` means `imports`) and module\n    // `C` is overridden, we consider `A` and `B` as affected, since their scopes might become\n    // invalidated with the override.\n    collectModulesAffectedByOverrides(arr) {\n        const seenModules = new Set();\n        const affectedModules = new Set();\n        const calcAffectedModulesRecur = (arr, path) => {\n            for (const value of arr) {\n                if (Array.isArray(value)) {\n                    // If the value is an array, just flatten it (by invoking this function recursively),\n                    // keeping \"path\" the same.\n                    calcAffectedModulesRecur(value, path);\n                }\n                else if (hasNgModuleDef(value)) {\n                    if (seenModules.has(value)) {\n                        // If we've seen this module before and it's included into \"affected modules\" list, mark\n                        // the whole path that leads to that module as affected, but do not descend into its\n                        // imports, since we already examined them before.\n                        if (affectedModules.has(value)) {\n                            path.forEach((item) => affectedModules.add(item));\n                        }\n                        continue;\n                    }\n                    seenModules.add(value);\n                    if (this.overriddenModules.has(value)) {\n                        path.forEach((item) => affectedModules.add(item));\n                    }\n                    // Examine module imports recursively to look for overridden modules.\n                    const moduleDef = value[\u0275NG_MOD_DEF];\n                    calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports), path.concat(value));\n                }\n            }\n        };\n        calcAffectedModulesRecur(arr, []);\n        return affectedModules;\n    }\n    /**\n     * Preserve an original def (such as \u0275mod, \u0275inj, etc) before applying an override.\n     * Note: one class may have multiple defs (for example: \u0275mod and \u0275inj in case of\n     * an NgModule). If there is a def in a set already, don't override it, since\n     * an original one should be restored at the end of a test.\n     */\n    maybeStoreNgDef(prop, type) {\n        if (!this.initialNgDefs.has(type)) {\n            this.initialNgDefs.set(type, new Map());\n        }\n        const currentDefs = this.initialNgDefs.get(type);\n        if (!currentDefs.has(prop)) {\n            const currentDef = Object.getOwnPropertyDescriptor(type, prop);\n            currentDefs.set(prop, currentDef);\n        }\n    }\n    storeFieldOfDefOnType(type, defField, fieldName) {\n        const def = type[defField];\n        const originalValue = def[fieldName];\n        this.defCleanupOps.push({ object: def, fieldName, originalValue });\n    }\n    /**\n     * Clears current components resolution queue, but stores the state of the queue, so we can\n     * restore it later. Clearing the queue is required before we try to compile components (via\n     * `TestBed.compileComponents`), so that component defs are in sync with the resolution queue.\n     */\n    clearComponentResolutionQueue() {\n        if (this.originalComponentResolutionQueue === null) {\n            this.originalComponentResolutionQueue = new Map();\n        }\n        \u0275clearResolutionOfComponentResourcesQueue().forEach((value, key) => this.originalComponentResolutionQueue.set(key, value));\n    }\n    /*\n     * Restores component resolution queue to the previously saved state. This operation is performed\n     * as a part of restoring the state after completion of the current set of tests (that might\n     * potentially mutate the state).\n     */\n    restoreComponentResolutionQueue() {\n        if (this.originalComponentResolutionQueue !== null) {\n            \u0275restoreComponentResolutionQueue(this.originalComponentResolutionQueue);\n            this.originalComponentResolutionQueue = null;\n        }\n    }\n    restoreOriginalState() {\n        // Process cleanup ops in reverse order so the field's original value is restored correctly (in\n        // case there were multiple overrides for the same field).\n        forEachRight(this.defCleanupOps, (op) => {\n            op.object[op.fieldName] = op.originalValue;\n        });\n        // Restore initial component/directive/pipe defs\n        this.initialNgDefs.forEach((defs, type) => {\n            if (\u0275USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {\n                \u0275depsTracker.clearScopeCacheFor(type);\n            }\n            defs.forEach((descriptor, prop) => {\n                if (!descriptor) {\n                    // Delete operations are generally undesirable since they have performance\n                    // implications on objects they were applied to. In this particular case, situations\n                    // where this code is invoked should be quite rare to cause any noticeable impact,\n                    // since it's applied only to some test cases (for example when class with no\n                    // annotations extends some @Component) when we need to clear '\u0275cmp' field on a given\n                    // class to restore its original state (before applying overrides and running tests).\n                    delete type[prop];\n                }\n                else {\n                    Object.defineProperty(type, prop, descriptor);\n                }\n            });\n        });\n        this.initialNgDefs.clear();\n        this.scopesWithOverriddenProviders.clear();\n        this.restoreComponentResolutionQueue();\n        // Restore the locale ID to the default value, this shouldn't be necessary but we never know\n        \u0275setLocaleId(\u0275DEFAULT_LOCALE_ID);\n    }\n    compileTestModule() {\n        class RootScopeModule {\n        }\n        \u0275compileNgModuleDefs(RootScopeModule, {\n            providers: [\n                ...this.rootProviderOverrides,\n                \u0275internalProvideZoneChangeDetection({}),\n                TestBedApplicationErrorHandler,\n                {\n                    provide: \u0275INTERNAL_APPLICATION_ERROR_HANDLER,\n                    useFactory: () => {\n                        if (inject$1(\u0275ZONELESS_ENABLED) || inject$1(RETHROW_APPLICATION_ERRORS, { optional: true })) {\n                            const handler = inject$1(TestBedApplicationErrorHandler);\n                            return (e) => {\n                                handler.handleError(e);\n                            };\n                        }\n                        else {\n                            const userErrorHandler = inject$1(ErrorHandler);\n                            const ngZone = inject$1(NgZone);\n                            return (e) => ngZone.runOutsideAngular(() => userErrorHandler.handleError(e));\n                        }\n                    },\n                },\n                { provide: \u0275ChangeDetectionScheduler, useExisting: \u0275ChangeDetectionSchedulerImpl },\n            ],\n        });\n        const providers = [\n            { provide: Compiler, useFactory: () => new R3TestCompiler(this) },\n            { provide: \u0275DEFER_BLOCK_CONFIG, useValue: { behavior: this.deferBlockBehavior } },\n            ...this.providers,\n            ...this.providerOverrides,\n        ];\n        const imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []];\n        \u0275compileNgModuleDefs(this.testModuleType, {\n            declarations: this.declarations,\n            imports,\n            schemas: this.schemas,\n            providers,\n        }, \n        /* allowDuplicateDeclarationsInRoot */ true);\n        this.applyProviderOverridesInScope(this.testModuleType);\n    }\n    get injector() {\n        if (this._injector !== null) {\n            return this._injector;\n        }\n        const providers = [];\n        const compilerOptions = this.platform.injector.get(COMPILER_OPTIONS);\n        compilerOptions.forEach((opts) => {\n            if (opts.providers) {\n                providers.push(opts.providers);\n            }\n        });\n        if (this.compilerProviders !== null) {\n            providers.push(...this.compilerProviders);\n        }\n        this._injector = Injector.create({ providers, parent: this.platform.injector });\n        return this._injector;\n    }\n    // get overrides for a specific provider (if any)\n    getSingleProviderOverrides(provider) {\n        const token = getProviderToken(provider);\n        return this.providerOverridesByToken.get(token) || null;\n    }\n    getProviderOverrides(providers) {\n        if (!providers || !providers.length || this.providerOverridesByToken.size === 0)\n            return [];\n        // There are two flattening operations here. The inner flattenProviders() operates on the\n        // metadata's providers and applies a mapping function which retrieves overrides for each\n        // incoming provider. The outer flatten() then flattens the produced overrides array. If this is\n        // not done, the array can contain other empty arrays (e.g. `[[], []]`) which leak into the\n        // providers array and contaminate any error messages that might be generated.\n        return flatten(flattenProviders(providers, (provider) => this.getSingleProviderOverrides(provider) || []));\n    }\n    getOverriddenProviders(providers) {\n        if (!providers || !providers.length || this.providerOverridesByToken.size === 0)\n            return [];\n        const flattenedProviders = flattenProviders(providers);\n        const overrides = this.getProviderOverrides(flattenedProviders);\n        const overriddenProviders = [...flattenedProviders, ...overrides];\n        const final = [];\n        const seenOverriddenProviders = new Set();\n        // We iterate through the list of providers in reverse order to make sure provider overrides\n        // take precedence over the values defined in provider list. We also filter out all providers\n        // that have overrides, keeping overridden values only. This is needed, since presence of a\n        // provider with `ngOnDestroy` hook will cause this hook to be registered and invoked later.\n        forEachRight(overriddenProviders, (provider) => {\n            const token = getProviderToken(provider);\n            if (this.providerOverridesByToken.has(token)) {\n                if (!seenOverriddenProviders.has(token)) {\n                    seenOverriddenProviders.add(token);\n                    // Treat all overridden providers as `{multi: false}` (even if it's a multi-provider) to\n                    // make sure that provided override takes highest precedence and is not combined with\n                    // other instances of the same multi provider.\n                    final.unshift({ ...provider, multi: false });\n                }\n            }\n            else {\n                final.unshift(provider);\n            }\n        });\n        return final;\n    }\n    hasProviderOverrides(providers) {\n        return this.getProviderOverrides(providers).length > 0;\n    }\n    patchDefWithProviderOverrides(declaration, field) {\n        const def = declaration[field];\n        if (def && def.providersResolver) {\n            this.maybeStoreNgDef(field, declaration);\n            const resolver = def.providersResolver;\n            const processProvidersFn = (providers) => this.getOverriddenProviders(providers);\n            this.storeFieldOfDefOnType(declaration, field, 'providersResolver');\n            def.providersResolver = (ngDef) => resolver(ngDef, processProvidersFn);\n        }\n    }\n}\nfunction initResolvers() {\n    return {\n        module: new NgModuleResolver(),\n        component: new ComponentResolver(),\n        directive: new DirectiveResolver(),\n        pipe: new PipeResolver(),\n    };\n}\nfunction isStandaloneComponent(value) {\n    const def = getComponentDef(value);\n    return !!def?.standalone;\n}\nfunction getComponentDef(value) {\n    return value.\u0275cmp ?? null;\n}\nfunction hasNgModuleDef(value) {\n    return value.hasOwnProperty('\u0275mod');\n}\nfunction isNgModule(value) {\n    return hasNgModuleDef(value);\n}\nfunction maybeUnwrapFn(maybeFn) {\n    return maybeFn instanceof Function ? maybeFn() : maybeFn;\n}\nfunction flatten(values) {\n    const out = [];\n    values.forEach((value) => {\n        if (Array.isArray(value)) {\n            out.push(...flatten(value));\n        }\n        else {\n            out.push(value);\n        }\n    });\n    return out;\n}\nfunction identityFn(value) {\n    return value;\n}\nfunction flattenProviders(providers, mapFn = identityFn) {\n    const out = [];\n    for (let provider of providers) {\n        if (\u0275isEnvironmentProviders(provider)) {\n            provider = provider.\u0275providers;\n        }\n        if (Array.isArray(provider)) {\n            out.push(...flattenProviders(provider, mapFn));\n        }\n        else {\n            out.push(mapFn(provider));\n        }\n    }\n    return out;\n}\nfunction getProviderField(provider, field) {\n    return provider && typeof provider === 'object' && provider[field];\n}\nfunction getProviderToken(provider) {\n    return getProviderField(provider, 'provide') || provider;\n}\nfunction isModuleWithProviders(value) {\n    return value.hasOwnProperty('ngModule');\n}\nfunction forEachRight(values, fn) {\n    for (let idx = values.length - 1; idx >= 0; idx--) {\n        fn(values[idx], idx);\n    }\n}\nfunction invalidTypeError(name, expectedType) {\n    return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`);\n}\nclass R3TestCompiler {\n    constructor(testBed) {\n        this.testBed = testBed;\n    }\n    compileModuleSync(moduleType) {\n        this.testBed._compileNgModuleSync(moduleType);\n        return new \u0275NgModuleFactory(moduleType);\n    }\n    async compileModuleAsync(moduleType) {\n        await this.testBed._compileNgModuleAsync(moduleType);\n        return new \u0275NgModuleFactory(moduleType);\n    }\n    compileModuleAndAllComponentsSync(moduleType) {\n        const ngModuleFactory = this.compileModuleSync(moduleType);\n        const componentFactories = this.testBed._getComponentFactories(moduleType);\n        return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n    }\n    async compileModuleAndAllComponentsAsync(moduleType) {\n        const ngModuleFactory = await this.compileModuleAsync(moduleType);\n        const componentFactories = this.testBed._getComponentFactories(moduleType);\n        return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n    }\n    clearCache() { }\n    clearCacheFor(type) { }\n    getModuleId(moduleType) {\n        const meta = this.testBed._getModuleResolver().resolve(moduleType);\n        return (meta && meta.id) || undefined;\n    }\n}\n\n// The formatter and CI disagree on how this import statement should be formatted. Both try to keep\nlet _nextRootElementId = 0;\n/**\n * Returns a singleton of the `TestBed` class.\n *\n * @publicApi\n */\nfunction getTestBed() {\n    return TestBedImpl.INSTANCE;\n}\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\n */\nclass TestBedImpl {\n    constructor() {\n        /**\n         * Defer block behavior option that specifies whether defer blocks will be triggered manually\n         * or set to play through.\n         */\n        this._instanceDeferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n        // Properties\n        this.platform = null;\n        this.ngModule = null;\n        this._compiler = null;\n        this._testModuleRef = null;\n        this._activeFixtures = [];\n        /**\n         * Internal-only flag to indicate whether a module\n         * scoping queue has been checked and flushed already.\n         * @nodoc\n         */\n        this.globalCompilationChecked = false;\n    }\n    static { this._INSTANCE = null; }\n    static get INSTANCE() {\n        return (TestBedImpl._INSTANCE = TestBedImpl._INSTANCE || new TestBedImpl());\n    }\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @publicApi\n     */\n    static initTestEnvironment(ngModule, platform, options) {\n        const testBed = TestBedImpl.INSTANCE;\n        testBed.initTestEnvironment(ngModule, platform, options);\n        return testBed;\n    }\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n    static resetTestEnvironment() {\n        TestBedImpl.INSTANCE.resetTestEnvironment();\n    }\n    static configureCompiler(config) {\n        return TestBedImpl.INSTANCE.configureCompiler(config);\n    }\n    /**\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\n     * which are defined in test_injector.js\n     */\n    static configureTestingModule(moduleDef) {\n        return TestBedImpl.INSTANCE.configureTestingModule(moduleDef);\n    }\n    /**\n     * Compile components with a `templateUrl` for the test's NgModule.\n     * It is necessary to call this function\n     * as fetching urls is asynchronous.\n     */\n    static compileComponents() {\n        return TestBedImpl.INSTANCE.compileComponents();\n    }\n    static overrideModule(ngModule, override) {\n        return TestBedImpl.INSTANCE.overrideModule(ngModule, override);\n    }\n    static overrideComponent(component, override) {\n        return TestBedImpl.INSTANCE.overrideComponent(component, override);\n    }\n    static overrideDirective(directive, override) {\n        return TestBedImpl.INSTANCE.overrideDirective(directive, override);\n    }\n    static overridePipe(pipe, override) {\n        return TestBedImpl.INSTANCE.overridePipe(pipe, override);\n    }\n    static overrideTemplate(component, template) {\n        return TestBedImpl.INSTANCE.overrideTemplate(component, template);\n    }\n    /**\n     * Overrides the template of the given component, compiling the template\n     * in the context of the TestingModule.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n    static overrideTemplateUsingTestingModule(component, template) {\n        return TestBedImpl.INSTANCE.overrideTemplateUsingTestingModule(component, template);\n    }\n    static overrideProvider(token, provider) {\n        return TestBedImpl.INSTANCE.overrideProvider(token, provider);\n    }\n    static inject(token, notFoundValue, flags) {\n        return TestBedImpl.INSTANCE.inject(token, notFoundValue, \u0275convertToBitFlags(flags));\n    }\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    static get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n        return TestBedImpl.INSTANCE.inject(token, notFoundValue, flags);\n    }\n    /**\n     * Runs the given function in the `EnvironmentInjector` context of `TestBed`.\n     *\n     * @see {@link EnvironmentInjector#runInContext}\n     */\n    static runInInjectionContext(fn) {\n        return TestBedImpl.INSTANCE.runInInjectionContext(fn);\n    }\n    static createComponent(component) {\n        return TestBedImpl.INSTANCE.createComponent(component);\n    }\n    static resetTestingModule() {\n        return TestBedImpl.INSTANCE.resetTestingModule();\n    }\n    static execute(tokens, fn, context) {\n        return TestBedImpl.INSTANCE.execute(tokens, fn, context);\n    }\n    static get platform() {\n        return TestBedImpl.INSTANCE.platform;\n    }\n    static get ngModule() {\n        return TestBedImpl.INSTANCE.ngModule;\n    }\n    static flushEffects() {\n        return TestBedImpl.INSTANCE.flushEffects();\n    }\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @publicApi\n     */\n    initTestEnvironment(ngModule, platform, options) {\n        if (this.platform || this.ngModule) {\n            throw new Error('Cannot set base providers because it has already been called');\n        }\n        TestBedImpl._environmentTeardownOptions = options?.teardown;\n        TestBedImpl._environmentErrorOnUnknownElementsOption = options?.errorOnUnknownElements;\n        TestBedImpl._environmentErrorOnUnknownPropertiesOption = options?.errorOnUnknownProperties;\n        this.platform = platform;\n        this.ngModule = ngModule;\n        this._compiler = new TestBedCompiler(this.platform, this.ngModule);\n        // TestBed does not have an API which can reliably detect the start of a test, and thus could be\n        // used to track the state of the NgModule registry and reset it correctly. Instead, when we\n        // know we're in a testing scenario, we disable the check for duplicate NgModule registration\n        // completely.\n        \u0275setAllowDuplicateNgModuleIdsForTest(true);\n    }\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n    resetTestEnvironment() {\n        this.resetTestingModule();\n        this._compiler = null;\n        this.platform = null;\n        this.ngModule = null;\n        TestBedImpl._environmentTeardownOptions = undefined;\n        \u0275setAllowDuplicateNgModuleIdsForTest(false);\n    }\n    resetTestingModule() {\n        this.checkGlobalCompilationFinished();\n        \u0275resetCompiledComponents();\n        if (this._compiler !== null) {\n            this.compiler.restoreOriginalState();\n        }\n        this._compiler = new TestBedCompiler(this.platform, this.ngModule);\n        // Restore the previous value of the \"error on unknown elements\" option\n        \u0275setUnknownElementStrictMode(this._previousErrorOnUnknownElementsOption ?? THROW_ON_UNKNOWN_ELEMENTS_DEFAULT);\n        // Restore the previous value of the \"error on unknown properties\" option\n        \u0275setUnknownPropertyStrictMode(this._previousErrorOnUnknownPropertiesOption ?? THROW_ON_UNKNOWN_PROPERTIES_DEFAULT);\n        // We have to chain a couple of try/finally blocks, because each step can\n        // throw errors and we don't want it to interrupt the next step and we also\n        // want an error to be thrown at the end.\n        try {\n            this.destroyActiveFixtures();\n        }\n        finally {\n            try {\n                if (this.shouldTearDownTestingModule()) {\n                    this.tearDownTestingModule();\n                }\n            }\n            finally {\n                this._testModuleRef = null;\n                this._instanceTeardownOptions = undefined;\n                this._instanceErrorOnUnknownElementsOption = undefined;\n                this._instanceErrorOnUnknownPropertiesOption = undefined;\n                this._instanceDeferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n            }\n        }\n        return this;\n    }\n    configureCompiler(config) {\n        if (config.useJit != null) {\n            throw new Error('JIT compiler is not configurable via TestBed APIs.');\n        }\n        if (config.providers !== undefined) {\n            this.compiler.setCompilerProviders(config.providers);\n        }\n        return this;\n    }\n    configureTestingModule(moduleDef) {\n        this.assertNotInstantiated('TestBed.configureTestingModule', 'configure the test module');\n        // Trigger module scoping queue flush before executing other TestBed operations in a test.\n        // This is needed for the first test invocation to ensure that globally declared modules have\n        // their components scoped properly. See the `checkGlobalCompilationFinished` function\n        // description for additional info.\n        this.checkGlobalCompilationFinished();\n        // Always re-assign the options, even if they're undefined.\n        // This ensures that we don't carry them between tests.\n        this._instanceTeardownOptions = moduleDef.teardown;\n        this._instanceErrorOnUnknownElementsOption = moduleDef.errorOnUnknownElements;\n        this._instanceErrorOnUnknownPropertiesOption = moduleDef.errorOnUnknownProperties;\n        this._instanceDeferBlockBehavior = moduleDef.deferBlockBehavior ?? DEFER_BLOCK_DEFAULT_BEHAVIOR;\n        // Store the current value of the strict mode option,\n        // so we can restore it later\n        this._previousErrorOnUnknownElementsOption = \u0275getUnknownElementStrictMode();\n        \u0275setUnknownElementStrictMode(this.shouldThrowErrorOnUnknownElements());\n        this._previousErrorOnUnknownPropertiesOption = \u0275getUnknownPropertyStrictMode();\n        \u0275setUnknownPropertyStrictMode(this.shouldThrowErrorOnUnknownProperties());\n        this.compiler.configureTestingModule(moduleDef);\n        return this;\n    }\n    compileComponents() {\n        return this.compiler.compileComponents();\n    }\n    inject(token, notFoundValue, flags) {\n        if (token === TestBed) {\n            return this;\n        }\n        const UNDEFINED = {};\n        const result = this.testModuleRef.injector.get(token, UNDEFINED, \u0275convertToBitFlags(flags));\n        return result === UNDEFINED\n            ? this.compiler.injector.get(token, notFoundValue, flags)\n            : result;\n    }\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n        return this.inject(token, notFoundValue, flags);\n    }\n    runInInjectionContext(fn) {\n        return runInInjectionContext(this.inject(EnvironmentInjector), fn);\n    }\n    execute(tokens, fn, context) {\n        const params = tokens.map((t) => this.inject(t));\n        return fn.apply(context, params);\n    }\n    overrideModule(ngModule, override) {\n        this.assertNotInstantiated('overrideModule', 'override module metadata');\n        this.compiler.overrideModule(ngModule, override);\n        return this;\n    }\n    overrideComponent(component, override) {\n        this.assertNotInstantiated('overrideComponent', 'override component metadata');\n        this.compiler.overrideComponent(component, override);\n        return this;\n    }\n    overrideTemplateUsingTestingModule(component, template) {\n        this.assertNotInstantiated('TestBed.overrideTemplateUsingTestingModule', 'Cannot override template when the test module has already been instantiated');\n        this.compiler.overrideTemplateUsingTestingModule(component, template);\n        return this;\n    }\n    overrideDirective(directive, override) {\n        this.assertNotInstantiated('overrideDirective', 'override directive metadata');\n        this.compiler.overrideDirective(directive, override);\n        return this;\n    }\n    overridePipe(pipe, override) {\n        this.assertNotInstantiated('overridePipe', 'override pipe metadata');\n        this.compiler.overridePipe(pipe, override);\n        return this;\n    }\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     */\n    overrideProvider(token, provider) {\n        this.assertNotInstantiated('overrideProvider', 'override provider');\n        this.compiler.overrideProvider(token, provider);\n        return this;\n    }\n    overrideTemplate(component, template) {\n        return this.overrideComponent(component, { set: { template, templateUrl: null } });\n    }\n    createComponent(type) {\n        const testComponentRenderer = this.inject(TestComponentRenderer);\n        const rootElId = `root${_nextRootElementId++}`;\n        testComponentRenderer.insertRootElement(rootElId);\n        if (\u0275getAsyncClassMetadataFn(type)) {\n            throw new Error(`Component '${type.name}' has unresolved metadata. ` +\n                `Please call \\`await TestBed.compileComponents()\\` before running this test.`);\n        }\n        const componentDef = type.\u0275cmp;\n        if (!componentDef) {\n            throw new Error(`It looks like '${\u0275stringify(type)}' has not been compiled.`);\n        }\n        const componentFactory = new \u0275Render3ComponentFactory(componentDef);\n        const initComponent = () => {\n            const componentRef = componentFactory.create(Injector.NULL, [], `#${rootElId}`, this.testModuleRef);\n            return this.runInInjectionContext(() => {\n                const isZoneless = this.inject(\u0275ZONELESS_ENABLED);\n                const fixture = isZoneless\n                    ? new ScheduledComponentFixture(componentRef)\n                    : new PseudoApplicationComponentFixture(componentRef);\n                fixture.initialize();\n                return fixture;\n            });\n        };\n        const noNgZone = this.inject(ComponentFixtureNoNgZone, false);\n        const ngZone = noNgZone ? null : this.inject(NgZone, null);\n        const fixture = ngZone ? ngZone.run(initComponent) : initComponent();\n        this._activeFixtures.push(fixture);\n        return fixture;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get compiler() {\n        if (this._compiler === null) {\n            throw new Error(`Need to call TestBed.initTestEnvironment() first`);\n        }\n        return this._compiler;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get testModuleRef() {\n        if (this._testModuleRef === null) {\n            this._testModuleRef = this.compiler.finalize();\n        }\n        return this._testModuleRef;\n    }\n    assertNotInstantiated(methodName, methodDescription) {\n        if (this._testModuleRef !== null) {\n            throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. ` +\n                `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`);\n        }\n    }\n    /**\n     * Check whether the module scoping queue should be flushed, and flush it if needed.\n     *\n     * When the TestBed is reset, it clears the JIT module compilation queue, cancelling any\n     * in-progress module compilation. This creates a potential hazard - the very first time the\n     * TestBed is initialized (or if it's reset without being initialized), there may be pending\n     * compilations of modules declared in global scope. These compilations should be finished.\n     *\n     * To ensure that globally declared modules have their components scoped properly, this function\n     * is called whenever TestBed is initialized or reset. The _first_ time that this happens, prior\n     * to any other operations, the scoping queue is flushed.\n     */\n    checkGlobalCompilationFinished() {\n        // Checking _testNgModuleRef is null should not be necessary, but is left in as an additional\n        // guard that compilations queued in tests (after instantiation) are never flushed accidentally.\n        if (!this.globalCompilationChecked && this._testModuleRef === null) {\n            \u0275flushModuleScopingQueueAsMuchAsPossible();\n        }\n        this.globalCompilationChecked = true;\n    }\n    destroyActiveFixtures() {\n        let errorCount = 0;\n        this._activeFixtures.forEach((fixture) => {\n            try {\n                fixture.destroy();\n            }\n            catch (e) {\n                errorCount++;\n                console.error('Error during cleanup of component', {\n                    component: fixture.componentInstance,\n                    stacktrace: e,\n                });\n            }\n        });\n        this._activeFixtures = [];\n        if (errorCount > 0 && this.shouldRethrowTeardownErrors()) {\n            throw Error(`${errorCount} ${errorCount === 1 ? 'component' : 'components'} ` +\n                `threw errors during cleanup`);\n        }\n    }\n    shouldRethrowTeardownErrors() {\n        const instanceOptions = this._instanceTeardownOptions;\n        const environmentOptions = TestBedImpl._environmentTeardownOptions;\n        // If the new teardown behavior hasn't been configured, preserve the old behavior.\n        if (!instanceOptions && !environmentOptions) {\n            return TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n        }\n        // Otherwise use the configured behavior or default to rethrowing.\n        return (instanceOptions?.rethrowErrors ??\n            environmentOptions?.rethrowErrors ??\n            this.shouldTearDownTestingModule());\n    }\n    shouldThrowErrorOnUnknownElements() {\n        // Check if a configuration has been provided to throw when an unknown element is found\n        return (this._instanceErrorOnUnknownElementsOption ??\n            TestBedImpl._environmentErrorOnUnknownElementsOption ??\n            THROW_ON_UNKNOWN_ELEMENTS_DEFAULT);\n    }\n    shouldThrowErrorOnUnknownProperties() {\n        // Check if a configuration has been provided to throw when an unknown property is found\n        return (this._instanceErrorOnUnknownPropertiesOption ??\n            TestBedImpl._environmentErrorOnUnknownPropertiesOption ??\n            THROW_ON_UNKNOWN_PROPERTIES_DEFAULT);\n    }\n    shouldTearDownTestingModule() {\n        return (this._instanceTeardownOptions?.destroyAfterEach ??\n            TestBedImpl._environmentTeardownOptions?.destroyAfterEach ??\n            TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT);\n    }\n    getDeferBlockBehavior() {\n        return this._instanceDeferBlockBehavior;\n    }\n    tearDownTestingModule() {\n        // If the module ref has already been destroyed, we won't be able to get a test renderer.\n        if (this._testModuleRef === null) {\n            return;\n        }\n        // Resolve the renderer ahead of time, because we want to remove the root elements as the very\n        // last step, but the injector will be destroyed as a part of the module ref destruction.\n        const testRenderer = this.inject(TestComponentRenderer);\n        try {\n            this._testModuleRef.destroy();\n        }\n        catch (e) {\n            if (this.shouldRethrowTeardownErrors()) {\n                throw e;\n            }\n            else {\n                console.error('Error during cleanup of a testing module', {\n                    component: this._testModuleRef.instance,\n                    stacktrace: e,\n                });\n            }\n        }\n        finally {\n            testRenderer.removeAllRootElements?.();\n        }\n    }\n    /**\n     * Execute any pending effects.\n     *\n     * @developerPreview\n     */\n    flushEffects() {\n        this.inject(\u0275EffectScheduler).flush();\n    }\n}\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * @publicApi\n */\nconst TestBed = TestBedImpl;\n/**\n * Allows injecting dependencies in `beforeEach()` and `it()`. Note: this function\n * (imported from the `@angular/core/testing` package) can **only** be used to inject dependencies\n * in tests. To inject dependencies in your application code, use the [`inject`](api/core/inject)\n * function from the `@angular/core` package instead.\n *\n * Example:\n *\n * ```\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\n *   // some code that uses `dep` and `object`\n *   // ...\n * }));\n *\n * it('...', inject([AClass], (object) => {\n *   object.doSomething();\n *   expect(...);\n * })\n * ```\n *\n * @publicApi\n */\nfunction inject(tokens, fn) {\n    const testBed = TestBedImpl.INSTANCE;\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n        return testBed.execute(tokens, fn, this);\n    };\n}\n/**\n * @publicApi\n */\nclass InjectSetupWrapper {\n    constructor(_moduleDef) {\n        this._moduleDef = _moduleDef;\n    }\n    _addModule() {\n        const moduleDef = this._moduleDef();\n        if (moduleDef) {\n            TestBedImpl.configureTestingModule(moduleDef);\n        }\n    }\n    inject(tokens, fn) {\n        const self = this;\n        // Not using an arrow function to preserve context passed from call site\n        return function () {\n            self._addModule();\n            return inject(tokens, fn).call(this);\n        };\n    }\n}\nfunction withModule(moduleDef, fn) {\n    if (fn) {\n        // Not using an arrow function to preserve context passed from call site\n        return function () {\n            const testBed = TestBedImpl.INSTANCE;\n            if (moduleDef) {\n                testBed.configureTestingModule(moduleDef);\n            }\n            return fn.apply(this);\n        };\n    }\n    return new InjectSetupWrapper(() => moduleDef);\n}\n\n/**\n * Public Test Library for unit testing Angular applications. Assumes that you are running\n * with Jasmine, Mocha, or a similar framework which exports a beforeEach function and\n * allows tests to be asynchronous by either returning a promise or using a 'done' parameter.\n */\n// Reset the test providers and the fake async zone before each test.\n// We keep a guard because somehow this file can make it into a bundle and be executed\n// beforeEach is only defined when executing the tests\nglobalThis.beforeEach?.(getCleanupHook(false));\n// We provide both a `beforeEach` and `afterEach`, because the updated behavior for\n// tearing down the module is supposed to run after the test so that we can associate\n// teardown errors with the correct test.\n// We keep a guard because somehow this file can make it into a bundle and be executed\n// afterEach is only defined when executing the tests\nglobalThis.afterEach?.(getCleanupHook(true));\nfunction getCleanupHook(expectedTeardownValue) {\n    return () => {\n        const testBed = TestBedImpl.INSTANCE;\n        if (testBed.shouldTearDownTestingModule() === expectedTeardownValue) {\n            testBed.resetTestingModule();\n            resetFakeAsyncZoneIfExists();\n        }\n    };\n}\n/**\n * This API should be removed. But doing so seems to break `google3` and so it requires a bit of\n * investigation.\n *\n * A work around is to mark it as `@codeGenApi` for now and investigate later.\n *\n * @codeGenApi\n */\n// TODO(iminar): Remove this code in a safe way.\nconst __core_private_testing_placeholder__ = '';\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the core/testing package.\n */\n\n/// <reference types=\"jasmine\" />\n// This file only reexports content of the `src` folder. Keep it that way.\n\n// This file is not used to build this module. It is only used during editing\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ComponentFixture, ComponentFixtureAutoDetect, ComponentFixtureNoNgZone, DeferBlockFixture, InjectSetupWrapper, TestBed, TestComponentRenderer, __core_private_testing_placeholder__, discardPeriodicTasks, fakeAsync, flush, flushMicrotasks, getTestBed, inject, resetFakeAsyncZone, tick, waitForAsync, withModule, MetadataOverrider as \u0275MetadataOverrider };\n//# sourceMappingURL=testing.mjs.map\n"],
  "mappings": "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",
  "names": ["import_core", "_Zone", "inject$1", "_a", "_b", "TestingModuleOverride", "arr", "fixture"]
}
