2cc6c2252c5b031431bac6f25eb1ce9f
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var testing_exports = {};
__export(testing_exports, {
  ComponentHarness: () => ComponentHarness,
  ContentContainerComponentHarness: () => ContentContainerComponentHarness,
  HarnessEnvironment: () => HarnessEnvironment,
  HarnessPredicate: () => HarnessPredicate,
  TestKey: () => TestKey,
  _getTextWithExcludedElements: () => _getTextWithExcludedElements,
  getNoKeysSpecifiedError: () => getNoKeysSpecifiedError,
  handleAutoChangeDetectionStatus: () => handleAutoChangeDetectionStatus,
  manualChangeDetection: () => manualChangeDetection,
  parallel: () => parallel,
  stopHandlingAutoChangeDetectionStatus: () => stopHandlingAutoChangeDetectionStatus
});
module.exports = __toCommonJS(testing_exports);
var import_rxjs = require("rxjs");
const autoChangeDetectionSubject = new import_rxjs.BehaviorSubject({
  isDisabled: false
});
let autoChangeDetectionSubscription;
function defaultAutoChangeDetectionHandler(status) {
  var _a;
  (_a = status.onDetectChangesNow) == null ? void 0 : _a.call(status);
}
function handleAutoChangeDetectionStatus(handler) {
  stopHandlingAutoChangeDetectionStatus();
  autoChangeDetectionSubscription = autoChangeDetectionSubject.subscribe(handler);
}
function stopHandlingAutoChangeDetectionStatus() {
  autoChangeDetectionSubscription == null ? void 0 : autoChangeDetectionSubscription.unsubscribe();
  autoChangeDetectionSubscription = null;
}
function batchChangeDetection(fn, triggerBeforeAndAfter) {
  return __async(this, null, function* () {
    if (autoChangeDetectionSubject.getValue().isDisabled) {
      return yield fn();
    }
    if (!autoChangeDetectionSubscription) {
      handleAutoChangeDetectionStatus(defaultAutoChangeDetectionHandler);
    }
    if (triggerBeforeAndAfter) {
      yield new Promise((resolve) => autoChangeDetectionSubject.next({
        isDisabled: true,
        onDetectChangesNow: resolve
      }));
      try {
        return yield fn();
      } finally {
        yield new Promise((resolve) => autoChangeDetectionSubject.next({
          isDisabled: false,
          onDetectChangesNow: resolve
        }));
      }
    } else {
      autoChangeDetectionSubject.next({ isDisabled: true });
      try {
        return yield fn();
      } finally {
        autoChangeDetectionSubject.next({ isDisabled: false });
      }
    }
  });
}
function manualChangeDetection(fn) {
  return __async(this, null, function* () {
    return batchChangeDetection(fn, false);
  });
}
function parallel(values) {
  return __async(this, null, function* () {
    return batchChangeDetection(() => Promise.all(values()), true);
  });
}
class ComponentHarness {
  constructor(locatorFactory) {
    this.locatorFactory = locatorFactory;
  }
  /** Gets a `Promise` for the `TestElement` representing the host element of the component. */
  host() {
    return __async(this, null, function* () {
      return this.locatorFactory.rootElement;
    });
  }
  /**
   * Gets a `LocatorFactory` for the document root element. This factory can be used to create
   * locators for elements that a component creates outside of its own root element. (e.g. by
   * appending to document.body).
   */
  documentRootLocatorFactory() {
    return this.locatorFactory.documentRootLocatorFactory();
  }
  /**
   * Creates an asynchronous locator function that can be used to find a `ComponentHarness` instance
   * or element under the host element of this `ComponentHarness`.
   * @param queries A list of queries specifying which harnesses and elements to search for:
   *   - A `string` searches for elements matching the CSS selector specified by the string.
   *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the
   *     given class.
   *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given
   *     predicate.
   * @return An asynchronous locator function that searches for and returns a `Promise` for the
   *   first element or harness matching the given search criteria. Matches are ordered first by
   *   order in the DOM, and second by order in the queries list. If no matches are found, the
   *   `Promise` rejects. The type that the `Promise` resolves to is a union of all result types for
   *   each query.
   *
   * e.g. Given the following DOM: `<div id="d1" /><div id="d2" />`, and assuming
   * `DivHarness.hostSelector === 'div'`:
   * - `await ch.locatorFor(DivHarness, 'div')()` gets a `DivHarness` instance for `#d1`
   * - `await ch.locatorFor('div', DivHarness)()` gets a `TestElement` instance for `#d1`
   * - `await ch.locatorFor('span')()` throws because the `Promise` rejects.
   */
  locatorFor(...queries) {
    return this.locatorFactory.locatorFor(...queries);
  }
  /**
   * Creates an asynchronous locator function that can be used to find a `ComponentHarness` instance
   * or element under the host element of this `ComponentHarness`.
   * @param queries A list of queries specifying which harnesses and elements to search for:
   *   - A `string` searches for elements matching the CSS selector specified by the string.
   *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the
   *     given class.
   *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given
   *     predicate.
   * @return An asynchronous locator function that searches for and returns a `Promise` for the
   *   first element or harness matching the given search criteria. Matches are ordered first by
   *   order in the DOM, and second by order in the queries list. If no matches are found, the
   *   `Promise` is resolved with `null`. The type that the `Promise` resolves to is a union of all
   *   result types for each query or null.
   *
   * e.g. Given the following DOM: `<div id="d1" /><div id="d2" />`, and assuming
   * `DivHarness.hostSelector === 'div'`:
   * - `await ch.locatorForOptional(DivHarness, 'div')()` gets a `DivHarness` instance for `#d1`
   * - `await ch.locatorForOptional('div', DivHarness)()` gets a `TestElement` instance for `#d1`
   * - `await ch.locatorForOptional('span')()` gets `null`.
   */
  locatorForOptional(...queries) {
    return this.locatorFactory.locatorForOptional(...queries);
  }
  /**
   * Creates an asynchronous locator function that can be used to find `ComponentHarness` instances
   * or elements under the host element of this `ComponentHarness`.
   * @param queries A list of queries specifying which harnesses and elements to search for:
   *   - A `string` searches for elements matching the CSS selector specified by the string.
   *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the
   *     given class.
   *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given
   *     predicate.
   * @return An asynchronous locator function that searches for and returns a `Promise` for all
   *   elements and harnesses matching the given search criteria. Matches are ordered first by
   *   order in the DOM, and second by order in the queries list. If an element matches more than
   *   one `ComponentHarness` class, the locator gets an instance of each for the same element. If
   *   an element matches multiple `string` selectors, only one `TestElement` instance is returned
   *   for that element. The type that the `Promise` resolves to is an array where each element is
   *   the union of all result types for each query.
   *
   * e.g. Given the following DOM: `<div id="d1" /><div id="d2" />`, and assuming
   * `DivHarness.hostSelector === 'div'` and `IdIsD1Harness.hostSelector === '#d1'`:
   * - `await ch.locatorForAll(DivHarness, 'div')()` gets `[
   *     DivHarness, // for #d1
   *     TestElement, // for #d1
   *     DivHarness, // for #d2
   *     TestElement // for #d2
   *   ]`
   * - `await ch.locatorForAll('div', '#d1')()` gets `[
   *     TestElement, // for #d1
   *     TestElement // for #d2
   *   ]`
   * - `await ch.locatorForAll(DivHarness, IdIsD1Harness)()` gets `[
   *     DivHarness, // for #d1
   *     IdIsD1Harness, // for #d1
   *     DivHarness // for #d2
   *   ]`
   * - `await ch.locatorForAll('span')()` gets `[]`.
   */
  locatorForAll(...queries) {
    return this.locatorFactory.locatorForAll(...queries);
  }
  /**
   * Flushes change detection and async tasks in the Angular zone.
   * In most cases it should not be necessary to call this manually. However, there may be some edge
   * cases where it is needed to fully flush animation events.
   */
  forceStabilize() {
    return __async(this, null, function* () {
      return this.locatorFactory.forceStabilize();
    });
  }
  /**
   * Waits for all scheduled or running async tasks to complete. This allows harness
   * authors to wait for async tasks outside of the Angular zone.
   */
  waitForTasksOutsideAngular() {
    return __async(this, null, function* () {
      return this.locatorFactory.waitForTasksOutsideAngular();
    });
  }
}
class ContentContainerComponentHarness extends ComponentHarness {
  getChildLoader(selector) {
    return __async(this, null, function* () {
      return (yield this.getRootHarnessLoader()).getChildLoader(selector);
    });
  }
  getAllChildLoaders(selector) {
    return __async(this, null, function* () {
      return (yield this.getRootHarnessLoader()).getAllChildLoaders(selector);
    });
  }
  getHarness(query) {
    return __async(this, null, function* () {
      return (yield this.getRootHarnessLoader()).getHarness(query);
    });
  }
  getHarnessOrNull(query) {
    return __async(this, null, function* () {
      return (yield this.getRootHarnessLoader()).getHarnessOrNull(query);
    });
  }
  getAllHarnesses(query) {
    return __async(this, null, function* () {
      return (yield this.getRootHarnessLoader()).getAllHarnesses(query);
    });
  }
  hasHarness(query) {
    return __async(this, null, function* () {
      return (yield this.getRootHarnessLoader()).hasHarness(query);
    });
  }
  /**
   * Gets the root harness loader from which to start
   * searching for content contained by this harness.
   */
  getRootHarnessLoader() {
    return __async(this, null, function* () {
      return this.locatorFactory.rootHarnessLoader();
    });
  }
}
class HarnessPredicate {
  constructor(harnessType, options) {
    this.harnessType = harnessType;
    this._predicates = [];
    this._descriptions = [];
    this._addBaseOptions(options);
  }
  /**
   * Checks if the specified nullable string value matches the given pattern.
   * @param value The nullable string value to check, or a Promise resolving to the
   *   nullable string value.
   * @param pattern The pattern the value is expected to match. If `pattern` is a string,
   *   `value` is expected to match exactly. If `pattern` is a regex, a partial match is
   *   allowed. If `pattern` is `null`, the value is expected to be `null`.
   * @return Whether the value matches the pattern.
   */
  static stringMatches(value, pattern) {
    return __async(this, null, function* () {
      value = yield value;
      if (pattern === null) {
        return value === null;
      } else if (value === null) {
        return false;
      }
      return typeof pattern === "string" ? value === pattern : pattern.test(value);
    });
  }
  /**
   * Adds a predicate function to be run against candidate harnesses.
   * @param description A description of this predicate that may be used in error messages.
   * @param predicate An async predicate function.
   * @return this (for method chaining).
   */
  add(description, predicate) {
    this._descriptions.push(description);
    this._predicates.push(predicate);
    return this;
  }
  /**
   * Adds a predicate function that depends on an option value to be run against candidate
   * harnesses. If the option value is undefined, the predicate will be ignored.
   * @param name The name of the option (may be used in error messages).
   * @param option The option value.
   * @param predicate The predicate function to run if the option value is not undefined.
   * @return this (for method chaining).
   */
  addOption(name, option, predicate) {
    if (option !== void 0) {
      this.add(`${name} = ${_valueAsString(option)}`, (item) => predicate(item, option));
    }
    return this;
  }
  /**
   * Filters a list of harnesses on this predicate.
   * @param harnesses The list of harnesses to filter.
   * @return A list of harnesses that satisfy this predicate.
   */
  filter(harnesses) {
    return __async(this, null, function* () {
      if (harnesses.length === 0) {
        return [];
      }
      const results = yield parallel(() => harnesses.map((h) => this.evaluate(h)));
      return harnesses.filter((_, i) => results[i]);
    });
  }
  /**
   * Evaluates whether the given harness satisfies this predicate.
   * @param harness The harness to check
   * @return A promise that resolves to true if the harness satisfies this predicate,
   *   and resolves to false otherwise.
   */
  evaluate(harness) {
    return __async(this, null, function* () {
      const results = yield parallel(() => this._predicates.map((p) => p(harness)));
      return results.reduce((combined, current) => combined && current, true);
    });
  }
  /** Gets a description of this predicate for use in error messages. */
  getDescription() {
    return this._descriptions.join(", ");
  }
  /** Gets the selector used to find candidate elements. */
  getSelector() {
    if (!this._ancestor) {
      return (this.harnessType.hostSelector || "").trim();
    }
    const [ancestors, ancestorPlaceholders] = _splitAndEscapeSelector(this._ancestor);
    const [selectors, selectorPlaceholders] = _splitAndEscapeSelector(this.harnessType.hostSelector || "");
    const result = [];
    ancestors.forEach((escapedAncestor) => {
      const ancestor = _restoreSelector(escapedAncestor, ancestorPlaceholders);
      return selectors.forEach((escapedSelector) => result.push(`${ancestor} ${_restoreSelector(escapedSelector, selectorPlaceholders)}`));
    });
    return result.join(", ");
  }
  /** Adds base options common to all harness types. */
  _addBaseOptions(options) {
    this._ancestor = options.ancestor || "";
    if (this._ancestor) {
      this._descriptions.push(`has ancestor matching selector "${this._ancestor}"`);
    }
    const selector = options.selector;
    if (selector !== void 0) {
      this.add(`host matches selector "${selector}"`, (item) => __async(this, null, function* () {
        return (yield item.host()).matchesSelector(selector);
      }));
    }
  }
}
function _valueAsString(value) {
  if (value === void 0) {
    return "undefined";
  }
  try {
    const stringifiedValue = JSON.stringify(value, (_, v) => v instanceof RegExp ? `\u25ECMAT_RE_ESCAPE\u25EC${v.toString().replace(/"/g, "\u25ECMAT_RE_ESCAPE\u25EC")}\u25ECMAT_RE_ESCAPE\u25EC` : v);
    return stringifiedValue.replace(/"◬MAT_RE_ESCAPE◬|◬MAT_RE_ESCAPE◬"/g, "").replace(/◬MAT_RE_ESCAPE◬/g, '"');
  } catch (e) {
    return "{...}";
  }
}
function _splitAndEscapeSelector(selector) {
  const placeholders = [];
  const result = selector.replace(/(["'][^["']*["'])/g, (_, keep) => {
    const replaceBy = `__cdkPlaceholder-${placeholders.length}__`;
    placeholders.push(keep);
    return replaceBy;
  });
  return [result.split(",").map((part) => part.trim()), placeholders];
}
function _restoreSelector(selector, placeholders) {
  return selector.replace(/__cdkPlaceholder-(\d+)__/g, (_, index) => placeholders[+index]);
}
class HarnessEnvironment {
  // Implemented as part of the `LocatorFactory` interface.
  get rootElement() {
    this._rootElement = this._rootElement || this.createTestElement(this.rawRootElement);
    return this._rootElement;
  }
  set rootElement(element) {
    this._rootElement = element;
  }
  constructor(rawRootElement) {
    this.rawRootElement = rawRootElement;
  }
  // Implemented as part of the `LocatorFactory` interface.
  documentRootLocatorFactory() {
    return this.createEnvironment(this.getDocumentRoot());
  }
  // Implemented as part of the `LocatorFactory` interface.
  locatorFor(...queries) {
    return () => _assertResultFound(this._getAllHarnessesAndTestElements(queries), _getDescriptionForLocatorForQueries(queries));
  }
  // Implemented as part of the `LocatorFactory` interface.
  locatorForOptional(...queries) {
    return () => __async(this, null, function* () {
      return (yield this._getAllHarnessesAndTestElements(queries))[0] || null;
    });
  }
  // Implemented as part of the `LocatorFactory` interface.
  locatorForAll(...queries) {
    return () => this._getAllHarnessesAndTestElements(queries);
  }
  // Implemented as part of the `LocatorFactory` interface.
  rootHarnessLoader() {
    return __async(this, null, function* () {
      return this;
    });
  }
  // Implemented as part of the `LocatorFactory` interface.
  harnessLoaderFor(selector) {
    return __async(this, null, function* () {
      return this.createEnvironment(yield _assertResultFound(this.getAllRawElements(selector), [
        _getDescriptionForHarnessLoaderQuery(selector)
      ]));
    });
  }
  // Implemented as part of the `LocatorFactory` interface.
  harnessLoaderForOptional(selector) {
    return __async(this, null, function* () {
      const elements = yield this.getAllRawElements(selector);
      return elements[0] ? this.createEnvironment(elements[0]) : null;
    });
  }
  // Implemented as part of the `LocatorFactory` interface.
  harnessLoaderForAll(selector) {
    return __async(this, null, function* () {
      const elements = yield this.getAllRawElements(selector);
      return elements.map((element) => this.createEnvironment(element));
    });
  }
  // Implemented as part of the `HarnessLoader` interface.
  getHarness(query) {
    return this.locatorFor(query)();
  }
  // Implemented as part of the `HarnessLoader` interface.
  getHarnessOrNull(query) {
    return this.locatorForOptional(query)();
  }
  // Implemented as part of the `HarnessLoader` interface.
  getAllHarnesses(query) {
    return this.locatorForAll(query)();
  }
  // Implemented as part of the `HarnessLoader` interface.
  hasHarness(query) {
    return __async(this, null, function* () {
      return (yield this.locatorForOptional(query)()) !== null;
    });
  }
  // Implemented as part of the `HarnessLoader` interface.
  getChildLoader(selector) {
    return __async(this, null, function* () {
      return this.createEnvironment(yield _assertResultFound(this.getAllRawElements(selector), [
        _getDescriptionForHarnessLoaderQuery(selector)
      ]));
    });
  }
  // Implemented as part of the `HarnessLoader` interface.
  getAllChildLoaders(selector) {
    return __async(this, null, function* () {
      return (yield this.getAllRawElements(selector)).map((e) => this.createEnvironment(e));
    });
  }
  /** Creates a `ComponentHarness` for the given harness type with the given raw host element. */
  createComponentHarness(harnessType, element) {
    return new harnessType(this.createEnvironment(element));
  }
  /**
   * Matches the given raw elements with the given list of element and harness queries to produce a
   * list of matched harnesses and test elements.
   */
  _getAllHarnessesAndTestElements(queries) {
    return __async(this, null, function* () {
      if (!queries.length) {
        throw Error("CDK Component harness query must contain at least one element.");
      }
      const { allQueries, harnessQueries, elementQueries, harnessTypes } = _parseQueries(queries);
      const rawElements = yield this.getAllRawElements([...elementQueries, ...harnessQueries.map((predicate) => predicate.getSelector())].join(","));
      const skipSelectorCheck = elementQueries.length === 0 && harnessTypes.size === 1 || harnessQueries.length === 0;
      const perElementMatches = yield parallel(() => rawElements.map((rawElement) => __async(this, null, function* () {
        const testElement = this.createTestElement(rawElement);
        const allResultsForElement = yield parallel(
          // For each query, get `null` if it doesn't match, or a `TestElement` or
          // `ComponentHarness` as appropriate if it does match. This gives us everything that
          // matches the current raw element, but it may contain duplicate entries (e.g.
          // multiple `TestElement` or multiple `ComponentHarness` of the same type).
          () => allQueries.map((query) => this._getQueryResultForElement(query, rawElement, testElement, skipSelectorCheck))
        );
        return _removeDuplicateQueryResults(allResultsForElement);
      })));
      return [].concat(...perElementMatches);
    });
  }
  /**
   * Check whether the given query matches the given element, if it does return the matched
   * `TestElement` or `ComponentHarness`, if it does not, return null. In cases where the caller
   * knows for sure that the query matches the element's selector, `skipSelectorCheck` can be used
   * to skip verification and optimize performance.
   */
  _getQueryResultForElement(query, rawElement, testElement, skipSelectorCheck = false) {
    return __async(this, null, function* () {
      if (typeof query === "string") {
        return skipSelectorCheck || (yield testElement.matchesSelector(query)) ? testElement : null;
      }
      if (skipSelectorCheck || (yield testElement.matchesSelector(query.getSelector()))) {
        const harness = this.createComponentHarness(query.harnessType, rawElement);
        return (yield query.evaluate(harness)) ? harness : null;
      }
      return null;
    });
  }
}
function _parseQueries(queries) {
  const allQueries = [];
  const harnessQueries = [];
  const elementQueries = [];
  const harnessTypes = /* @__PURE__ */ new Set();
  for (const query of queries) {
    if (typeof query === "string") {
      allQueries.push(query);
      elementQueries.push(query);
    } else {
      const predicate = query instanceof HarnessPredicate ? query : new HarnessPredicate(query, {});
      allQueries.push(predicate);
      harnessQueries.push(predicate);
      harnessTypes.add(predicate.harnessType);
    }
  }
  return { allQueries, harnessQueries, elementQueries, harnessTypes };
}
function _removeDuplicateQueryResults(results) {
  return __async(this, null, function* () {
    let testElementMatched = false;
    let matchedHarnessTypes = /* @__PURE__ */ new Set();
    const dedupedMatches = [];
    for (const result of results) {
      if (!result) {
        continue;
      }
      if (result instanceof ComponentHarness) {
        if (!matchedHarnessTypes.has(result.constructor)) {
          matchedHarnessTypes.add(result.constructor);
          dedupedMatches.push(result);
        }
      } else if (!testElementMatched) {
        testElementMatched = true;
        dedupedMatches.push(result);
      }
    }
    return dedupedMatches;
  });
}
function _assertResultFound(results, queryDescriptions) {
  return __async(this, null, function* () {
    const result = (yield results)[0];
    if (result == void 0) {
      throw Error(`Failed to find element matching one of the following queries:
` + queryDescriptions.map((desc) => `(${desc})`).join(",\n"));
    }
    return result;
  });
}
function _getDescriptionForLocatorForQueries(queries) {
  return queries.map((query) => typeof query === "string" ? _getDescriptionForTestElementQuery(query) : _getDescriptionForComponentHarnessQuery(query));
}
function _getDescriptionForComponentHarnessQuery(query) {
  const harnessPredicate = query instanceof HarnessPredicate ? query : new HarnessPredicate(query, {});
  const { name, hostSelector } = harnessPredicate.harnessType;
  const description = `${name} with host element matching selector: "${hostSelector}"`;
  const constraints = harnessPredicate.getDescription();
  return description + (constraints ? ` satisfying the constraints: ${harnessPredicate.getDescription()}` : "");
}
function _getDescriptionForTestElementQuery(selector) {
  return `TestElement for element matching selector: "${selector}"`;
}
function _getDescriptionForHarnessLoaderQuery(selector) {
  return `HarnessLoader for element matching selector: "${selector}"`;
}
var TestKey;
(function(TestKey2) {
  TestKey2[TestKey2["BACKSPACE"] = 0] = "BACKSPACE";
  TestKey2[TestKey2["TAB"] = 1] = "TAB";
  TestKey2[TestKey2["ENTER"] = 2] = "ENTER";
  TestKey2[TestKey2["SHIFT"] = 3] = "SHIFT";
  TestKey2[TestKey2["CONTROL"] = 4] = "CONTROL";
  TestKey2[TestKey2["ALT"] = 5] = "ALT";
  TestKey2[TestKey2["ESCAPE"] = 6] = "ESCAPE";
  TestKey2[TestKey2["PAGE_UP"] = 7] = "PAGE_UP";
  TestKey2[TestKey2["PAGE_DOWN"] = 8] = "PAGE_DOWN";
  TestKey2[TestKey2["END"] = 9] = "END";
  TestKey2[TestKey2["HOME"] = 10] = "HOME";
  TestKey2[TestKey2["LEFT_ARROW"] = 11] = "LEFT_ARROW";
  TestKey2[TestKey2["UP_ARROW"] = 12] = "UP_ARROW";
  TestKey2[TestKey2["RIGHT_ARROW"] = 13] = "RIGHT_ARROW";
  TestKey2[TestKey2["DOWN_ARROW"] = 14] = "DOWN_ARROW";
  TestKey2[TestKey2["INSERT"] = 15] = "INSERT";
  TestKey2[TestKey2["DELETE"] = 16] = "DELETE";
  TestKey2[TestKey2["F1"] = 17] = "F1";
  TestKey2[TestKey2["F2"] = 18] = "F2";
  TestKey2[TestKey2["F3"] = 19] = "F3";
  TestKey2[TestKey2["F4"] = 20] = "F4";
  TestKey2[TestKey2["F5"] = 21] = "F5";
  TestKey2[TestKey2["F6"] = 22] = "F6";
  TestKey2[TestKey2["F7"] = 23] = "F7";
  TestKey2[TestKey2["F8"] = 24] = "F8";
  TestKey2[TestKey2["F9"] = 25] = "F9";
  TestKey2[TestKey2["F10"] = 26] = "F10";
  TestKey2[TestKey2["F11"] = 27] = "F11";
  TestKey2[TestKey2["F12"] = 28] = "F12";
  TestKey2[TestKey2["META"] = 29] = "META";
  TestKey2[TestKey2["COMMA"] = 30] = "COMMA";
})(TestKey || (TestKey = {}));
function getNoKeysSpecifiedError() {
  return Error("No keys have been specified.");
}
function _getTextWithExcludedElements(element, excludeSelector) {
  const clone = element.cloneNode(true);
  const exclusions = clone.querySelectorAll(excludeSelector);
  for (let i = 0; i < exclusions.length; i++) {
    exclusions[i].remove();
  }
  return (clone.textContent || "").trim();
}
