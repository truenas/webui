{
  "version": 3,
  "sources": ["/Users/macbook/karpov-work/TrueNAS/webui/node_modules/@angular/cdk/fesm2022/testing.mjs"],
  "sourcesContent": ["import { BehaviorSubject } from 'rxjs';\n\n/** Subject used to dispatch and listen for changes to the auto change detection status . */\nconst autoChangeDetectionSubject = new BehaviorSubject({\n    isDisabled: false,\n});\n/** The current subscription to `autoChangeDetectionSubject`. */\nlet autoChangeDetectionSubscription;\n/**\n * The default handler for auto change detection status changes. This handler will be used if the\n * specific environment does not install its own.\n * @param status The new auto change detection status.\n */\nfunction defaultAutoChangeDetectionHandler(status) {\n    status.onDetectChangesNow?.();\n}\n/**\n * Allows a test `HarnessEnvironment` to install its own handler for auto change detection status\n * changes.\n * @param handler The handler for the auto change detection status.\n */\nfunction handleAutoChangeDetectionStatus(handler) {\n    stopHandlingAutoChangeDetectionStatus();\n    autoChangeDetectionSubscription = autoChangeDetectionSubject.subscribe(handler);\n}\n/** Allows a `HarnessEnvironment` to stop handling auto change detection status changes. */\nfunction stopHandlingAutoChangeDetectionStatus() {\n    autoChangeDetectionSubscription?.unsubscribe();\n    autoChangeDetectionSubscription = null;\n}\n/**\n * Batches together triggering of change detection over the duration of the given function.\n * @param fn The function to call with batched change detection.\n * @param triggerBeforeAndAfter Optionally trigger change detection once before and after the batch\n *   operation. If false, change detection will not be triggered.\n * @return The result of the given function.\n */\nasync function batchChangeDetection(fn, triggerBeforeAndAfter) {\n    // If change detection batching is already in progress, just run the function.\n    if (autoChangeDetectionSubject.getValue().isDisabled) {\n        return await fn();\n    }\n    // If nothing is handling change detection batching, install the default handler.\n    if (!autoChangeDetectionSubscription) {\n        handleAutoChangeDetectionStatus(defaultAutoChangeDetectionHandler);\n    }\n    if (triggerBeforeAndAfter) {\n        await new Promise(resolve => autoChangeDetectionSubject.next({\n            isDisabled: true,\n            onDetectChangesNow: resolve,\n        }));\n        // The function passed in may throw (e.g. if the user wants to make an expectation of an error\n        // being thrown. If this happens, we need to make sure we still re-enable change detection, so\n        // we wrap it in a `finally` block.\n        try {\n            return await fn();\n        }\n        finally {\n            await new Promise(resolve => autoChangeDetectionSubject.next({\n                isDisabled: false,\n                onDetectChangesNow: resolve,\n            }));\n        }\n    }\n    else {\n        autoChangeDetectionSubject.next({ isDisabled: true });\n        // The function passed in may throw (e.g. if the user wants to make an expectation of an error\n        // being thrown. If this happens, we need to make sure we still re-enable change detection, so\n        // we wrap it in a `finally` block.\n        try {\n            return await fn();\n        }\n        finally {\n            autoChangeDetectionSubject.next({ isDisabled: false });\n        }\n    }\n}\n/**\n * Disables the harness system's auto change detection for the duration of the given function.\n * @param fn The function to disable auto change detection for.\n * @return The result of the given function.\n */\nasync function manualChangeDetection(fn) {\n    return batchChangeDetection(fn, false);\n}\n/**\n * Resolves the given list of async values in parallel (i.e. via Promise.all) while batching change\n * detection over the entire operation such that change detection occurs exactly once before\n * resolving the values and once after.\n * @param values A getter for the async values to resolve in parallel with batched change detection.\n * @return The resolved values.\n */\nasync function parallel(values) {\n    return batchChangeDetection(() => Promise.all(values()), true);\n}\n\n/**\n * Base class for component harnesses that all component harness authors should extend. This base\n * component harness provides the basic ability to locate element and sub-component harness. It\n * should be inherited when defining user's own harness.\n */\nclass ComponentHarness {\n    constructor(locatorFactory) {\n        this.locatorFactory = locatorFactory;\n    }\n    /** Gets a `Promise` for the `TestElement` representing the host element of the component. */\n    async host() {\n        return this.locatorFactory.rootElement;\n    }\n    /**\n     * Gets a `LocatorFactory` for the document root element. This factory can be used to create\n     * locators for elements that a component creates outside of its own root element. (e.g. by\n     * appending to document.body).\n     */\n    documentRootLocatorFactory() {\n        return this.locatorFactory.documentRootLocatorFactory();\n    }\n    /**\n     * Creates an asynchronous locator function that can be used to find a `ComponentHarness` instance\n     * or element under the host element of this `ComponentHarness`.\n     * @param queries A list of queries specifying which harnesses and elements to search for:\n     *   - A `string` searches for elements matching the CSS selector specified by the string.\n     *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the\n     *     given class.\n     *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given\n     *     predicate.\n     * @return An asynchronous locator function that searches for and returns a `Promise` for the\n     *   first element or harness matching the given search criteria. Matches are ordered first by\n     *   order in the DOM, and second by order in the queries list. If no matches are found, the\n     *   `Promise` rejects. The type that the `Promise` resolves to is a union of all result types for\n     *   each query.\n     *\n     * e.g. Given the following DOM: `<div id=\"d1\" /><div id=\"d2\" />`, and assuming\n     * `DivHarness.hostSelector === 'div'`:\n     * - `await ch.locatorFor(DivHarness, 'div')()` gets a `DivHarness` instance for `#d1`\n     * - `await ch.locatorFor('div', DivHarness)()` gets a `TestElement` instance for `#d1`\n     * - `await ch.locatorFor('span')()` throws because the `Promise` rejects.\n     */\n    locatorFor(...queries) {\n        return this.locatorFactory.locatorFor(...queries);\n    }\n    /**\n     * Creates an asynchronous locator function that can be used to find a `ComponentHarness` instance\n     * or element under the host element of this `ComponentHarness`.\n     * @param queries A list of queries specifying which harnesses and elements to search for:\n     *   - A `string` searches for elements matching the CSS selector specified by the string.\n     *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the\n     *     given class.\n     *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given\n     *     predicate.\n     * @return An asynchronous locator function that searches for and returns a `Promise` for the\n     *   first element or harness matching the given search criteria. Matches are ordered first by\n     *   order in the DOM, and second by order in the queries list. If no matches are found, the\n     *   `Promise` is resolved with `null`. The type that the `Promise` resolves to is a union of all\n     *   result types for each query or null.\n     *\n     * e.g. Given the following DOM: `<div id=\"d1\" /><div id=\"d2\" />`, and assuming\n     * `DivHarness.hostSelector === 'div'`:\n     * - `await ch.locatorForOptional(DivHarness, 'div')()` gets a `DivHarness` instance for `#d1`\n     * - `await ch.locatorForOptional('div', DivHarness)()` gets a `TestElement` instance for `#d1`\n     * - `await ch.locatorForOptional('span')()` gets `null`.\n     */\n    locatorForOptional(...queries) {\n        return this.locatorFactory.locatorForOptional(...queries);\n    }\n    /**\n     * Creates an asynchronous locator function that can be used to find `ComponentHarness` instances\n     * or elements under the host element of this `ComponentHarness`.\n     * @param queries A list of queries specifying which harnesses and elements to search for:\n     *   - A `string` searches for elements matching the CSS selector specified by the string.\n     *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the\n     *     given class.\n     *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given\n     *     predicate.\n     * @return An asynchronous locator function that searches for and returns a `Promise` for all\n     *   elements and harnesses matching the given search criteria. Matches are ordered first by\n     *   order in the DOM, and second by order in the queries list. If an element matches more than\n     *   one `ComponentHarness` class, the locator gets an instance of each for the same element. If\n     *   an element matches multiple `string` selectors, only one `TestElement` instance is returned\n     *   for that element. The type that the `Promise` resolves to is an array where each element is\n     *   the union of all result types for each query.\n     *\n     * e.g. Given the following DOM: `<div id=\"d1\" /><div id=\"d2\" />`, and assuming\n     * `DivHarness.hostSelector === 'div'` and `IdIsD1Harness.hostSelector === '#d1'`:\n     * - `await ch.locatorForAll(DivHarness, 'div')()` gets `[\n     *     DivHarness, // for #d1\n     *     TestElement, // for #d1\n     *     DivHarness, // for #d2\n     *     TestElement // for #d2\n     *   ]`\n     * - `await ch.locatorForAll('div', '#d1')()` gets `[\n     *     TestElement, // for #d1\n     *     TestElement // for #d2\n     *   ]`\n     * - `await ch.locatorForAll(DivHarness, IdIsD1Harness)()` gets `[\n     *     DivHarness, // for #d1\n     *     IdIsD1Harness, // for #d1\n     *     DivHarness // for #d2\n     *   ]`\n     * - `await ch.locatorForAll('span')()` gets `[]`.\n     */\n    locatorForAll(...queries) {\n        return this.locatorFactory.locatorForAll(...queries);\n    }\n    /**\n     * Flushes change detection and async tasks in the Angular zone.\n     * In most cases it should not be necessary to call this manually. However, there may be some edge\n     * cases where it is needed to fully flush animation events.\n     */\n    async forceStabilize() {\n        return this.locatorFactory.forceStabilize();\n    }\n    /**\n     * Waits for all scheduled or running async tasks to complete. This allows harness\n     * authors to wait for async tasks outside of the Angular zone.\n     */\n    async waitForTasksOutsideAngular() {\n        return this.locatorFactory.waitForTasksOutsideAngular();\n    }\n}\n/**\n * Base class for component harnesses that authors should extend if they anticipate that consumers\n * of the harness may want to access other harnesses within the `<ng-content>` of the component.\n */\nclass ContentContainerComponentHarness extends ComponentHarness {\n    async getChildLoader(selector) {\n        return (await this.getRootHarnessLoader()).getChildLoader(selector);\n    }\n    async getAllChildLoaders(selector) {\n        return (await this.getRootHarnessLoader()).getAllChildLoaders(selector);\n    }\n    async getHarness(query) {\n        return (await this.getRootHarnessLoader()).getHarness(query);\n    }\n    async getHarnessOrNull(query) {\n        return (await this.getRootHarnessLoader()).getHarnessOrNull(query);\n    }\n    async getAllHarnesses(query) {\n        return (await this.getRootHarnessLoader()).getAllHarnesses(query);\n    }\n    async hasHarness(query) {\n        return (await this.getRootHarnessLoader()).hasHarness(query);\n    }\n    /**\n     * Gets the root harness loader from which to start\n     * searching for content contained by this harness.\n     */\n    async getRootHarnessLoader() {\n        return this.locatorFactory.rootHarnessLoader();\n    }\n}\n/**\n * A class used to associate a ComponentHarness class with predicates functions that can be used to\n * filter instances of the class.\n */\nclass HarnessPredicate {\n    constructor(harnessType, options) {\n        this.harnessType = harnessType;\n        this._predicates = [];\n        this._descriptions = [];\n        this._addBaseOptions(options);\n    }\n    /**\n     * Checks if the specified nullable string value matches the given pattern.\n     * @param value The nullable string value to check, or a Promise resolving to the\n     *   nullable string value.\n     * @param pattern The pattern the value is expected to match. If `pattern` is a string,\n     *   `value` is expected to match exactly. If `pattern` is a regex, a partial match is\n     *   allowed. If `pattern` is `null`, the value is expected to be `null`.\n     * @return Whether the value matches the pattern.\n     */\n    static async stringMatches(value, pattern) {\n        value = await value;\n        if (pattern === null) {\n            return value === null;\n        }\n        else if (value === null) {\n            return false;\n        }\n        return typeof pattern === 'string' ? value === pattern : pattern.test(value);\n    }\n    /**\n     * Adds a predicate function to be run against candidate harnesses.\n     * @param description A description of this predicate that may be used in error messages.\n     * @param predicate An async predicate function.\n     * @return this (for method chaining).\n     */\n    add(description, predicate) {\n        this._descriptions.push(description);\n        this._predicates.push(predicate);\n        return this;\n    }\n    /**\n     * Adds a predicate function that depends on an option value to be run against candidate\n     * harnesses. If the option value is undefined, the predicate will be ignored.\n     * @param name The name of the option (may be used in error messages).\n     * @param option The option value.\n     * @param predicate The predicate function to run if the option value is not undefined.\n     * @return this (for method chaining).\n     */\n    addOption(name, option, predicate) {\n        if (option !== undefined) {\n            this.add(`${name} = ${_valueAsString(option)}`, item => predicate(item, option));\n        }\n        return this;\n    }\n    /**\n     * Filters a list of harnesses on this predicate.\n     * @param harnesses The list of harnesses to filter.\n     * @return A list of harnesses that satisfy this predicate.\n     */\n    async filter(harnesses) {\n        if (harnesses.length === 0) {\n            return [];\n        }\n        const results = await parallel(() => harnesses.map(h => this.evaluate(h)));\n        return harnesses.filter((_, i) => results[i]);\n    }\n    /**\n     * Evaluates whether the given harness satisfies this predicate.\n     * @param harness The harness to check\n     * @return A promise that resolves to true if the harness satisfies this predicate,\n     *   and resolves to false otherwise.\n     */\n    async evaluate(harness) {\n        const results = await parallel(() => this._predicates.map(p => p(harness)));\n        return results.reduce((combined, current) => combined && current, true);\n    }\n    /** Gets a description of this predicate for use in error messages. */\n    getDescription() {\n        return this._descriptions.join(', ');\n    }\n    /** Gets the selector used to find candidate elements. */\n    getSelector() {\n        // We don't have to go through the extra trouble if there are no ancestors.\n        if (!this._ancestor) {\n            return (this.harnessType.hostSelector || '').trim();\n        }\n        const [ancestors, ancestorPlaceholders] = _splitAndEscapeSelector(this._ancestor);\n        const [selectors, selectorPlaceholders] = _splitAndEscapeSelector(this.harnessType.hostSelector || '');\n        const result = [];\n        // We have to add the ancestor to each part of the host compound selector, otherwise we can get\n        // incorrect results. E.g. `.ancestor .a, .ancestor .b` vs `.ancestor .a, .b`.\n        ancestors.forEach(escapedAncestor => {\n            const ancestor = _restoreSelector(escapedAncestor, ancestorPlaceholders);\n            return selectors.forEach(escapedSelector => result.push(`${ancestor} ${_restoreSelector(escapedSelector, selectorPlaceholders)}`));\n        });\n        return result.join(', ');\n    }\n    /** Adds base options common to all harness types. */\n    _addBaseOptions(options) {\n        this._ancestor = options.ancestor || '';\n        if (this._ancestor) {\n            this._descriptions.push(`has ancestor matching selector \"${this._ancestor}\"`);\n        }\n        const selector = options.selector;\n        if (selector !== undefined) {\n            this.add(`host matches selector \"${selector}\"`, async (item) => {\n                return (await item.host()).matchesSelector(selector);\n            });\n        }\n    }\n}\n/** Represent a value as a string for the purpose of logging. */\nfunction _valueAsString(value) {\n    if (value === undefined) {\n        return 'undefined';\n    }\n    try {\n        // `JSON.stringify` doesn't handle RegExp properly, so we need a custom replacer.\n        // Use a character that is unlikely to appear in real strings to denote the start and end of\n        // the regex. This allows us to strip out the extra quotes around the value added by\n        // `JSON.stringify`. Also do custom escaping on `\"` characters to prevent `JSON.stringify`\n        // from escaping them as if they were part of a string.\n        const stringifiedValue = JSON.stringify(value, (_, v) => v instanceof RegExp\n            ? `\u25ECMAT_RE_ESCAPE\u25EC${v.toString().replace(/\"/g, '\u25ECMAT_RE_ESCAPE\u25EC')}\u25ECMAT_RE_ESCAPE\u25EC`\n            : v);\n        // Strip out the extra quotes around regexes and put back the manually escaped `\"` characters.\n        return stringifiedValue\n            .replace(/\"\u25ECMAT_RE_ESCAPE\u25EC|\u25ECMAT_RE_ESCAPE\u25EC\"/g, '')\n            .replace(/\u25ECMAT_RE_ESCAPE\u25EC/g, '\"');\n    }\n    catch {\n        // `JSON.stringify` will throw if the object is cyclical,\n        // in this case the best we can do is report the value as `{...}`.\n        return '{...}';\n    }\n}\n/**\n * Splits up a compound selector into its parts and escapes any quoted content. The quoted content\n * has to be escaped, because it can contain commas which will throw throw us off when trying to\n * split it.\n * @param selector Selector to be split.\n * @returns The escaped string where any quoted content is replaced with a placeholder. E.g.\n * `[foo=\"bar\"]` turns into `[foo=__cdkPlaceholder-0__]`. Use `_restoreSelector` to restore\n * the placeholders.\n */\nfunction _splitAndEscapeSelector(selector) {\n    const placeholders = [];\n    // Note that the regex doesn't account for nested quotes so something like `\"ab'cd'e\"` will be\n    // considered as two blocks. It's a bit of an edge case, but if we find that it's a problem,\n    // we can make it a bit smarter using a loop. Use this for now since it's more readable and\n    // compact. More complete implementation:\n    // https://github.com/angular/angular/blob/bd34bc9e89f18a/packages/compiler/src/shadow_css.ts#L655\n    const result = selector.replace(/([\"'][^[\"']*[\"'])/g, (_, keep) => {\n        const replaceBy = `__cdkPlaceholder-${placeholders.length}__`;\n        placeholders.push(keep);\n        return replaceBy;\n    });\n    return [result.split(',').map(part => part.trim()), placeholders];\n}\n/** Restores a selector whose content was escaped in `_splitAndEscapeSelector`. */\nfunction _restoreSelector(selector, placeholders) {\n    return selector.replace(/__cdkPlaceholder-(\\d+)__/g, (_, index) => placeholders[+index]);\n}\n\n/**\n * Base harness environment class that can be extended to allow `ComponentHarness`es to be used in\n * different test environments (e.g. testbed, protractor, etc.). This class implements the\n * functionality of both a `HarnessLoader` and `LocatorFactory`. This class is generic on the raw\n * element type, `E`, used by the particular test environment.\n */\nclass HarnessEnvironment {\n    // Implemented as part of the `LocatorFactory` interface.\n    get rootElement() {\n        this._rootElement = this._rootElement || this.createTestElement(this.rawRootElement);\n        return this._rootElement;\n    }\n    set rootElement(element) {\n        this._rootElement = element;\n    }\n    constructor(rawRootElement) {\n        this.rawRootElement = rawRootElement;\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    documentRootLocatorFactory() {\n        return this.createEnvironment(this.getDocumentRoot());\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    locatorFor(...queries) {\n        return () => _assertResultFound(this._getAllHarnessesAndTestElements(queries), _getDescriptionForLocatorForQueries(queries));\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    locatorForOptional(...queries) {\n        return async () => (await this._getAllHarnessesAndTestElements(queries))[0] || null;\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    locatorForAll(...queries) {\n        return () => this._getAllHarnessesAndTestElements(queries);\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    async rootHarnessLoader() {\n        return this;\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    async harnessLoaderFor(selector) {\n        return this.createEnvironment(await _assertResultFound(this.getAllRawElements(selector), [\n            _getDescriptionForHarnessLoaderQuery(selector),\n        ]));\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    async harnessLoaderForOptional(selector) {\n        const elements = await this.getAllRawElements(selector);\n        return elements[0] ? this.createEnvironment(elements[0]) : null;\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    async harnessLoaderForAll(selector) {\n        const elements = await this.getAllRawElements(selector);\n        return elements.map(element => this.createEnvironment(element));\n    }\n    // Implemented as part of the `HarnessLoader` interface.\n    getHarness(query) {\n        return this.locatorFor(query)();\n    }\n    // Implemented as part of the `HarnessLoader` interface.\n    getHarnessOrNull(query) {\n        return this.locatorForOptional(query)();\n    }\n    // Implemented as part of the `HarnessLoader` interface.\n    getAllHarnesses(query) {\n        return this.locatorForAll(query)();\n    }\n    // Implemented as part of the `HarnessLoader` interface.\n    async hasHarness(query) {\n        return (await this.locatorForOptional(query)()) !== null;\n    }\n    // Implemented as part of the `HarnessLoader` interface.\n    async getChildLoader(selector) {\n        return this.createEnvironment(await _assertResultFound(this.getAllRawElements(selector), [\n            _getDescriptionForHarnessLoaderQuery(selector),\n        ]));\n    }\n    // Implemented as part of the `HarnessLoader` interface.\n    async getAllChildLoaders(selector) {\n        return (await this.getAllRawElements(selector)).map(e => this.createEnvironment(e));\n    }\n    /** Creates a `ComponentHarness` for the given harness type with the given raw host element. */\n    createComponentHarness(harnessType, element) {\n        return new harnessType(this.createEnvironment(element));\n    }\n    /**\n     * Matches the given raw elements with the given list of element and harness queries to produce a\n     * list of matched harnesses and test elements.\n     */\n    async _getAllHarnessesAndTestElements(queries) {\n        if (!queries.length) {\n            throw Error('CDK Component harness query must contain at least one element.');\n        }\n        const { allQueries, harnessQueries, elementQueries, harnessTypes } = _parseQueries(queries);\n        // Combine all of the queries into one large comma-delimited selector and use it to get all raw\n        // elements matching any of the individual queries.\n        const rawElements = await this.getAllRawElements([...elementQueries, ...harnessQueries.map(predicate => predicate.getSelector())].join(','));\n        // If every query is searching for the same harness subclass, we know every result corresponds\n        // to an instance of that subclass. Likewise, if every query is for a `TestElement`, we know\n        // every result corresponds to a `TestElement`. Otherwise we need to verify which result was\n        // found by which selector so it can be matched to the appropriate instance.\n        const skipSelectorCheck = (elementQueries.length === 0 && harnessTypes.size === 1) || harnessQueries.length === 0;\n        const perElementMatches = await parallel(() => rawElements.map(async (rawElement) => {\n            const testElement = this.createTestElement(rawElement);\n            const allResultsForElement = await parallel(\n            // For each query, get `null` if it doesn't match, or a `TestElement` or\n            // `ComponentHarness` as appropriate if it does match. This gives us everything that\n            // matches the current raw element, but it may contain duplicate entries (e.g.\n            // multiple `TestElement` or multiple `ComponentHarness` of the same type).\n            () => allQueries.map(query => this._getQueryResultForElement(query, rawElement, testElement, skipSelectorCheck)));\n            return _removeDuplicateQueryResults(allResultsForElement);\n        }));\n        return [].concat(...perElementMatches);\n    }\n    /**\n     * Check whether the given query matches the given element, if it does return the matched\n     * `TestElement` or `ComponentHarness`, if it does not, return null. In cases where the caller\n     * knows for sure that the query matches the element's selector, `skipSelectorCheck` can be used\n     * to skip verification and optimize performance.\n     */\n    async _getQueryResultForElement(query, rawElement, testElement, skipSelectorCheck = false) {\n        if (typeof query === 'string') {\n            return skipSelectorCheck || (await testElement.matchesSelector(query)) ? testElement : null;\n        }\n        if (skipSelectorCheck || (await testElement.matchesSelector(query.getSelector()))) {\n            const harness = this.createComponentHarness(query.harnessType, rawElement);\n            return (await query.evaluate(harness)) ? harness : null;\n        }\n        return null;\n    }\n}\n/**\n * Parses a list of queries in the format accepted by the `locatorFor*` methods into an easier to\n * work with format.\n */\nfunction _parseQueries(queries) {\n    const allQueries = [];\n    const harnessQueries = [];\n    const elementQueries = [];\n    const harnessTypes = new Set();\n    for (const query of queries) {\n        if (typeof query === 'string') {\n            allQueries.push(query);\n            elementQueries.push(query);\n        }\n        else {\n            const predicate = query instanceof HarnessPredicate ? query : new HarnessPredicate(query, {});\n            allQueries.push(predicate);\n            harnessQueries.push(predicate);\n            harnessTypes.add(predicate.harnessType);\n        }\n    }\n    return { allQueries, harnessQueries, elementQueries, harnessTypes };\n}\n/**\n * Removes duplicate query results for a particular element. (e.g. multiple `TestElement`\n * instances or multiple instances of the same `ComponentHarness` class.\n */\nasync function _removeDuplicateQueryResults(results) {\n    let testElementMatched = false;\n    let matchedHarnessTypes = new Set();\n    const dedupedMatches = [];\n    for (const result of results) {\n        if (!result) {\n            continue;\n        }\n        if (result instanceof ComponentHarness) {\n            if (!matchedHarnessTypes.has(result.constructor)) {\n                matchedHarnessTypes.add(result.constructor);\n                dedupedMatches.push(result);\n            }\n        }\n        else if (!testElementMatched) {\n            testElementMatched = true;\n            dedupedMatches.push(result);\n        }\n    }\n    return dedupedMatches;\n}\n/** Verifies that there is at least one result in an array. */\nasync function _assertResultFound(results, queryDescriptions) {\n    const result = (await results)[0];\n    if (result == undefined) {\n        throw Error(`Failed to find element matching one of the following queries:\\n` +\n            queryDescriptions.map(desc => `(${desc})`).join(',\\n'));\n    }\n    return result;\n}\n/** Gets a list of description strings from a list of queries. */\nfunction _getDescriptionForLocatorForQueries(queries) {\n    return queries.map(query => typeof query === 'string'\n        ? _getDescriptionForTestElementQuery(query)\n        : _getDescriptionForComponentHarnessQuery(query));\n}\n/** Gets a description string for a `ComponentHarness` query. */\nfunction _getDescriptionForComponentHarnessQuery(query) {\n    const harnessPredicate = query instanceof HarnessPredicate ? query : new HarnessPredicate(query, {});\n    const { name, hostSelector } = harnessPredicate.harnessType;\n    const description = `${name} with host element matching selector: \"${hostSelector}\"`;\n    const constraints = harnessPredicate.getDescription();\n    return (description +\n        (constraints ? ` satisfying the constraints: ${harnessPredicate.getDescription()}` : ''));\n}\n/** Gets a description string for a `TestElement` query. */\nfunction _getDescriptionForTestElementQuery(selector) {\n    return `TestElement for element matching selector: \"${selector}\"`;\n}\n/** Gets a description string for a `HarnessLoader` query. */\nfunction _getDescriptionForHarnessLoaderQuery(selector) {\n    return `HarnessLoader for element matching selector: \"${selector}\"`;\n}\n\n/** An enum of non-text keys that can be used with the `sendKeys` method. */\n// NOTE: This is a separate enum from `@angular/cdk/keycodes` because we don't necessarily want to\n// support every possible keyCode. We also can't rely on Protractor's `Key` because we don't want a\n// dependency on any particular testing framework here. Instead we'll just maintain this supported\n// list of keys and let individual concrete `HarnessEnvironment` classes map them to whatever key\n// representation is used in its respective testing framework.\n// tslint:disable-next-line:prefer-const-enum Seems like this causes some issues with System.js\nvar TestKey;\n(function (TestKey) {\n    TestKey[TestKey[\"BACKSPACE\"] = 0] = \"BACKSPACE\";\n    TestKey[TestKey[\"TAB\"] = 1] = \"TAB\";\n    TestKey[TestKey[\"ENTER\"] = 2] = \"ENTER\";\n    TestKey[TestKey[\"SHIFT\"] = 3] = \"SHIFT\";\n    TestKey[TestKey[\"CONTROL\"] = 4] = \"CONTROL\";\n    TestKey[TestKey[\"ALT\"] = 5] = \"ALT\";\n    TestKey[TestKey[\"ESCAPE\"] = 6] = \"ESCAPE\";\n    TestKey[TestKey[\"PAGE_UP\"] = 7] = \"PAGE_UP\";\n    TestKey[TestKey[\"PAGE_DOWN\"] = 8] = \"PAGE_DOWN\";\n    TestKey[TestKey[\"END\"] = 9] = \"END\";\n    TestKey[TestKey[\"HOME\"] = 10] = \"HOME\";\n    TestKey[TestKey[\"LEFT_ARROW\"] = 11] = \"LEFT_ARROW\";\n    TestKey[TestKey[\"UP_ARROW\"] = 12] = \"UP_ARROW\";\n    TestKey[TestKey[\"RIGHT_ARROW\"] = 13] = \"RIGHT_ARROW\";\n    TestKey[TestKey[\"DOWN_ARROW\"] = 14] = \"DOWN_ARROW\";\n    TestKey[TestKey[\"INSERT\"] = 15] = \"INSERT\";\n    TestKey[TestKey[\"DELETE\"] = 16] = \"DELETE\";\n    TestKey[TestKey[\"F1\"] = 17] = \"F1\";\n    TestKey[TestKey[\"F2\"] = 18] = \"F2\";\n    TestKey[TestKey[\"F3\"] = 19] = \"F3\";\n    TestKey[TestKey[\"F4\"] = 20] = \"F4\";\n    TestKey[TestKey[\"F5\"] = 21] = \"F5\";\n    TestKey[TestKey[\"F6\"] = 22] = \"F6\";\n    TestKey[TestKey[\"F7\"] = 23] = \"F7\";\n    TestKey[TestKey[\"F8\"] = 24] = \"F8\";\n    TestKey[TestKey[\"F9\"] = 25] = \"F9\";\n    TestKey[TestKey[\"F10\"] = 26] = \"F10\";\n    TestKey[TestKey[\"F11\"] = 27] = \"F11\";\n    TestKey[TestKey[\"F12\"] = 28] = \"F12\";\n    TestKey[TestKey[\"META\"] = 29] = \"META\";\n    TestKey[TestKey[\"COMMA\"] = 30] = \"COMMA\";\n})(TestKey || (TestKey = {}));\n\n/**\n * Returns an error which reports that no keys have been specified.\n * @docs-private\n */\nfunction getNoKeysSpecifiedError() {\n    return Error('No keys have been specified.');\n}\n\n/**\n * Gets text of element excluding certain selectors within the element.\n * @param element Element to get text from,\n * @param excludeSelector Selector identifying which elements to exclude,\n */\nfunction _getTextWithExcludedElements(element, excludeSelector) {\n    const clone = element.cloneNode(true);\n    const exclusions = clone.querySelectorAll(excludeSelector);\n    for (let i = 0; i < exclusions.length; i++) {\n        exclusions[i].remove();\n    }\n    return (clone.textContent || '').trim();\n}\n\nexport { ComponentHarness, ContentContainerComponentHarness, HarnessEnvironment, HarnessPredicate, TestKey, _getTextWithExcludedElements, getNoKeysSpecifiedError, handleAutoChangeDetectionStatus, manualChangeDetection, parallel, stopHandlingAutoChangeDetectionStatus };\n//# sourceMappingURL=testing.mjs.map\n"],
  "mappings": "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",
  "names": ["TestKey"]
}
