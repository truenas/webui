{"file":"/Users/macbook/karpov-work/TrueNAS/webui/src/app/helpers/error-parser.helper.ts","mappings":";;;;;;AAAA,+CAAyD;AACzD,yCAAyC;AACzC,4EAAkD;AAElD,kFAAkF;AAClF,SAAS,sBAAsB,CAAC,KAAc;IAC5C,2EAA2E;IAC3E,wDAAwD;IACxD,OAAO,KAAK,IAAK,KAAoC,CAAC,eAAe;QACnE,CAAC,CAAE,KAAoC,CAAC,eAAe;QACvD,CAAC,CAAC,KAAK,CAAC;AACZ,CAAC;AAED,SAAS,sBAAsB,CAAC,KAAwB;IACtD,uGAAuG;IACvG,IAAI,wBAAwB,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC;QAC1C,OAAO,KAAK,CAAC,KAAK,CAAC;IACrB,CAAC;IAED,+EAA+E;IAC/E,IAAI,KAAK,CAAC,KAAK,YAAY,UAAU,IAAI,KAAK,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC;QAC7D,OAAO,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC;IAC7B,CAAC;IAED,wEAAwE;IACxE,IAAI,OAAO,KAAK,CAAC,KAAK,KAAK,QAAQ,EAAE,CAAC;QACpC,OAAO,wBAAwB,KAAK,CAAC,MAAM,eAAe,KAAK,CAAC,KAAK,GAAG,CAAC;IAC3E,CAAC;IAED,qFAAqF;IACrF,OAAO,KAAK,CAAC,OAAO,CAAC;AACvB,CAAC;AAQD,SAAS,wBAAwB,CAAC,KAAc;IAC9C,IAAI,KAAK,YAAY,KAAK,EAAE,CAAC;QAC3B,OAAO,IAAI,CAAC;IACd,CAAC;IAED,IAAI,KAAK,KAAK,IAAI,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC;QAChD,OAAO,KAAK,CAAC;IACf,CAAC;IAED,MAAM,SAAS,GAAG,KAAuB,CAAC;IAE1C,OAAO,CACL,IAAA,gBAAQ,EAAC,SAAS,CAAC,IAAI,CAAC;WACrB,IAAA,gBAAQ,EAAC,SAAS,CAAC,OAAO,CAAC;WAC3B,CAAC,SAAS,KAAK,SAAS,CAAC,KAAK,IAAI,IAAA,gBAAQ,EAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAChE,CAAC;AACJ,CAAC;AAED;;;GAGG;AACI,MAAM,gBAAgB,GAAG,CAAC,cAAuB,EAAW,EAAE;IACnE,MAAM,KAAK,GAAG,sBAAsB,CAAC,cAAc,CAAC,CAAC;IAErD,4EAA4E;IAC5E,IAAI,KAAK,YAAY,wBAAiB,EAAE,CAAC;QACvC,OAAO,sBAAsB,CAAC,KAAK,CAAC,CAAC;IACvC,CAAC;IAED,qDAAqD;IACrD,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,wBAAwB,CAAC,KAAK,CAAC,EAAE,CAAC;QACjE,OAAO,KAAK,CAAC;IACf,CAAC;IAED,4DAA4D;IAC5D,OAAO,IAAI,CAAC;AACd,CAAC,CAAC;AAfW,QAAA,gBAAgB,oBAe3B;AAEK,MAAM,+BAA+B,GAAG,CAAC,KAAc,EAAW,EAAE;IACzE,MAAM,uBAAuB,GAAG,IAAA,wBAAgB,EAAC,KAAK,CAAC,CAAC;IACxD,IAAI,uBAAuB,EAAE,CAAC;QAC5B,OAAO,uBAAuB,CAAC;IACjC,CAAC;IAED,IAAI,CAAC;QACH,MAAM,gBAAgB,GAAG,4BAAgB,CAAC,KAAK,CAAC,KAAc,CAAC,CAAC;QAEhE,IAAI,gBAAgB,EAAE,CAAC;YACrB,OAAO,gBAAgB,CAAC;QAC1B,CAAC;IACH,CAAC;IAAC,WAAM,CAAC,CAAA,CAAC;IAEV,OAAO,KAAK,CAAC;AACf,CAAC,CAAC;AAfW,QAAA,+BAA+B,mCAe1C","names":[],"sources":["/Users/macbook/karpov-work/TrueNAS/webui/src/app/helpers/error-parser.helper.ts"],"sourcesContent":["import { HttpErrorResponse } from '@angular/common/http';\nimport { isString } from '@sentry/utils';\nimport ErrorStackParser from 'error-stack-parser';\n\n// https://github.com/angular/angular/blob/master/packages/core/src/util/errors.ts\nfunction tryToUnwrapZonejsError(error: unknown): unknown {\n  // TODO: once Angular14 is the minimum requirement ERROR_ORIGINAL_ERROR and\n  //  getOriginalError from error.ts can be used directly.\n  return error && (error as { ngOriginalError: Error }).ngOriginalError\n    ? (error as { ngOriginalError: Error }).ngOriginalError\n    : error;\n}\n\nfunction extractHttpModuleError(error: HttpErrorResponse): string | Error {\n  // The `error` property of http exception can be either an `Error` object, which we can use directly...\n  if (isErrorOrErrorLikeObject(error.error)) {\n    return error.error;\n  }\n\n  // ... or an`ErrorEvent`, which can provide us with the message but no stack...\n  if (error.error instanceof ErrorEvent && error.error.message) {\n    return error.error.message;\n  }\n\n  // ...or the request body itself, which we can use as a message instead.\n  if (typeof error.error === 'string') {\n    return `Server returned code ${error.status} with body \"${error.error}\"`;\n  }\n\n  // If we don't have any detailed information, fallback to the request message itself.\n  return error.message;\n}\n\ninterface ErrorCandidate {\n  name?: unknown;\n  message?: unknown;\n  stack?: unknown;\n}\n\nfunction isErrorOrErrorLikeObject(value: unknown): value is Error {\n  if (value instanceof Error) {\n    return true;\n  }\n\n  if (value === null || typeof value !== 'object') {\n    return false;\n  }\n\n  const candidate = value as ErrorCandidate;\n\n  return (\n    isString(candidate.name)\n    && isString(candidate.message)\n    && (undefined === candidate.stack || isString(candidate.stack))\n  );\n}\n\n/**\n * Default implementation of error extraction that handles default error wrapping,\n * HTTP responses, ErrorEvent and few other known cases.\n */\nexport const defaultExtractor = (errorCandidate: unknown): unknown => {\n  const error = tryToUnwrapZonejsError(errorCandidate);\n\n  // If it's http module error, extract as much information from it as we can.\n  if (error instanceof HttpErrorResponse) {\n    return extractHttpModuleError(error);\n  }\n\n  // We can handle messages and Error objects directly.\n  if (typeof error === 'string' || isErrorOrErrorLikeObject(error)) {\n    return error;\n  }\n\n  // Nothing was extracted, fallback to default error message.\n  return null;\n};\n\nexport const sentryCustomExceptionExtraction = (error: unknown): unknown => {\n  const defaultExtractorResults = defaultExtractor(error);\n  if (defaultExtractorResults) {\n    return defaultExtractorResults;\n  }\n\n  try {\n    const parsedErrorValue = ErrorStackParser.parse(error as Error);\n\n    if (parsedErrorValue) {\n      return parsedErrorValue;\n    }\n  } catch {}\n\n  return error;\n};\n"],"version":3}