70bbe02628d132ea8eb48889e03ad12d
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ngrx_store_exports = {};
__export(ngrx_store_exports, {
  ACTIVE_RUNTIME_CHECKS: () => ACTIVE_RUNTIME_CHECKS,
  ActionsSubject: () => ActionsSubject,
  FEATURE_REDUCERS: () => FEATURE_REDUCERS,
  FEATURE_STATE_PROVIDER: () => FEATURE_STATE_PROVIDER,
  INIT: () => INIT,
  INITIAL_REDUCERS: () => INITIAL_REDUCERS,
  INITIAL_STATE: () => INITIAL_STATE,
  META_REDUCERS: () => META_REDUCERS,
  REDUCER_FACTORY: () => REDUCER_FACTORY,
  ROOT_STORE_PROVIDER: () => ROOT_STORE_PROVIDER,
  ReducerManager: () => ReducerManager,
  ReducerManagerDispatcher: () => ReducerManagerDispatcher,
  ReducerObservable: () => ReducerObservable,
  STORE_FEATURES: () => STORE_FEATURES,
  ScannedActionsSubject: () => ScannedActionsSubject,
  State: () => State,
  StateObservable: () => StateObservable,
  Store: () => Store,
  StoreFeatureModule: () => StoreFeatureModule,
  StoreModule: () => StoreModule,
  StoreRootModule: () => StoreRootModule,
  UPDATE: () => UPDATE,
  USER_PROVIDED_META_REDUCERS: () => USER_PROVIDED_META_REDUCERS,
  USER_RUNTIME_CHECKS: () => USER_RUNTIME_CHECKS,
  combineReducers: () => combineReducers,
  compose: () => compose,
  createAction: () => createAction,
  createActionGroup: () => createActionGroup,
  createFeature: () => createFeature,
  createFeatureSelector: () => createFeatureSelector,
  createReducer: () => createReducer,
  createReducerFactory: () => createReducerFactory,
  createSelector: () => createSelector,
  createSelectorFactory: () => createSelectorFactory,
  defaultMemoize: () => defaultMemoize,
  defaultStateFn: () => defaultStateFn,
  emptyProps: () => emptyProps,
  isNgrxMockEnvironment: () => isNgrxMockEnvironment,
  on: () => on,
  props: () => props,
  provideState: () => provideState,
  provideStore: () => provideStore,
  reduceState: () => reduceState,
  resultMemoize: () => resultMemoize,
  select: () => select,
  setNgrxMockEnvironment: () => setNgrxMockEnvironment,
  union: () => union
});
module.exports = __toCommonJS(ngrx_store_exports);
var i0 = __toESM(require("@angular/core"), 1);
var import_core = require("@angular/core");
var import_rxjs = require("rxjs");
var import_operators = require("rxjs/operators");
var import_rxjs_interop = require("@angular/core/rxjs-interop");
const REGISTERED_ACTION_TYPES = {};
function resetRegisteredActionTypes() {
  for (const key of Object.keys(REGISTERED_ACTION_TYPES)) {
    delete REGISTERED_ACTION_TYPES[key];
  }
}
function createAction(type, config) {
  REGISTERED_ACTION_TYPES[type] = (REGISTERED_ACTION_TYPES[type] || 0) + 1;
  if (typeof config === "function") {
    return defineType(type, (...args) => __spreadProps(__spreadValues({}, config(...args)), {
      type
    }));
  }
  const as = config ? config._as : "empty";
  switch (as) {
    case "empty":
      return defineType(type, () => ({ type }));
    case "props":
      return defineType(type, (props2) => __spreadProps(__spreadValues({}, props2), {
        type
      }));
    default:
      throw new Error("Unexpected config.");
  }
}
function props() {
  return { _as: "props", _p: void 0 };
}
function union(creators) {
  return void 0;
}
function defineType(type, creator) {
  return Object.defineProperty(creator, "type", {
    value: type,
    writable: false
  });
}
function capitalize(text) {
  return text.charAt(0).toUpperCase() + text.substring(1);
}
function uncapitalize(text) {
  return text.charAt(0).toLowerCase() + text.substring(1);
}
function createActionGroup(config) {
  const { source, events } = config;
  return Object.keys(events).reduce((actionGroup, eventName) => __spreadProps(__spreadValues({}, actionGroup), {
    [toActionName(eventName)]: createAction(toActionType(source, eventName), events[eventName])
  }), {});
}
function emptyProps() {
  return props();
}
function toActionName(eventName) {
  return eventName.trim().split(" ").map((word, i) => i === 0 ? uncapitalize(word) : capitalize(word)).join("");
}
function toActionType(source, eventName) {
  return `[${source}] ${eventName}`;
}
const INIT = "@ngrx/store/init";
const _ActionsSubject = class _ActionsSubject extends import_rxjs.BehaviorSubject {
  constructor() {
    super({ type: INIT });
  }
  next(action) {
    if (typeof action === "function") {
      throw new TypeError(`
        Dispatch expected an object, instead it received a function.
        If you're using the createAction function, make sure to invoke the function
        before dispatching the action. For example, someAction should be someAction().`);
    } else if (typeof action === "undefined") {
      throw new TypeError(`Actions must be objects`);
    } else if (typeof action.type === "undefined") {
      throw new TypeError(`Actions must have a type property`);
    }
    super.next(action);
  }
  complete() {
  }
  ngOnDestroy() {
    super.complete();
  }
};
_ActionsSubject.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _ActionsSubject, deps: [], target: i0.\u0275\u0275FactoryTarget.Injectable });
_ActionsSubject.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _ActionsSubject });
let ActionsSubject = _ActionsSubject;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: ActionsSubject, decorators: [{
  type: import_core.Injectable
}], ctorParameters: () => [] });
const ACTIONS_SUBJECT_PROVIDERS = [ActionsSubject];
const _ROOT_STORE_GUARD = new import_core.InjectionToken("@ngrx/store Internal Root Guard");
const _INITIAL_STATE = new import_core.InjectionToken("@ngrx/store Internal Initial State");
const INITIAL_STATE = new import_core.InjectionToken("@ngrx/store Initial State");
const REDUCER_FACTORY = new import_core.InjectionToken("@ngrx/store Reducer Factory");
const _REDUCER_FACTORY = new import_core.InjectionToken("@ngrx/store Internal Reducer Factory Provider");
const INITIAL_REDUCERS = new import_core.InjectionToken("@ngrx/store Initial Reducers");
const _INITIAL_REDUCERS = new import_core.InjectionToken("@ngrx/store Internal Initial Reducers");
const STORE_FEATURES = new import_core.InjectionToken("@ngrx/store Store Features");
const _STORE_REDUCERS = new import_core.InjectionToken("@ngrx/store Internal Store Reducers");
const _FEATURE_REDUCERS = new import_core.InjectionToken("@ngrx/store Internal Feature Reducers");
const _FEATURE_CONFIGS = new import_core.InjectionToken("@ngrx/store Internal Feature Configs");
const _STORE_FEATURES = new import_core.InjectionToken("@ngrx/store Internal Store Features");
const _FEATURE_REDUCERS_TOKEN = new import_core.InjectionToken("@ngrx/store Internal Feature Reducers Token");
const FEATURE_REDUCERS = new import_core.InjectionToken("@ngrx/store Feature Reducers");
const USER_PROVIDED_META_REDUCERS = new import_core.InjectionToken("@ngrx/store User Provided Meta Reducers");
const META_REDUCERS = new import_core.InjectionToken("@ngrx/store Meta Reducers");
const _RESOLVED_META_REDUCERS = new import_core.InjectionToken("@ngrx/store Internal Resolved Meta Reducers");
const USER_RUNTIME_CHECKS = new import_core.InjectionToken("@ngrx/store User Runtime Checks Config");
const _USER_RUNTIME_CHECKS = new import_core.InjectionToken("@ngrx/store Internal User Runtime Checks Config");
const ACTIVE_RUNTIME_CHECKS = new import_core.InjectionToken("@ngrx/store Internal Runtime Checks");
const _ACTION_TYPE_UNIQUENESS_CHECK = new import_core.InjectionToken("@ngrx/store Check if Action types are unique");
const ROOT_STORE_PROVIDER = new import_core.InjectionToken("@ngrx/store Root Store Provider");
const FEATURE_STATE_PROVIDER = new import_core.InjectionToken("@ngrx/store Feature State Provider");
function combineReducers(reducers, initialState = {}) {
  const reducerKeys = Object.keys(reducers);
  const finalReducers = {};
  for (let i = 0; i < reducerKeys.length; i++) {
    const key = reducerKeys[i];
    if (typeof reducers[key] === "function") {
      finalReducers[key] = reducers[key];
    }
  }
  const finalReducerKeys = Object.keys(finalReducers);
  return function combination(state, action) {
    state = state === void 0 ? initialState : state;
    let hasChanged = false;
    const nextState = {};
    for (let i = 0; i < finalReducerKeys.length; i++) {
      const key = finalReducerKeys[i];
      const reducer = finalReducers[key];
      const previousStateForKey = state[key];
      const nextStateForKey = reducer(previousStateForKey, action);
      nextState[key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    return hasChanged ? nextState : state;
  };
}
function omit(object, keyToRemove) {
  return Object.keys(object).filter((key) => key !== keyToRemove).reduce((result, key) => Object.assign(result, { [key]: object[key] }), {});
}
function compose(...functions) {
  return function(arg) {
    if (functions.length === 0) {
      return arg;
    }
    const last = functions[functions.length - 1];
    const rest = functions.slice(0, -1);
    return rest.reduceRight((composed, fn) => fn(composed), last(arg));
  };
}
function createReducerFactory(reducerFactory, metaReducers) {
  if (Array.isArray(metaReducers) && metaReducers.length > 0) {
    reducerFactory = compose.apply(null, [
      ...metaReducers,
      reducerFactory
    ]);
  }
  return (reducers, initialState) => {
    const reducer = reducerFactory(reducers);
    return (state, action) => {
      state = state === void 0 ? initialState : state;
      return reducer(state, action);
    };
  };
}
function createFeatureReducerFactory(metaReducers) {
  const reducerFactory = Array.isArray(metaReducers) && metaReducers.length > 0 ? compose(...metaReducers) : (r) => r;
  return (reducer, initialState) => {
    reducer = reducerFactory(reducer);
    return (state, action) => {
      state = state === void 0 ? initialState : state;
      return reducer(state, action);
    };
  };
}
class ReducerObservable extends import_rxjs.Observable {
}
class ReducerManagerDispatcher extends ActionsSubject {
}
const UPDATE = "@ngrx/store/update-reducers";
const _ReducerManager = class _ReducerManager extends import_rxjs.BehaviorSubject {
  get currentReducers() {
    return this.reducers;
  }
  constructor(dispatcher, initialState, reducers, reducerFactory) {
    super(reducerFactory(reducers, initialState));
    this.dispatcher = dispatcher;
    this.initialState = initialState;
    this.reducers = reducers;
    this.reducerFactory = reducerFactory;
  }
  addFeature(feature) {
    this.addFeatures([feature]);
  }
  addFeatures(features) {
    const reducers = features.reduce((reducerDict, { reducers: reducers2, reducerFactory, metaReducers, initialState, key }) => {
      const reducer = typeof reducers2 === "function" ? createFeatureReducerFactory(metaReducers)(reducers2, initialState) : createReducerFactory(reducerFactory, metaReducers)(reducers2, initialState);
      reducerDict[key] = reducer;
      return reducerDict;
    }, {});
    this.addReducers(reducers);
  }
  removeFeature(feature) {
    this.removeFeatures([feature]);
  }
  removeFeatures(features) {
    this.removeReducers(features.map((p) => p.key));
  }
  addReducer(key, reducer) {
    this.addReducers({ [key]: reducer });
  }
  addReducers(reducers) {
    this.reducers = __spreadValues(__spreadValues({}, this.reducers), reducers);
    this.updateReducers(Object.keys(reducers));
  }
  removeReducer(featureKey) {
    this.removeReducers([featureKey]);
  }
  removeReducers(featureKeys) {
    featureKeys.forEach((key) => {
      this.reducers = omit(this.reducers, key);
    });
    this.updateReducers(featureKeys);
  }
  updateReducers(featureKeys) {
    this.next(this.reducerFactory(this.reducers, this.initialState));
    this.dispatcher.next({
      type: UPDATE,
      features: featureKeys
    });
  }
  ngOnDestroy() {
    this.complete();
  }
};
_ReducerManager.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _ReducerManager, deps: [{ token: ReducerManagerDispatcher }, { token: INITIAL_STATE }, { token: INITIAL_REDUCERS }, { token: REDUCER_FACTORY }], target: i0.\u0275\u0275FactoryTarget.Injectable });
_ReducerManager.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _ReducerManager });
let ReducerManager = _ReducerManager;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: ReducerManager, decorators: [{
  type: import_core.Injectable
}], ctorParameters: () => [{ type: ReducerManagerDispatcher }, { type: void 0, decorators: [{
  type: import_core.Inject,
  args: [INITIAL_STATE]
}] }, { type: void 0, decorators: [{
  type: import_core.Inject,
  args: [INITIAL_REDUCERS]
}] }, { type: void 0, decorators: [{
  type: import_core.Inject,
  args: [REDUCER_FACTORY]
}] }] });
const REDUCER_MANAGER_PROVIDERS = [
  ReducerManager,
  { provide: ReducerObservable, useExisting: ReducerManager },
  { provide: ReducerManagerDispatcher, useExisting: ActionsSubject }
];
const _ScannedActionsSubject = class _ScannedActionsSubject extends import_rxjs.Subject {
  ngOnDestroy() {
    this.complete();
  }
};
_ScannedActionsSubject.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _ScannedActionsSubject, deps: null, target: i0.\u0275\u0275FactoryTarget.Injectable });
_ScannedActionsSubject.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _ScannedActionsSubject });
let ScannedActionsSubject = _ScannedActionsSubject;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: ScannedActionsSubject, decorators: [{
  type: import_core.Injectable
}] });
const SCANNED_ACTIONS_SUBJECT_PROVIDERS = [
  ScannedActionsSubject
];
class StateObservable extends import_rxjs.Observable {
}
const _State = class _State extends import_rxjs.BehaviorSubject {
  constructor(actions$, reducer$, scannedActions, initialState) {
    super(initialState);
    const actionsOnQueue$ = actions$.pipe((0, import_operators.observeOn)(import_rxjs.queueScheduler));
    const withLatestReducer$ = actionsOnQueue$.pipe((0, import_operators.withLatestFrom)(reducer$));
    const seed = { state: initialState };
    const stateAndAction$ = withLatestReducer$.pipe((0, import_operators.scan)(reduceState, seed));
    this.stateSubscription = stateAndAction$.subscribe(({ state, action }) => {
      this.next(state);
      scannedActions.next(action);
    });
    this.state = (0, import_rxjs_interop.toSignal)(this, { manualCleanup: true, requireSync: true });
  }
  ngOnDestroy() {
    this.stateSubscription.unsubscribe();
    this.complete();
  }
};
_State.INIT = INIT;
_State.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _State, deps: [{ token: ActionsSubject }, { token: ReducerObservable }, { token: ScannedActionsSubject }, { token: INITIAL_STATE }], target: i0.\u0275\u0275FactoryTarget.Injectable });
_State.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _State });
let State = _State;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: State, decorators: [{
  type: import_core.Injectable
}], ctorParameters: () => [{ type: ActionsSubject }, { type: ReducerObservable }, { type: ScannedActionsSubject }, { type: void 0, decorators: [{
  type: import_core.Inject,
  args: [INITIAL_STATE]
}] }] });
function reduceState(stateActionPair = { state: void 0 }, [action, reducer]) {
  const { state } = stateActionPair;
  return { state: reducer(state, action), action };
}
const STATE_PROVIDERS = [
  State,
  { provide: StateObservable, useExisting: State }
];
const _Store = class _Store extends import_rxjs.Observable {
  constructor(state$, actionsObserver, reducerManager) {
    super();
    this.actionsObserver = actionsObserver;
    this.reducerManager = reducerManager;
    this.source = state$;
    this.state = state$.state;
  }
  select(pathOrMapFn, ...paths) {
    return select.call(null, pathOrMapFn, ...paths)(this);
  }
  /**
   * Returns a signal of the provided selector.
   *
   * @param selector selector function
   * @param options select signal options
   */
  selectSignal(selector, options) {
    return (0, import_core.computed)(() => selector(this.state()), options);
  }
  lift(operator) {
    const store = new _Store(this, this.actionsObserver, this.reducerManager);
    store.operator = operator;
    return store;
  }
  dispatch(action) {
    this.actionsObserver.next(action);
  }
  next(action) {
    this.actionsObserver.next(action);
  }
  error(err) {
    this.actionsObserver.error(err);
  }
  complete() {
    this.actionsObserver.complete();
  }
  addReducer(key, reducer) {
    this.reducerManager.addReducer(key, reducer);
  }
  removeReducer(key) {
    this.reducerManager.removeReducer(key);
  }
};
_Store.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _Store, deps: [{ token: StateObservable }, { token: ActionsSubject }, { token: ReducerManager }], target: i0.\u0275\u0275FactoryTarget.Injectable });
_Store.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _Store });
let Store = _Store;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: Store, decorators: [{
  type: import_core.Injectable
}], ctorParameters: () => [{ type: StateObservable }, { type: ActionsSubject }, { type: ReducerManager }] });
const STORE_PROVIDERS = [Store];
function select(pathOrMapFn, propsOrPath, ...paths) {
  return function selectOperator(source$) {
    let mapped$;
    if (typeof pathOrMapFn === "string") {
      const pathSlices = [propsOrPath, ...paths].filter(Boolean);
      mapped$ = source$.pipe((0, import_operators.pluck)(pathOrMapFn, ...pathSlices));
    } else if (typeof pathOrMapFn === "function") {
      mapped$ = source$.pipe((0, import_operators.map)((source) => pathOrMapFn(source, propsOrPath)));
    } else {
      throw new TypeError(`Unexpected type '${typeof pathOrMapFn}' in select operator, expected 'string' or 'function'`);
    }
    return mapped$.pipe((0, import_operators.distinctUntilChanged)());
  };
}
const RUNTIME_CHECK_URL = "https://ngrx.io/guide/store/configuration/runtime-checks";
function isUndefined(target) {
  return target === void 0;
}
function isNull(target) {
  return target === null;
}
function isArray(target) {
  return Array.isArray(target);
}
function isString(target) {
  return typeof target === "string";
}
function isBoolean(target) {
  return typeof target === "boolean";
}
function isNumber(target) {
  return typeof target === "number";
}
function isObjectLike(target) {
  return typeof target === "object" && target !== null;
}
function isObject(target) {
  return isObjectLike(target) && !isArray(target);
}
function isPlainObject(target) {
  if (!isObject(target)) {
    return false;
  }
  const targetPrototype = Object.getPrototypeOf(target);
  return targetPrototype === Object.prototype || targetPrototype === null;
}
function isFunction(target) {
  return typeof target === "function";
}
function isComponent(target) {
  return isFunction(target) && target.hasOwnProperty("\u0275cmp");
}
function hasOwnProperty(target, propertyName) {
  return Object.prototype.hasOwnProperty.call(target, propertyName);
}
let _ngrxMockEnvironment = false;
function setNgrxMockEnvironment(value) {
  _ngrxMockEnvironment = value;
}
function isNgrxMockEnvironment() {
  return _ngrxMockEnvironment;
}
function isEqualCheck(a, b) {
  return a === b;
}
function isArgumentsChanged(args, lastArguments, comparator) {
  for (let i = 0; i < args.length; i++) {
    if (!comparator(args[i], lastArguments[i])) {
      return true;
    }
  }
  return false;
}
function resultMemoize(projectionFn, isResultEqual) {
  return defaultMemoize(projectionFn, isEqualCheck, isResultEqual);
}
function defaultMemoize(projectionFn, isArgumentsEqual = isEqualCheck, isResultEqual = isEqualCheck) {
  let lastArguments = null;
  let lastResult = null;
  let overrideResult;
  function reset() {
    lastArguments = null;
    lastResult = null;
  }
  function setResult(result = void 0) {
    overrideResult = { result };
  }
  function clearResult() {
    overrideResult = void 0;
  }
  function memoized() {
    if (overrideResult !== void 0) {
      return overrideResult.result;
    }
    if (!lastArguments) {
      lastResult = projectionFn.apply(null, arguments);
      lastArguments = arguments;
      return lastResult;
    }
    if (!isArgumentsChanged(arguments, lastArguments, isArgumentsEqual)) {
      return lastResult;
    }
    const newResult = projectionFn.apply(null, arguments);
    lastArguments = arguments;
    if (isResultEqual(lastResult, newResult)) {
      return lastResult;
    }
    lastResult = newResult;
    return newResult;
  }
  return { memoized, reset, setResult, clearResult };
}
function createSelector(...input) {
  return createSelectorFactory(defaultMemoize)(...input);
}
function defaultStateFn(state, selectors, props2, memoizedProjector) {
  if (props2 === void 0) {
    const args2 = selectors.map((fn) => fn(state));
    return memoizedProjector.memoized.apply(null, args2);
  }
  const args = selectors.map((fn) => fn(state, props2));
  return memoizedProjector.memoized.apply(null, [...args, props2]);
}
function createSelectorFactory(memoize, options = {
  stateFn: defaultStateFn
}) {
  return function(...input) {
    let args = input;
    if (Array.isArray(args[0])) {
      const [head, ...tail] = args;
      args = [...head, ...tail];
    } else if (args.length === 1 && isSelectorsDictionary(args[0])) {
      args = extractArgsFromSelectorsDictionary(args[0]);
    }
    const selectors = args.slice(0, args.length - 1);
    const projector = args[args.length - 1];
    const memoizedSelectors = selectors.filter((selector) => selector.release && typeof selector.release === "function");
    const memoizedProjector = memoize(function(...selectors2) {
      return projector.apply(null, selectors2);
    });
    const memoizedState = defaultMemoize(function(state, props2) {
      return options.stateFn.apply(null, [
        state,
        selectors,
        props2,
        memoizedProjector
      ]);
    });
    function release() {
      memoizedState.reset();
      memoizedProjector.reset();
      memoizedSelectors.forEach((selector) => selector.release());
    }
    return Object.assign(memoizedState.memoized, {
      release,
      projector: memoizedProjector.memoized,
      setResult: memoizedState.setResult,
      clearResult: memoizedState.clearResult
    });
  };
}
function createFeatureSelector(featureName) {
  return createSelector((state) => {
    const featureState = state[featureName];
    if (!isNgrxMockEnvironment() && (0, import_core.isDevMode)() && !(featureName in state)) {
      console.warn(`@ngrx/store: The feature name "${featureName}" does not exist in the state, therefore createFeatureSelector cannot access it.  Be sure it is imported in a loaded module using StoreModule.forRoot('${featureName}', ...) or StoreModule.forFeature('${featureName}', ...).  If the default state is intended to be undefined, as is the case with router state, this development-only warning message can be ignored.`);
    }
    return featureState;
  }, (featureState) => featureState);
}
function isSelectorsDictionary(selectors) {
  return !!selectors && typeof selectors === "object" && Object.values(selectors).every((selector) => typeof selector === "function");
}
function extractArgsFromSelectorsDictionary(selectorsDictionary) {
  const selectors = Object.values(selectorsDictionary);
  const resultKeys = Object.keys(selectorsDictionary);
  const projector = (...selectorResults) => resultKeys.reduce((result, key, index) => __spreadProps(__spreadValues({}, result), {
    [key]: selectorResults[index]
  }), {});
  return [...selectors, projector];
}
function createFeature(featureConfig) {
  const { name, reducer, extraSelectors: extraSelectorsFactory } = featureConfig;
  const featureSelector = createFeatureSelector(name);
  const nestedSelectors = createNestedSelectors(featureSelector, reducer);
  const baseSelectors = __spreadValues({
    [`select${capitalize(name)}State`]: featureSelector
  }, nestedSelectors);
  const extraSelectors = extraSelectorsFactory ? extraSelectorsFactory(baseSelectors) : {};
  return __spreadValues(__spreadValues({
    name,
    reducer
  }, baseSelectors), extraSelectors);
}
function createNestedSelectors(featureSelector, reducer) {
  const initialState = getInitialState(reducer);
  const nestedKeys = isPlainObject(initialState) ? Object.keys(initialState) : [];
  return nestedKeys.reduce((nestedSelectors, nestedKey) => __spreadProps(__spreadValues({}, nestedSelectors), {
    [`select${capitalize(nestedKey)}`]: createSelector(featureSelector, (parentState) => parentState == null ? void 0 : parentState[nestedKey])
  }), {});
}
function getInitialState(reducer) {
  return reducer(void 0, { type: "@ngrx/feature/init" });
}
function _createStoreReducers(reducers) {
  return reducers instanceof import_core.InjectionToken ? (0, import_core.inject)(reducers) : reducers;
}
function _createFeatureStore(configs, featureStores) {
  return featureStores.map((feat, index) => {
    if (configs[index] instanceof import_core.InjectionToken) {
      const conf = (0, import_core.inject)(configs[index]);
      return {
        key: feat.key,
        reducerFactory: conf.reducerFactory ? conf.reducerFactory : combineReducers,
        metaReducers: conf.metaReducers ? conf.metaReducers : [],
        initialState: conf.initialState
      };
    }
    return feat;
  });
}
function _createFeatureReducers(reducerCollection) {
  return reducerCollection.map((reducer) => {
    return reducer instanceof import_core.InjectionToken ? (0, import_core.inject)(reducer) : reducer;
  });
}
function _initialStateFactory(initialState) {
  if (typeof initialState === "function") {
    return initialState();
  }
  return initialState;
}
function _concatMetaReducers(metaReducers, userProvidedMetaReducers) {
  return metaReducers.concat(userProvidedMetaReducers);
}
function _provideForRootGuard() {
  const store = (0, import_core.inject)(Store, { optional: true, skipSelf: true });
  if (store) {
    throw new TypeError(`The root Store has been provided more than once. Feature modules should provide feature states instead.`);
  }
  return "guarded";
}
function immutabilityCheckMetaReducer(reducer, checks) {
  return function(state, action) {
    const act = checks.action(action) ? freeze(action) : action;
    const nextState = reducer(state, act);
    return checks.state() ? freeze(nextState) : nextState;
  };
}
function freeze(target) {
  Object.freeze(target);
  const targetIsFunction = isFunction(target);
  Object.getOwnPropertyNames(target).forEach((prop) => {
    if (prop.startsWith("\u0275")) {
      return;
    }
    if (hasOwnProperty(target, prop) && (targetIsFunction ? prop !== "caller" && prop !== "callee" && prop !== "arguments" : true)) {
      const propValue = target[prop];
      if ((isObjectLike(propValue) || isFunction(propValue)) && !Object.isFrozen(propValue)) {
        freeze(propValue);
      }
    }
  });
  return target;
}
function serializationCheckMetaReducer(reducer, checks) {
  return function(state, action) {
    if (checks.action(action)) {
      const unserializableAction = getUnserializable(action);
      throwIfUnserializable(unserializableAction, "action");
    }
    const nextState = reducer(state, action);
    if (checks.state()) {
      const unserializableState = getUnserializable(nextState);
      throwIfUnserializable(unserializableState, "state");
    }
    return nextState;
  };
}
function getUnserializable(target, path = []) {
  if ((isUndefined(target) || isNull(target)) && path.length === 0) {
    return {
      path: ["root"],
      value: target
    };
  }
  const keys = Object.keys(target);
  return keys.reduce((result, key) => {
    if (result) {
      return result;
    }
    const value = target[key];
    if (isComponent(value)) {
      return result;
    }
    if (isUndefined(value) || isNull(value) || isNumber(value) || isBoolean(value) || isString(value) || isArray(value)) {
      return false;
    }
    if (isPlainObject(value)) {
      return getUnserializable(value, [...path, key]);
    }
    return {
      path: [...path, key],
      value
    };
  }, false);
}
function throwIfUnserializable(unserializable, context) {
  if (unserializable === false) {
    return;
  }
  const unserializablePath = unserializable.path.join(".");
  const error = new Error(`Detected unserializable ${context} at "${unserializablePath}". ${RUNTIME_CHECK_URL}#strict${context}serializability`);
  error.value = unserializable.value;
  error.unserializablePath = unserializablePath;
  throw error;
}
function inNgZoneAssertMetaReducer(reducer, checks) {
  return function(state, action) {
    if (checks.action(action) && !i0.NgZone.isInAngularZone()) {
      throw new Error(`Action '${action.type}' running outside NgZone. ${RUNTIME_CHECK_URL}#strictactionwithinngzone`);
    }
    return reducer(state, action);
  };
}
function createActiveRuntimeChecks(runtimeChecks) {
  if ((0, import_core.isDevMode)()) {
    return __spreadValues({
      strictStateSerializability: false,
      strictActionSerializability: false,
      strictStateImmutability: true,
      strictActionImmutability: true,
      strictActionWithinNgZone: false,
      strictActionTypeUniqueness: false
    }, runtimeChecks);
  }
  return {
    strictStateSerializability: false,
    strictActionSerializability: false,
    strictStateImmutability: false,
    strictActionImmutability: false,
    strictActionWithinNgZone: false,
    strictActionTypeUniqueness: false
  };
}
function createSerializationCheckMetaReducer({ strictActionSerializability, strictStateSerializability }) {
  return (reducer) => strictActionSerializability || strictStateSerializability ? serializationCheckMetaReducer(reducer, {
    action: (action) => strictActionSerializability && !ignoreNgrxAction(action),
    state: () => strictStateSerializability
  }) : reducer;
}
function createImmutabilityCheckMetaReducer({ strictActionImmutability, strictStateImmutability }) {
  return (reducer) => strictActionImmutability || strictStateImmutability ? immutabilityCheckMetaReducer(reducer, {
    action: (action) => strictActionImmutability && !ignoreNgrxAction(action),
    state: () => strictStateImmutability
  }) : reducer;
}
function ignoreNgrxAction(action) {
  return action.type.startsWith("@ngrx");
}
function createInNgZoneCheckMetaReducer({ strictActionWithinNgZone }) {
  return (reducer) => strictActionWithinNgZone ? inNgZoneAssertMetaReducer(reducer, {
    action: (action) => strictActionWithinNgZone && !ignoreNgrxAction(action)
  }) : reducer;
}
function provideRuntimeChecks(runtimeChecks) {
  return [
    {
      provide: _USER_RUNTIME_CHECKS,
      useValue: runtimeChecks
    },
    {
      provide: USER_RUNTIME_CHECKS,
      useFactory: _runtimeChecksFactory,
      deps: [_USER_RUNTIME_CHECKS]
    },
    {
      provide: ACTIVE_RUNTIME_CHECKS,
      deps: [USER_RUNTIME_CHECKS],
      useFactory: createActiveRuntimeChecks
    },
    {
      provide: META_REDUCERS,
      multi: true,
      deps: [ACTIVE_RUNTIME_CHECKS],
      useFactory: createImmutabilityCheckMetaReducer
    },
    {
      provide: META_REDUCERS,
      multi: true,
      deps: [ACTIVE_RUNTIME_CHECKS],
      useFactory: createSerializationCheckMetaReducer
    },
    {
      provide: META_REDUCERS,
      multi: true,
      deps: [ACTIVE_RUNTIME_CHECKS],
      useFactory: createInNgZoneCheckMetaReducer
    }
  ];
}
function checkForActionTypeUniqueness() {
  return [
    {
      provide: _ACTION_TYPE_UNIQUENESS_CHECK,
      multi: true,
      deps: [ACTIVE_RUNTIME_CHECKS],
      useFactory: _actionTypeUniquenessCheck
    }
  ];
}
function _runtimeChecksFactory(runtimeChecks) {
  return runtimeChecks;
}
function _actionTypeUniquenessCheck(config) {
  if (!config.strictActionTypeUniqueness) {
    return;
  }
  const duplicates = Object.entries(REGISTERED_ACTION_TYPES).filter(([, registrations]) => registrations > 1).map(([type]) => type);
  if (duplicates.length) {
    throw new Error(`Action types are registered more than once, ${duplicates.map((type) => `"${type}"`).join(", ")}. ${RUNTIME_CHECK_URL}#strictactiontypeuniqueness`);
  }
}
function provideState(featureNameOrSlice, reducers, config = {}) {
  return (0, import_core.makeEnvironmentProviders)([
    ..._provideState(featureNameOrSlice, reducers, config),
    ENVIRONMENT_STATE_PROVIDER
  ]);
}
function _provideStore(reducers = {}, config = {}) {
  return [
    {
      provide: _ROOT_STORE_GUARD,
      useFactory: _provideForRootGuard
    },
    { provide: _INITIAL_STATE, useValue: config.initialState },
    {
      provide: INITIAL_STATE,
      useFactory: _initialStateFactory,
      deps: [_INITIAL_STATE]
    },
    { provide: _INITIAL_REDUCERS, useValue: reducers },
    {
      provide: _STORE_REDUCERS,
      useExisting: reducers instanceof import_core.InjectionToken ? reducers : _INITIAL_REDUCERS
    },
    {
      provide: INITIAL_REDUCERS,
      deps: [_INITIAL_REDUCERS, [new import_core.Inject(_STORE_REDUCERS)]],
      useFactory: _createStoreReducers
    },
    {
      provide: USER_PROVIDED_META_REDUCERS,
      useValue: config.metaReducers ? config.metaReducers : []
    },
    {
      provide: _RESOLVED_META_REDUCERS,
      deps: [META_REDUCERS, USER_PROVIDED_META_REDUCERS],
      useFactory: _concatMetaReducers
    },
    {
      provide: _REDUCER_FACTORY,
      useValue: config.reducerFactory ? config.reducerFactory : combineReducers
    },
    {
      provide: REDUCER_FACTORY,
      deps: [_REDUCER_FACTORY, _RESOLVED_META_REDUCERS],
      useFactory: createReducerFactory
    },
    ACTIONS_SUBJECT_PROVIDERS,
    REDUCER_MANAGER_PROVIDERS,
    SCANNED_ACTIONS_SUBJECT_PROVIDERS,
    STATE_PROVIDERS,
    STORE_PROVIDERS,
    provideRuntimeChecks(config.runtimeChecks),
    checkForActionTypeUniqueness()
  ];
}
function rootStoreProviderFactory() {
  (0, import_core.inject)(ActionsSubject);
  (0, import_core.inject)(ReducerObservable);
  (0, import_core.inject)(ScannedActionsSubject);
  (0, import_core.inject)(Store);
  (0, import_core.inject)(_ROOT_STORE_GUARD, { optional: true });
  (0, import_core.inject)(_ACTION_TYPE_UNIQUENESS_CHECK, { optional: true });
}
const ENVIRONMENT_STORE_PROVIDER = [
  { provide: ROOT_STORE_PROVIDER, useFactory: rootStoreProviderFactory },
  {
    provide: import_core.ENVIRONMENT_INITIALIZER,
    multi: true,
    useFactory() {
      return () => (0, import_core.inject)(ROOT_STORE_PROVIDER);
    }
  }
];
function provideStore(reducers, config) {
  return (0, import_core.makeEnvironmentProviders)([
    ..._provideStore(reducers, config),
    ENVIRONMENT_STORE_PROVIDER
  ]);
}
function featureStateProviderFactory() {
  (0, import_core.inject)(ROOT_STORE_PROVIDER);
  const features = (0, import_core.inject)(_STORE_FEATURES);
  const featureReducers = (0, import_core.inject)(FEATURE_REDUCERS);
  const reducerManager = (0, import_core.inject)(ReducerManager);
  (0, import_core.inject)(_ACTION_TYPE_UNIQUENESS_CHECK, { optional: true });
  const feats = features.map((feature, index) => {
    const featureReducerCollection = featureReducers.shift();
    const reducers = featureReducerCollection[index];
    return __spreadProps(__spreadValues({}, feature), {
      reducers,
      initialState: _initialStateFactory(feature.initialState)
    });
  });
  reducerManager.addFeatures(feats);
}
const ENVIRONMENT_STATE_PROVIDER = [
  {
    provide: FEATURE_STATE_PROVIDER,
    useFactory: featureStateProviderFactory
  },
  {
    provide: import_core.ENVIRONMENT_INITIALIZER,
    multi: true,
    useFactory() {
      return () => (0, import_core.inject)(FEATURE_STATE_PROVIDER);
    }
  }
];
function _provideState(featureNameOrSlice, reducers, config = {}) {
  return [
    {
      provide: _FEATURE_CONFIGS,
      multi: true,
      useValue: featureNameOrSlice instanceof Object ? {} : config
    },
    {
      provide: STORE_FEATURES,
      multi: true,
      useValue: {
        key: featureNameOrSlice instanceof Object ? featureNameOrSlice.name : featureNameOrSlice,
        reducerFactory: !(config instanceof import_core.InjectionToken) && config.reducerFactory ? config.reducerFactory : combineReducers,
        metaReducers: !(config instanceof import_core.InjectionToken) && config.metaReducers ? config.metaReducers : [],
        initialState: !(config instanceof import_core.InjectionToken) && config.initialState ? config.initialState : void 0
      }
    },
    {
      provide: _STORE_FEATURES,
      deps: [_FEATURE_CONFIGS, STORE_FEATURES],
      useFactory: _createFeatureStore
    },
    {
      provide: _FEATURE_REDUCERS,
      multi: true,
      useValue: featureNameOrSlice instanceof Object ? featureNameOrSlice.reducer : reducers
    },
    {
      provide: _FEATURE_REDUCERS_TOKEN,
      multi: true,
      useExisting: reducers instanceof import_core.InjectionToken ? reducers : _FEATURE_REDUCERS
    },
    {
      provide: FEATURE_REDUCERS,
      multi: true,
      deps: [_FEATURE_REDUCERS, [new import_core.Inject(_FEATURE_REDUCERS_TOKEN)]],
      useFactory: _createFeatureReducers
    },
    checkForActionTypeUniqueness()
  ];
}
const _StoreRootModule = class _StoreRootModule {
  constructor(actions$, reducer$, scannedActions$, store, guard, actionCheck) {
  }
};
_StoreRootModule.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _StoreRootModule, deps: [{ token: ActionsSubject }, { token: ReducerObservable }, { token: ScannedActionsSubject }, { token: Store }, { token: _ROOT_STORE_GUARD, optional: true }, { token: _ACTION_TYPE_UNIQUENESS_CHECK, optional: true }], target: i0.\u0275\u0275FactoryTarget.NgModule });
_StoreRootModule.\u0275mod = i0.\u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "18.0.0", ngImport: i0, type: _StoreRootModule });
_StoreRootModule.\u0275inj = i0.\u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _StoreRootModule });
let StoreRootModule = _StoreRootModule;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: StoreRootModule, decorators: [{
  type: import_core.NgModule,
  args: [{}]
}], ctorParameters: () => [{ type: ActionsSubject }, { type: ReducerObservable }, { type: ScannedActionsSubject }, { type: Store }, { type: void 0, decorators: [{
  type: import_core.Optional
}, {
  type: import_core.Inject,
  args: [_ROOT_STORE_GUARD]
}] }, { type: void 0, decorators: [{
  type: import_core.Optional
}, {
  type: import_core.Inject,
  args: [_ACTION_TYPE_UNIQUENESS_CHECK]
}] }] });
const _StoreFeatureModule = class _StoreFeatureModule {
  constructor(features, featureReducers, reducerManager, root, actionCheck) {
    this.features = features;
    this.featureReducers = featureReducers;
    this.reducerManager = reducerManager;
    const feats = features.map((feature, index) => {
      const featureReducerCollection = featureReducers.shift();
      const reducers = featureReducerCollection[index];
      return __spreadProps(__spreadValues({}, feature), {
        reducers,
        initialState: _initialStateFactory(feature.initialState)
      });
    });
    reducerManager.addFeatures(feats);
  }
  // eslint-disable-next-line @angular-eslint/contextual-lifecycle
  ngOnDestroy() {
    this.reducerManager.removeFeatures(this.features);
  }
};
_StoreFeatureModule.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _StoreFeatureModule, deps: [{ token: _STORE_FEATURES }, { token: FEATURE_REDUCERS }, { token: ReducerManager }, { token: StoreRootModule }, { token: _ACTION_TYPE_UNIQUENESS_CHECK, optional: true }], target: i0.\u0275\u0275FactoryTarget.NgModule });
_StoreFeatureModule.\u0275mod = i0.\u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "18.0.0", ngImport: i0, type: _StoreFeatureModule });
_StoreFeatureModule.\u0275inj = i0.\u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _StoreFeatureModule });
let StoreFeatureModule = _StoreFeatureModule;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: StoreFeatureModule, decorators: [{
  type: import_core.NgModule,
  args: [{}]
}], ctorParameters: () => [{ type: void 0, decorators: [{
  type: import_core.Inject,
  args: [_STORE_FEATURES]
}] }, { type: void 0, decorators: [{
  type: import_core.Inject,
  args: [FEATURE_REDUCERS]
}] }, { type: ReducerManager }, { type: StoreRootModule }, { type: void 0, decorators: [{
  type: import_core.Optional
}, {
  type: import_core.Inject,
  args: [_ACTION_TYPE_UNIQUENESS_CHECK]
}] }] });
const _StoreModule = class _StoreModule {
  static forRoot(reducers, config) {
    return {
      ngModule: StoreRootModule,
      providers: [..._provideStore(reducers, config)]
    };
  }
  static forFeature(featureNameOrSlice, reducers, config = {}) {
    return {
      ngModule: StoreFeatureModule,
      providers: [..._provideState(featureNameOrSlice, reducers, config)]
    };
  }
};
_StoreModule.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _StoreModule, deps: [], target: i0.\u0275\u0275FactoryTarget.NgModule });
_StoreModule.\u0275mod = i0.\u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "18.0.0", ngImport: i0, type: _StoreModule });
_StoreModule.\u0275inj = i0.\u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: _StoreModule });
let StoreModule = _StoreModule;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: StoreModule, decorators: [{
  type: import_core.NgModule,
  args: [{}]
}] });
function on(...args) {
  const reducer = args.pop();
  const types = args.map((creator) => creator.type);
  return { reducer, types };
}
function createReducer(initialState, ...ons) {
  const map2 = /* @__PURE__ */ new Map();
  for (const on2 of ons) {
    for (const type of on2.types) {
      const existingReducer = map2.get(type);
      if (existingReducer) {
        const newReducer = (state, action) => on2.reducer(existingReducer(state, action), action);
        map2.set(type, newReducer);
      } else {
        map2.set(type, on2.reducer);
      }
    }
  }
  return function(state = initialState, action) {
    const reducer = map2.get(action.type);
    return reducer ? reducer(state, action) : state;
  };
}
