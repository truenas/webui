3e5302c8f2046ceaf21b85357be2859a
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const _baseToString_js_1 = __importDefault(require("./_baseToString.js"));
const _castSlice_js_1 = __importDefault(require("./_castSlice.js"));
const _charsEndIndex_js_1 = __importDefault(require("./_charsEndIndex.js"));
const _stringToArray_js_1 = __importDefault(require("./_stringToArray.js"));
const toString_js_1 = __importDefault(require("./toString.js"));
const _trimmedEndIndex_js_1 = __importDefault(require("./_trimmedEndIndex.js"));
/**
 * Removes trailing whitespace or specified characters from `string`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to trim.
 * @param {string} [chars=whitespace] The characters to trim.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {string} Returns the trimmed string.
 * @example
 *
 * _.trimEnd('  abc  ');
 * // => '  abc'
 *
 * _.trimEnd('-_-abc-_-', '_-');
 * // => '-_-abc'
 */
function trimEnd(string, chars, guard) {
    string = (0, toString_js_1.default)(string);
    if (string && (guard || chars === undefined)) {
        return string.slice(0, (0, _trimmedEndIndex_js_1.default)(string) + 1);
    }
    if (!string || !(chars = (0, _baseToString_js_1.default)(chars))) {
        return string;
    }
    var strSymbols = (0, _stringToArray_js_1.default)(string), end = (0, _charsEndIndex_js_1.default)(strSymbols, (0, _stringToArray_js_1.default)(chars)) + 1;
    return (0, _castSlice_js_1.default)(strSymbols, 0, end).join('');
}
exports.default = trimEnd;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL21hY2Jvb2sva2FycG92LXdvcmsvVHJ1ZU5BUy93ZWJ1aS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RyaW1FbmQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSwwRUFBOEM7QUFDOUMsb0VBQXdDO0FBQ3hDLDRFQUFnRDtBQUNoRCw0RUFBZ0Q7QUFDaEQsZ0VBQXFDO0FBQ3JDLGdGQUFvRDtBQUVwRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBa0JHO0FBQ0gsU0FBUyxPQUFPLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxLQUFLO0lBQ25DLE1BQU0sR0FBRyxJQUFBLHFCQUFRLEVBQUMsTUFBTSxDQUFDLENBQUM7SUFDMUIsSUFBSSxNQUFNLElBQUksQ0FBQyxLQUFLLElBQUksS0FBSyxLQUFLLFNBQVMsQ0FBQyxFQUFFLENBQUM7UUFDN0MsT0FBTyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFBLDZCQUFlLEVBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDdEQsQ0FBQztJQUNELElBQUksQ0FBQyxNQUFNLElBQUksQ0FBQyxDQUFDLEtBQUssR0FBRyxJQUFBLDBCQUFZLEVBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQzlDLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFDRCxJQUFJLFVBQVUsR0FBRyxJQUFBLDJCQUFhLEVBQUMsTUFBTSxDQUFDLEVBQ2xDLEdBQUcsR0FBRyxJQUFBLDJCQUFhLEVBQUMsVUFBVSxFQUFFLElBQUEsMkJBQWEsRUFBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUU5RCxPQUFPLElBQUEsdUJBQVMsRUFBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUNoRCxDQUFDO0FBRUQsa0JBQWUsT0FBTyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNib29rL2thcnBvdi13b3JrL1RydWVOQVMvd2VidWkvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90cmltRW5kLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBiYXNlVG9TdHJpbmcgZnJvbSAnLi9fYmFzZVRvU3RyaW5nLmpzJztcbmltcG9ydCBjYXN0U2xpY2UgZnJvbSAnLi9fY2FzdFNsaWNlLmpzJztcbmltcG9ydCBjaGFyc0VuZEluZGV4IGZyb20gJy4vX2NoYXJzRW5kSW5kZXguanMnO1xuaW1wb3J0IHN0cmluZ1RvQXJyYXkgZnJvbSAnLi9fc3RyaW5nVG9BcnJheS5qcyc7XG5pbXBvcnQgdG9TdHJpbmcgZnJvbSAnLi90b1N0cmluZy5qcyc7XG5pbXBvcnQgdHJpbW1lZEVuZEluZGV4IGZyb20gJy4vX3RyaW1tZWRFbmRJbmRleC5qcyc7XG5cbi8qKlxuICogUmVtb3ZlcyB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50cmltRW5kKCcgIGFiYyAgJyk7XG4gKiAvLyA9PiAnICBhYmMnXG4gKlxuICogXy50cmltRW5kKCctXy1hYmMtXy0nLCAnXy0nKTtcbiAqIC8vID0+ICctXy1hYmMnXG4gKi9cbmZ1bmN0aW9uIHRyaW1FbmQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpICsgMSk7XG4gIH1cbiAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcbiAgICAgIGVuZCA9IGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgc3RyaW5nVG9BcnJheShjaGFycykpICsgMTtcblxuICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDAsIGVuZCkuam9pbignJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRyaW1FbmQ7XG4iXSwidmVyc2lvbiI6M30=