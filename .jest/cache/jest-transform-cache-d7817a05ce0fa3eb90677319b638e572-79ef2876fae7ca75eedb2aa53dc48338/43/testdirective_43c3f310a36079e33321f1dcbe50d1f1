7b99aafaec289602da99463b85004548
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestDirective = void 0;
const core_1 = require("@angular/core");
const lodash_es_1 = require("lodash-es");
const test_override_directive_1 = require("app/modules/test-id/test-override/test-override.directive");
/**
 * Adds test attribute to the element for the benefit of Release Engineering.
 * Prefer not to use test attributes in our unit tests.
 *
 * Usage:
 * Add some description to [ixTest]. Both string and array of strings are supported.
 * Do NOT add element type, in most cases it'll be added automatically.
 *
 * Examples:
 * <button ixTest="reset-settings">Reset Settings</button>
 * <input [ixTest]="formControl.name">
 * <mat-option [ixTest]="[formControl.name, option.label]"></mat-option>
 */
let TestDirective = class TestDirective {
    constructor(elementRef, overrideDirective) {
        this.elementRef = elementRef;
        this.overrideDirective = overrideDirective;
    }
    get normalizedDescription() {
        var _a, _b, _c;
        const description = (_b = (_a = this.overrideDirective) === null || _a === void 0 ? void 0 : _a.overrideDescription) !== null && _b !== void 0 ? _b : this.description;
        let normalizedDescription = Array.isArray(description) ? description : [description];
        normalizedDescription = normalizedDescription
            .filter((part) => part)
            .map((part) => (0, lodash_es_1.kebabCase)(String(part)));
        if ((_c = this.overrideDirective) === null || _c === void 0 ? void 0 : _c.keepLastPart) {
            const normalizedInitialDescription = Array.isArray(this.description) ? this.description : [this.description];
            normalizedDescription.push(normalizedInitialDescription[normalizedInitialDescription.length - 1]);
        }
        return normalizedDescription;
    }
    get attribute() {
        return [
            this.getElementType(),
            ...this.normalizedDescription,
        ]
            .filter((part) => part)
            .join('-');
    }
    getElementType() {
        const tagName = this.elementRef.nativeElement.tagName.toLowerCase();
        switch (tagName) {
            case 'tr':
                return 'row';
            case 'mat-slide-toggle':
                return 'toggle';
            case 'mat-checkbox':
            case 'mat-option':
            case 'mat-select':
            case 'mat-radio-group':
            case 'mat-radio-button':
            case 'mat-icon':
            case 'mat-row':
            case 'mat-slider':
            case 'mat-button-toggle-group':
            case 'mat-button-toggle':
                return tagName.replace('mat-', '');
            case 'input':
            case 'button':
            case 'select':
            case 'textarea':
            case 'table':
                return tagName;
            case 'a':
                return 'link';
            case 'ix-icon':
                return 'icon';
            case 'div':
            case 'p':
            case 'span':
                return 'text';
            case 'ix-date':
                return tagName.replace('ix-', '');
            default:
                throw new Error(`Unknown element type: ${tagName}`);
        }
    }
};
exports.TestDirective = TestDirective;
TestDirective.ctorParameters = () => [
    { type: core_1.ElementRef },
    { type: test_override_directive_1.TestOverrideDirective, decorators: [{ type: core_1.Optional }] }
];
TestDirective.propDecorators = {
    description: [{ type: core_1.Input, args: ['ixTest',] }],
    attribute: [{ type: core_1.HostBinding, args: ['attr.data-test',] }]
};
exports.TestDirective = TestDirective = __decorate([
    (0, core_1.Directive)({
        selector: '[ixTest]',
        standalone: true,
    })
], TestDirective);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL21hY2Jvb2sva2FycG92LXdvcmsvVHJ1ZU5BUy93ZWJ1aS9zcmMvYXBwL21vZHVsZXMvdGVzdC1pZC90ZXN0LmRpcmVjdGl2ZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSx3Q0FFdUI7QUFDdkIseUNBQXNDO0FBQ3RDLHVHQUFrRztBQUVsRzs7Ozs7Ozs7Ozs7O0dBWUc7QUFLSSxJQUFNLGFBQWEsR0FBbkIsTUFBTSxhQUFhO0lBR3hCLFlBQ1UsVUFBbUMsRUFDdkIsaUJBQXdDO1FBRHBELGVBQVUsR0FBVixVQUFVLENBQXlCO1FBQ3ZCLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBdUI7SUFDM0QsQ0FBQztJQUVKLElBQUkscUJBQXFCOztRQUN2QixNQUFNLFdBQVcsR0FBRyxNQUFBLE1BQUEsSUFBSSxDQUFDLGlCQUFpQiwwQ0FBRSxtQkFBbUIsbUNBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQztRQUNwRixJQUFJLHFCQUFxQixHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUVyRixxQkFBcUIsR0FBRyxxQkFBcUI7YUFDMUMsTUFBTSxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUM7YUFDdEIsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFBLHFCQUFTLEVBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUUxQyxJQUFJLE1BQUEsSUFBSSxDQUFDLGlCQUFpQiwwQ0FBRSxZQUFZLEVBQUUsQ0FBQztZQUN6QyxNQUFNLDRCQUE0QixHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUM3RyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsNEJBQTRCLENBQUMsNEJBQTRCLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDcEcsQ0FBQztRQUVELE9BQU8scUJBQWlDLENBQUM7SUFDM0MsQ0FBQztRQUdHLFNBQVM7UUFDWCxPQUFPO1lBQ0wsSUFBSSxDQUFDLGNBQWMsRUFBRTtZQUNyQixHQUFHLElBQUksQ0FBQyxxQkFBcUI7U0FDOUI7YUFDRSxNQUFNLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQzthQUN0QixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDZixDQUFDO0lBRU8sY0FBYztRQUNwQixNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLENBQUM7UUFFcEUsUUFBUSxPQUFPLEVBQUUsQ0FBQztZQUNoQixLQUFLLElBQUk7Z0JBQ1AsT0FBTyxLQUFLLENBQUM7WUFDZixLQUFLLGtCQUFrQjtnQkFDckIsT0FBTyxRQUFRLENBQUM7WUFDbEIsS0FBSyxjQUFjLENBQUM7WUFDcEIsS0FBSyxZQUFZLENBQUM7WUFDbEIsS0FBSyxZQUFZLENBQUM7WUFDbEIsS0FBSyxpQkFBaUIsQ0FBQztZQUN2QixLQUFLLGtCQUFrQixDQUFDO1lBQ3hCLEtBQUssVUFBVSxDQUFDO1lBQ2hCLEtBQUssU0FBUyxDQUFDO1lBQ2YsS0FBSyxZQUFZLENBQUM7WUFDbEIsS0FBSyx5QkFBeUIsQ0FBQztZQUMvQixLQUFLLG1CQUFtQjtnQkFDdEIsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQztZQUNyQyxLQUFLLE9BQU8sQ0FBQztZQUNiLEtBQUssUUFBUSxDQUFDO1lBQ2QsS0FBSyxRQUFRLENBQUM7WUFDZCxLQUFLLFVBQVUsQ0FBQztZQUNoQixLQUFLLE9BQU87Z0JBQ1YsT0FBTyxPQUFPLENBQUM7WUFDakIsS0FBSyxHQUFHO2dCQUNOLE9BQU8sTUFBTSxDQUFDO1lBQ2hCLEtBQUssU0FBUztnQkFDWixPQUFPLE1BQU0sQ0FBQztZQUNoQixLQUFLLEtBQUssQ0FBQztZQUNYLEtBQUssR0FBRyxDQUFDO1lBQ1QsS0FBSyxNQUFNO2dCQUNULE9BQU8sTUFBTSxDQUFDO1lBQ2hCLEtBQUssU0FBUztnQkFDWixPQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQ3BDO2dCQUNFLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLE9BQU8sRUFBRSxDQUFDLENBQUM7UUFDeEQsQ0FBQztJQUNILENBQUM7O0FBeEVVLHNDQUFhOzs7a0ZBS3JCLGVBQVE7OzswQkFKVixZQUFLLFNBQUMsUUFBUTt3QkF1QmQsa0JBQVcsU0FBQyxnQkFBZ0I7O3dCQXhCbEIsYUFBYTtJQUp6QixJQUFBLGdCQUFTLEVBQUM7UUFDVCxRQUFRLEVBQUUsVUFBVTtRQUNwQixVQUFVLEVBQUUsSUFBSTtLQUNqQixDQUFDO0dBQ1csYUFBYSxDQXlFekIiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL21hY2Jvb2sva2FycG92LXdvcmsvVHJ1ZU5BUy93ZWJ1aS9zcmMvYXBwL21vZHVsZXMvdGVzdC1pZC90ZXN0LmRpcmVjdGl2ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEhvc3RCaW5kaW5nLCBJbnB1dCwgT3B0aW9uYWwsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsga2ViYWJDYXNlIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IFRlc3RPdmVycmlkZURpcmVjdGl2ZSB9IGZyb20gJ2FwcC9tb2R1bGVzL3Rlc3QtaWQvdGVzdC1vdmVycmlkZS90ZXN0LW92ZXJyaWRlLmRpcmVjdGl2ZSc7XG5cbi8qKlxuICogQWRkcyB0ZXN0IGF0dHJpYnV0ZSB0byB0aGUgZWxlbWVudCBmb3IgdGhlIGJlbmVmaXQgb2YgUmVsZWFzZSBFbmdpbmVlcmluZy5cbiAqIFByZWZlciBub3QgdG8gdXNlIHRlc3QgYXR0cmlidXRlcyBpbiBvdXIgdW5pdCB0ZXN0cy5cbiAqXG4gKiBVc2FnZTpcbiAqIEFkZCBzb21lIGRlc2NyaXB0aW9uIHRvIFtpeFRlc3RdLiBCb3RoIHN0cmluZyBhbmQgYXJyYXkgb2Ygc3RyaW5ncyBhcmUgc3VwcG9ydGVkLlxuICogRG8gTk9UIGFkZCBlbGVtZW50IHR5cGUsIGluIG1vc3QgY2FzZXMgaXQnbGwgYmUgYWRkZWQgYXV0b21hdGljYWxseS5cbiAqXG4gKiBFeGFtcGxlczpcbiAqIDxidXR0b24gaXhUZXN0PVwicmVzZXQtc2V0dGluZ3NcIj5SZXNldCBTZXR0aW5nczwvYnV0dG9uPlxuICogPGlucHV0IFtpeFRlc3RdPVwiZm9ybUNvbnRyb2wubmFtZVwiPlxuICogPG1hdC1vcHRpb24gW2l4VGVzdF09XCJbZm9ybUNvbnRyb2wubmFtZSwgb3B0aW9uLmxhYmVsXVwiPjwvbWF0LW9wdGlvbj5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2l4VGVzdF0nLFxuICBzdGFuZGFsb25lOiB0cnVlLFxufSlcbmV4cG9ydCBjbGFzcyBUZXN0RGlyZWN0aXZlIHtcbiAgQElucHV0KCdpeFRlc3QnKSBkZXNjcmlwdGlvbjogbnVtYmVyIHwgc3RyaW5nIHwgKHN0cmluZyB8IG51bWJlcilbXTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+LFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgb3ZlcnJpZGVEaXJlY3RpdmU6IFRlc3RPdmVycmlkZURpcmVjdGl2ZSxcbiAgKSB7fVxuXG4gIGdldCBub3JtYWxpemVkRGVzY3JpcHRpb24oKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy5vdmVycmlkZURpcmVjdGl2ZT8ub3ZlcnJpZGVEZXNjcmlwdGlvbiA/PyB0aGlzLmRlc2NyaXB0aW9uO1xuICAgIGxldCBub3JtYWxpemVkRGVzY3JpcHRpb24gPSBBcnJheS5pc0FycmF5KGRlc2NyaXB0aW9uKSA/IGRlc2NyaXB0aW9uIDogW2Rlc2NyaXB0aW9uXTtcblxuICAgIG5vcm1hbGl6ZWREZXNjcmlwdGlvbiA9IG5vcm1hbGl6ZWREZXNjcmlwdGlvblxuICAgICAgLmZpbHRlcigocGFydCkgPT4gcGFydClcbiAgICAgIC5tYXAoKHBhcnQpID0+IGtlYmFiQ2FzZShTdHJpbmcocGFydCkpKTtcblxuICAgIGlmICh0aGlzLm92ZXJyaWRlRGlyZWN0aXZlPy5rZWVwTGFzdFBhcnQpIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJbml0aWFsRGVzY3JpcHRpb24gPSBBcnJheS5pc0FycmF5KHRoaXMuZGVzY3JpcHRpb24pID8gdGhpcy5kZXNjcmlwdGlvbiA6IFt0aGlzLmRlc2NyaXB0aW9uXTtcbiAgICAgIG5vcm1hbGl6ZWREZXNjcmlwdGlvbi5wdXNoKG5vcm1hbGl6ZWRJbml0aWFsRGVzY3JpcHRpb25bbm9ybWFsaXplZEluaXRpYWxEZXNjcmlwdGlvbi5sZW5ndGggLSAxXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWREZXNjcmlwdGlvbiBhcyBzdHJpbmdbXTtcbiAgfVxuXG4gIEBIb3N0QmluZGluZygnYXR0ci5kYXRhLXRlc3QnKVxuICBnZXQgYXR0cmlidXRlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHRoaXMuZ2V0RWxlbWVudFR5cGUoKSxcbiAgICAgIC4uLnRoaXMubm9ybWFsaXplZERlc2NyaXB0aW9uLFxuICAgIF1cbiAgICAgIC5maWx0ZXIoKHBhcnQpID0+IHBhcnQpXG4gICAgICAuam9pbignLScpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRFbGVtZW50VHlwZSgpOiBzdHJpbmcge1xuICAgIGNvbnN0IHRhZ05hbWUgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgcmV0dXJuICdyb3cnO1xuICAgICAgY2FzZSAnbWF0LXNsaWRlLXRvZ2dsZSc6XG4gICAgICAgIHJldHVybiAndG9nZ2xlJztcbiAgICAgIGNhc2UgJ21hdC1jaGVja2JveCc6XG4gICAgICBjYXNlICdtYXQtb3B0aW9uJzpcbiAgICAgIGNhc2UgJ21hdC1zZWxlY3QnOlxuICAgICAgY2FzZSAnbWF0LXJhZGlvLWdyb3VwJzpcbiAgICAgIGNhc2UgJ21hdC1yYWRpby1idXR0b24nOlxuICAgICAgY2FzZSAnbWF0LWljb24nOlxuICAgICAgY2FzZSAnbWF0LXJvdyc6XG4gICAgICBjYXNlICdtYXQtc2xpZGVyJzpcbiAgICAgIGNhc2UgJ21hdC1idXR0b24tdG9nZ2xlLWdyb3VwJzpcbiAgICAgIGNhc2UgJ21hdC1idXR0b24tdG9nZ2xlJzpcbiAgICAgICAgcmV0dXJuIHRhZ05hbWUucmVwbGFjZSgnbWF0LScsICcnKTtcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICByZXR1cm4gdGFnTmFtZTtcbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICByZXR1cm4gJ2xpbmsnO1xuICAgICAgY2FzZSAnaXgtaWNvbic6XG4gICAgICAgIHJldHVybiAnaWNvbic7XG4gICAgICBjYXNlICdkaXYnOlxuICAgICAgY2FzZSAncCc6XG4gICAgICBjYXNlICdzcGFuJzpcbiAgICAgICAgcmV0dXJuICd0ZXh0JztcbiAgICAgIGNhc2UgJ2l4LWRhdGUnOlxuICAgICAgICByZXR1cm4gdGFnTmFtZS5yZXBsYWNlKCdpeC0nLCAnJyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZWxlbWVudCB0eXBlOiAke3RhZ05hbWV9YCk7XG4gICAgfVxuICB9XG59XG4iXSwidmVyc2lvbiI6M30=