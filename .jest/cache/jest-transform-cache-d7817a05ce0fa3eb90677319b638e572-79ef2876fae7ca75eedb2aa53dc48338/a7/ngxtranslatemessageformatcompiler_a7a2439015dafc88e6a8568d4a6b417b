9b52467216c644bdd2b266b592dd30c9
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ngx_translate_messageformat_compiler_exports = {};
__export(ngx_translate_messageformat_compiler_exports, {
  MESSAGE_FORMAT_CONFIG: () => MESSAGE_FORMAT_CONFIG,
  TranslateMessageFormatCompiler: () => TranslateMessageFormatCompiler,
  TranslateMessageFormatDebugCompiler: () => TranslateMessageFormatDebugCompiler,
  defaultConfig: () => defaultConfig
});
module.exports = __toCommonJS(ngx_translate_messageformat_compiler_exports);
var i0 = __toESM(require("@angular/core"), 1);
var import_core = require("@angular/core");
var import_core2 = require("@ngx-translate/core");
var import_core3 = __toESM(require("@messageformat/core"), 1);
const MESSAGE_FORMAT_CONFIG = new import_core.InjectionToken("MESSAGE_FORMAT_CONFIG");
const defaultConfig = {
  biDiSupport: false,
  formatters: {},
  strictNumberSign: false,
  currency: "USD",
  strictPluralKeys: true,
  throwOnError: false,
  fallbackPrefix: void 0
};
const _TranslateMessageFormatCompiler = class _TranslateMessageFormatCompiler extends import_core2.TranslateCompiler {
  constructor(config) {
    super();
    this.mfCache = /* @__PURE__ */ new Map();
    const { formatters: customFormatters, biDiSupport, strictNumberSign: strict, currency, strictPluralKeys, throwOnError, fallbackPrefix } = __spreadValues(__spreadValues({}, defaultConfig), config);
    this.messageFormatOptions = {
      customFormatters,
      biDiSupport,
      strict,
      currency,
      strictPluralKeys
    };
    this.throwOnError = !!throwOnError;
    this.fallbackPrefix = fallbackPrefix;
  }
  compile(value, lang) {
    if (this.fallbackPrefix && value.startsWith(this.fallbackPrefix)) {
      return value.slice(this.fallbackPrefix.length);
    }
    let result;
    try {
      result = this.getMessageFormatInstance(lang).compile(value);
    } catch (err) {
      if (this.throwOnError) {
        throw err;
      }
      console.error(err);
      console.error(`[ngx-translate-messageformat-compiler] Could not compile message for lang '${lang}': '${value}'`);
      result = compileFallback(value, lang);
    }
    if (!this.throwOnError) {
      result = wrapInterpolationFunction(result, value);
    }
    return result;
  }
  compileTranslations(translations, lang) {
    if (typeof translations === "string") {
      return this.compile(translations, lang);
    }
    return Object.keys(translations).reduce((acc, key) => {
      const value = translations[key];
      acc[key] = this.compileTranslations(value, lang);
      return acc;
    }, {});
  }
  getMessageFormatInstance(locale) {
    if (!this.mfCache.has(locale)) {
      this.mfCache.set(locale, new import_core3.default(locale, this.messageFormatOptions));
    }
    return this.mfCache.get(locale);
  }
};
_TranslateMessageFormatCompiler.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: _TranslateMessageFormatCompiler, deps: [{ token: MESSAGE_FORMAT_CONFIG, optional: true }], target: i0.\u0275\u0275FactoryTarget.Injectable });
_TranslateMessageFormatCompiler.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: _TranslateMessageFormatCompiler });
let TranslateMessageFormatCompiler = _TranslateMessageFormatCompiler;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: TranslateMessageFormatCompiler, decorators: [{
  type: import_core.Injectable
}], ctorParameters: function() {
  return [{ type: void 0, decorators: [{
    type: import_core.Optional
  }, {
    type: import_core.Inject,
    args: [MESSAGE_FORMAT_CONFIG]
  }] }];
} });
function wrapInterpolationFunction(fn, message) {
  return (params) => {
    let result = message;
    try {
      result = fn(params);
    } catch (err) {
      console.error(err);
      console.error(`[ngx-translate-messageformat-compiler] Could not interpolate '${message}' with params '${params}'`);
    }
    return result;
  };
}
function compileFallback(message, lang) {
  return () => {
    console.warn(`[ngx-translate-messageformat-compiler] Falling back to original invalid message: '${message}' ('${lang}')`);
    return String(message);
  };
}
const log = (...message) => console.log(tag, ...message);
const tag = "[TranslateMessageFormatCompiler]";
const _TranslateMessageFormatDebugCompiler = class _TranslateMessageFormatDebugCompiler extends TranslateMessageFormatCompiler {
  compile(value, lang) {
    log(`COMPILE (${lang})`, value);
    const interpolationFn = super.compile(value, lang);
    return isFunction(interpolationFn) ? this.wrap(interpolationFn, value) : value;
  }
  compileTranslations(value, lang) {
    log(`COMPILE (${lang})`, value);
    return super.compileTranslations(value, lang);
  }
  wrap(fn, reference) {
    return (params) => {
      log("INTERPOLATE", reference, params);
      return fn(params);
    };
  }
};
_TranslateMessageFormatDebugCompiler.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: _TranslateMessageFormatDebugCompiler, deps: null, target: i0.\u0275\u0275FactoryTarget.Injectable });
_TranslateMessageFormatDebugCompiler.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: _TranslateMessageFormatDebugCompiler });
let TranslateMessageFormatDebugCompiler = _TranslateMessageFormatDebugCompiler;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: TranslateMessageFormatDebugCompiler, decorators: [{
  type: import_core.Injectable
}] });
function isFunction(value) {
  return typeof value === "function";
}
