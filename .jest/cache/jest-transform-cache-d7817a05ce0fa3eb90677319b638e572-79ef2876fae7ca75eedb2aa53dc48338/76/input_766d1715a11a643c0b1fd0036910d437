85e32f5d85198b1f9e8fc67da3f4756a
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var input_exports = {};
__export(input_exports, {
  MAT_INPUT_VALUE_ACCESSOR: () => MAT_INPUT_VALUE_ACCESSOR,
  MatError: () => import_form_field2.MatError,
  MatFormField: () => import_form_field2.MatFormField,
  MatHint: () => import_form_field2.MatHint,
  MatInput: () => MatInput,
  MatInputModule: () => MatInputModule,
  MatLabel: () => import_form_field2.MatLabel,
  MatPrefix: () => import_form_field2.MatPrefix,
  MatSuffix: () => import_form_field2.MatSuffix,
  getMatInputUnsupportedTypeError: () => getMatInputUnsupportedTypeError
});
module.exports = __toCommonJS(input_exports);
var import_coercion = require("@angular/cdk/coercion");
var i1 = __toESM(require("@angular/cdk/platform"), 1);
var import_platform = require("@angular/cdk/platform");
var i4 = __toESM(require("@angular/cdk/text-field"), 1);
var import_text_field = require("@angular/cdk/text-field");
var i0 = __toESM(require("@angular/core"), 1);
var import_core = require("@angular/core");
var i2 = __toESM(require("@angular/forms"), 1);
var import_forms = require("@angular/forms");
var i3 = __toESM(require("@angular/material/core"), 1);
var import_core2 = require("@angular/material/core");
var i5 = __toESM(require("@angular/material/form-field"), 1);
var import_form_field = require("@angular/material/form-field");
var import_form_field2 = require("@angular/material/form-field");
var import_rxjs = require("rxjs");
function getMatInputUnsupportedTypeError(type) {
  return Error(`Input type "${type}" isn't supported by matInput.`);
}
const MAT_INPUT_VALUE_ACCESSOR = new import_core.InjectionToken("MAT_INPUT_VALUE_ACCESSOR");
const MAT_INPUT_INVALID_TYPES = [
  "button",
  "checkbox",
  "file",
  "hidden",
  "image",
  "radio",
  "range",
  "reset",
  "submit"
];
let nextUniqueId = 0;
const _MatInput = class _MatInput {
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = (0, import_coercion.coerceBooleanProperty)(value);
    if (this.focused) {
      this.focused = false;
      this.stateChanges.next();
    }
  }
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  get id() {
    return this._id;
  }
  set id(value) {
    this._id = value || this._uid;
  }
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  get required() {
    var _a, _b, _c, _d;
    return (_d = (_c = this._required) != null ? _c : (_b = (_a = this.ngControl) == null ? void 0 : _a.control) == null ? void 0 : _b.hasValidator(import_forms.Validators.required)) != null ? _d : false;
  }
  set required(value) {
    this._required = (0, import_coercion.coerceBooleanProperty)(value);
  }
  /** Input type of the element. */
  get type() {
    return this._type;
  }
  set type(value) {
    this._type = value || "text";
    this._validateType();
    if (!this._isTextarea && (0, import_platform.getSupportedInputTypes)().has(this._type)) {
      this._elementRef.nativeElement.type = this._type;
    }
    this._ensureWheelDefaultBehavior();
  }
  /** An object used to control when error messages are shown. */
  get errorStateMatcher() {
    return this._errorStateTracker.matcher;
  }
  set errorStateMatcher(value) {
    this._errorStateTracker.matcher = value;
  }
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  get value() {
    return this._inputValueAccessor.value;
  }
  set value(value) {
    if (value !== this.value) {
      this._inputValueAccessor.value = value;
      this.stateChanges.next();
    }
  }
  /** Whether the element is readonly. */
  get readonly() {
    return this._readonly;
  }
  set readonly(value) {
    this._readonly = (0, import_coercion.coerceBooleanProperty)(value);
  }
  /** Whether the input is in an error state. */
  get errorState() {
    return this._errorStateTracker.errorState;
  }
  set errorState(value) {
    this._errorStateTracker.errorState = value;
  }
  constructor(_elementRef, _platform, ngControl, parentForm, parentFormGroup, defaultErrorStateMatcher, inputValueAccessor, _autofillMonitor, _ngZone, _formField) {
    this._elementRef = _elementRef;
    this._platform = _platform;
    this.ngControl = ngControl;
    this._autofillMonitor = _autofillMonitor;
    this._ngZone = _ngZone;
    this._formField = _formField;
    this._uid = `mat-input-${nextUniqueId++}`;
    this._webkitBlinkWheelListenerAttached = false;
    this.focused = false;
    this.stateChanges = new import_rxjs.Subject();
    this.controlType = "mat-input";
    this.autofilled = false;
    this._disabled = false;
    this._type = "text";
    this._readonly = false;
    this._neverEmptyInputTypes = [
      "date",
      "datetime",
      "datetime-local",
      "month",
      "time",
      "week"
    ].filter((t) => (0, import_platform.getSupportedInputTypes)().has(t));
    this._iOSKeyupListener = (event) => {
      const el = event.target;
      if (!el.value && el.selectionStart === 0 && el.selectionEnd === 0) {
        el.setSelectionRange(1, 1);
        el.setSelectionRange(0, 0);
      }
    };
    this._webkitBlinkWheelListener = () => {
    };
    const element = this._elementRef.nativeElement;
    const nodeName = element.nodeName.toLowerCase();
    this._inputValueAccessor = inputValueAccessor || element;
    this._previousNativeValue = this.value;
    this.id = this.id;
    if (_platform.IOS) {
      _ngZone.runOutsideAngular(() => {
        _elementRef.nativeElement.addEventListener("keyup", this._iOSKeyupListener);
      });
    }
    this._errorStateTracker = new import_core2._ErrorStateTracker(defaultErrorStateMatcher, ngControl, parentFormGroup, parentForm, this.stateChanges);
    this._isServer = !this._platform.isBrowser;
    this._isNativeSelect = nodeName === "select";
    this._isTextarea = nodeName === "textarea";
    this._isInFormField = !!_formField;
    if (this._isNativeSelect) {
      this.controlType = element.multiple ? "mat-native-select-multiple" : "mat-native-select";
    }
  }
  ngAfterViewInit() {
    if (this._platform.isBrowser) {
      this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe((event) => {
        this.autofilled = event.isAutofilled;
        this.stateChanges.next();
      });
    }
  }
  ngOnChanges() {
    this.stateChanges.next();
  }
  ngOnDestroy() {
    this.stateChanges.complete();
    if (this._platform.isBrowser) {
      this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);
    }
    if (this._platform.IOS) {
      this._elementRef.nativeElement.removeEventListener("keyup", this._iOSKeyupListener);
    }
    if (this._webkitBlinkWheelListenerAttached) {
      this._elementRef.nativeElement.removeEventListener("wheel", this._webkitBlinkWheelListener);
    }
  }
  ngDoCheck() {
    if (this.ngControl) {
      this.updateErrorState();
      if (this.ngControl.disabled !== null && this.ngControl.disabled !== this.disabled) {
        this.disabled = this.ngControl.disabled;
        this.stateChanges.next();
      }
    }
    this._dirtyCheckNativeValue();
    this._dirtyCheckPlaceholder();
  }
  /** Focuses the input. */
  focus(options) {
    this._elementRef.nativeElement.focus(options);
  }
  /** Refreshes the error state of the input. */
  updateErrorState() {
    this._errorStateTracker.updateErrorState();
  }
  /** Callback for the cases where the focused state of the input changes. */
  _focusChanged(isFocused) {
    if (isFocused !== this.focused) {
      this.focused = isFocused;
      this.stateChanges.next();
    }
  }
  _onInput() {
  }
  /** Does some manual dirty checking on the native input `value` property. */
  _dirtyCheckNativeValue() {
    const newValue = this._elementRef.nativeElement.value;
    if (this._previousNativeValue !== newValue) {
      this._previousNativeValue = newValue;
      this.stateChanges.next();
    }
  }
  /** Does some manual dirty checking on the native input `placeholder` attribute. */
  _dirtyCheckPlaceholder() {
    const placeholder = this._getPlaceholder();
    if (placeholder !== this._previousPlaceholder) {
      const element = this._elementRef.nativeElement;
      this._previousPlaceholder = placeholder;
      placeholder ? element.setAttribute("placeholder", placeholder) : element.removeAttribute("placeholder");
    }
  }
  /** Gets the current placeholder of the form field. */
  _getPlaceholder() {
    return this.placeholder || null;
  }
  /** Make sure the input is a supported type. */
  _validateType() {
    if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1 && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getMatInputUnsupportedTypeError(this._type);
    }
  }
  /** Checks whether the input type is one of the types that are never empty. */
  _isNeverEmpty() {
    return this._neverEmptyInputTypes.indexOf(this._type) > -1;
  }
  /** Checks whether the input is invalid based on the native validation. */
  _isBadInput() {
    let validity = this._elementRef.nativeElement.validity;
    return validity && validity.badInput;
  }
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  get empty() {
    return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() && !this.autofilled;
  }
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  get shouldLabelFloat() {
    if (this._isNativeSelect) {
      const selectElement = this._elementRef.nativeElement;
      const firstOption = selectElement.options[0];
      return this.focused || selectElement.multiple || !this.empty || !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label);
    } else {
      return this.focused || !this.empty;
    }
  }
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  setDescribedByIds(ids) {
    if (ids.length) {
      this._elementRef.nativeElement.setAttribute("aria-describedby", ids.join(" "));
    } else {
      this._elementRef.nativeElement.removeAttribute("aria-describedby");
    }
  }
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  onContainerClick() {
    if (!this.focused) {
      this.focus();
    }
  }
  /** Whether the form control is a native select that is displayed inline. */
  _isInlineSelect() {
    const element = this._elementRef.nativeElement;
    return this._isNativeSelect && (element.multiple || element.size > 1);
  }
  /**
   * In blink and webkit browsers a focused number input does not increment or decrement its value
   * on mouse wheel interaction unless a wheel event listener is attached to it or one of its ancestors or a passive wheel listener is attached somewhere in the DOM.
   * For example: Hitting a tooltip once enables the mouse wheel input for all number inputs as long as it exists.
   * In order to get reliable and intuitive behavior we apply a wheel event on our own
   * thus making sure increment and decrement by mouse wheel works every time.
   * @docs-private
   */
  _ensureWheelDefaultBehavior() {
    if (!this._webkitBlinkWheelListenerAttached && this._type === "number" && (this._platform.BLINK || this._platform.WEBKIT)) {
      this._ngZone.runOutsideAngular(() => {
        this._elementRef.nativeElement.addEventListener("wheel", this._webkitBlinkWheelListener);
      });
      this._webkitBlinkWheelListenerAttached = true;
    }
    if (this._webkitBlinkWheelListenerAttached && this._type !== "number") {
      this._elementRef.nativeElement.removeEventListener("wheel", this._webkitBlinkWheelListener);
      this._webkitBlinkWheelListenerAttached = true;
    }
  }
};
_MatInput.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _MatInput, deps: [{ token: i0.ElementRef }, { token: i1.Platform }, { token: i2.NgControl, optional: true, self: true }, { token: i2.NgForm, optional: true }, { token: i2.FormGroupDirective, optional: true }, { token: i3.ErrorStateMatcher }, { token: MAT_INPUT_VALUE_ACCESSOR, optional: true, self: true }, { token: i4.AutofillMonitor }, { token: i0.NgZone }, { token: import_form_field.MAT_FORM_FIELD, optional: true }], target: i0.\u0275\u0275FactoryTarget.Directive });
_MatInput.\u0275dir = i0.\u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "18.2.0-next.2", type: _MatInput, isStandalone: true, selector: "input[matInput], textarea[matInput], select[matNativeControl],\n      input[matNativeControl], textarea[matNativeControl]", inputs: { disabled: "disabled", id: "id", placeholder: "placeholder", name: "name", required: "required", type: "type", errorStateMatcher: "errorStateMatcher", userAriaDescribedBy: ["aria-describedby", "userAriaDescribedBy"], value: "value", readonly: "readonly" }, host: { listeners: { "focus": "_focusChanged(true)", "blur": "_focusChanged(false)", "input": "_onInput()" }, properties: { "class.mat-input-server": "_isServer", "class.mat-mdc-form-field-textarea-control": "_isInFormField && _isTextarea", "class.mat-mdc-form-field-input-control": "_isInFormField", "class.mdc-text-field__input": "_isInFormField", "class.mat-mdc-native-select-inline": "_isInlineSelect()", "id": "id", "disabled": "disabled", "required": "required", "attr.name": "name || null", "attr.readonly": "readonly && !_isNativeSelect || null", "attr.aria-invalid": "(empty && required) ? null : errorState", "attr.aria-required": "required", "attr.id": "id" }, classAttribute: "mat-mdc-input-element" }, providers: [{ provide: import_form_field.MatFormFieldControl, useExisting: _MatInput }], exportAs: ["matInput"], usesOnChanges: true, ngImport: i0 });
let MatInput = _MatInput;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: MatInput, decorators: [{
  type: import_core.Directive,
  args: [{
    selector: `input[matInput], textarea[matInput], select[matNativeControl],
      input[matNativeControl], textarea[matNativeControl]`,
    exportAs: "matInput",
    host: {
      "class": "mat-mdc-input-element",
      // The BaseMatInput parent class adds `mat-input-element`, `mat-form-field-control` and
      // `mat-form-field-autofill-control` to the CSS class list, but this should not be added for
      // this MDC equivalent input.
      "[class.mat-input-server]": "_isServer",
      "[class.mat-mdc-form-field-textarea-control]": "_isInFormField && _isTextarea",
      "[class.mat-mdc-form-field-input-control]": "_isInFormField",
      "[class.mdc-text-field__input]": "_isInFormField",
      "[class.mat-mdc-native-select-inline]": "_isInlineSelect()",
      // Native input properties that are overwritten by Angular inputs need to be synced with
      // the native input element. Otherwise property bindings for those don't work.
      "[id]": "id",
      "[disabled]": "disabled",
      "[required]": "required",
      "[attr.name]": "name || null",
      "[attr.readonly]": "readonly && !_isNativeSelect || null",
      // Only mark the input as invalid for assistive technology if it has a value since the
      // state usually overlaps with `aria-required` when the input is empty and can be redundant.
      "[attr.aria-invalid]": "(empty && required) ? null : errorState",
      "[attr.aria-required]": "required",
      // Native input properties that are overwritten by Angular inputs need to be synced with
      // the native input element. Otherwise property bindings for those don't work.
      "[attr.id]": "id",
      "(focus)": "_focusChanged(true)",
      "(blur)": "_focusChanged(false)",
      "(input)": "_onInput()"
    },
    providers: [{ provide: import_form_field.MatFormFieldControl, useExisting: MatInput }],
    standalone: true
  }]
}], ctorParameters: () => [{ type: i0.ElementRef }, { type: i1.Platform }, { type: i2.NgControl, decorators: [{
  type: import_core.Optional
}, {
  type: import_core.Self
}] }, { type: i2.NgForm, decorators: [{
  type: import_core.Optional
}] }, { type: i2.FormGroupDirective, decorators: [{
  type: import_core.Optional
}] }, { type: i3.ErrorStateMatcher }, { type: void 0, decorators: [{
  type: import_core.Optional
}, {
  type: import_core.Self
}, {
  type: import_core.Inject,
  args: [MAT_INPUT_VALUE_ACCESSOR]
}] }, { type: i4.AutofillMonitor }, { type: i0.NgZone }, { type: i5.MatFormField, decorators: [{
  type: import_core.Optional
}, {
  type: import_core.Inject,
  args: [import_form_field.MAT_FORM_FIELD]
}] }], propDecorators: { disabled: [{
  type: import_core.Input
}], id: [{
  type: import_core.Input
}], placeholder: [{
  type: import_core.Input
}], name: [{
  type: import_core.Input
}], required: [{
  type: import_core.Input
}], type: [{
  type: import_core.Input
}], errorStateMatcher: [{
  type: import_core.Input
}], userAriaDescribedBy: [{
  type: import_core.Input,
  args: ["aria-describedby"]
}], value: [{
  type: import_core.Input
}], readonly: [{
  type: import_core.Input
}] } });
const _MatInputModule = class _MatInputModule {
};
_MatInputModule.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _MatInputModule, deps: [], target: i0.\u0275\u0275FactoryTarget.NgModule });
_MatInputModule.\u0275mod = i0.\u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.0-next.2", ngImport: i0, type: _MatInputModule, imports: [import_core2.MatCommonModule, import_form_field.MatFormFieldModule, MatInput], exports: [MatInput, import_form_field.MatFormFieldModule, import_text_field.TextFieldModule, import_core2.MatCommonModule] });
_MatInputModule.\u0275inj = i0.\u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: _MatInputModule, imports: [import_core2.MatCommonModule, import_form_field.MatFormFieldModule, import_form_field.MatFormFieldModule, import_text_field.TextFieldModule, import_core2.MatCommonModule] });
let MatInputModule = _MatInputModule;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0-next.2", ngImport: i0, type: MatInputModule, decorators: [{
  type: import_core.NgModule,
  args: [{
    imports: [import_core2.MatCommonModule, import_form_field.MatFormFieldModule, MatInput],
    exports: [MatInput, import_form_field.MatFormFieldModule, import_text_field.TextFieldModule, import_core2.MatCommonModule]
  }]
}] });
