dc54ea46c43da1f2a7c8c6b0f3e466c3
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IxSlideInService = void 0;
const common_1 = require("@angular/common");
const core_1 = require("@angular/core");
const router_1 = require("@angular/router");
const until_destroy_1 = require("@ngneat/until-destroy");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const focus_service_1 = require("app/services/focus.service");
let IxSlideInService = class IxSlideInService {
    constructor(location, router, focusService) {
        this.location = location;
        this.router = router;
        this.focusService = focusService;
        this.slideInRefMap = new Map();
        /**
         * Emits when any slide in has been closed.
         * Prefer to use slideInClosed$ in slideInRef to tell when an individual slide in is closed.
         */
        this.onClose$ = new rxjs_1.Subject();
        this.closeOnNavigation();
    }
    get isSlideInOpen() {
        var _a;
        return (_a = this.slideInComponent) === null || _a === void 0 ? void 0 : _a.isSlideInOpen;
    }
    // TODO: Rework via cdk overlays or something else that would make it easier to use in tests.
    setSlideComponent(slideComponent) {
        this.slideInComponent = slideComponent;
    }
    open(component, params) {
        this.slideInRefMap.forEach((ref) => ref.close());
        const slideInRef = this.slideInComponent.openSlideIn(component, params);
        this.slideInRefMap.set(slideInRef.id, slideInRef);
        slideInRef.slideInClosed$.pipe((0, until_destroy_1.untilDestroyed)(this)).subscribe((response) => {
            this.deleteRef(slideInRef.id);
            if (response === undefined) {
                response = null;
            }
            this.onClose$.next(null);
        });
        this.focusService.captureCurrentFocus();
        this.focusOnTheCloseButton();
        return slideInRef;
    }
    closeLast() {
        if (!this.isSlideInOpen) {
            return;
        }
        const lastSlideInRef = Array.from(this.slideInRefMap.values()).pop();
        lastSlideInRef.close();
    }
    closeAll() {
        if (!this.isSlideInOpen) {
            return;
        }
        this.slideInRefMap.forEach((ref) => ref.close());
    }
    deleteRef(id) {
        this.slideInRefMap.delete(id);
        if (this.isSlideInOpen) {
            this.slideInComponent.closeSlideIn();
        }
        this.focusService.restoreFocus();
    }
    closeOnNavigation() {
        (0, rxjs_1.merge)(new rxjs_1.Observable((observer) => {
            this.location.subscribe((event) => {
                observer.next(event);
            });
        }), this.router.events.pipe((0, operators_1.filter)((event) => event instanceof router_1.NavigationEnd)))
            .pipe((0, until_destroy_1.untilDestroyed)(this))
            .subscribe(() => {
            this.closeAll();
        });
    }
    focusOnTheCloseButton() {
        (0, rxjs_1.timer)(100).pipe((0, operators_1.take)(1)).subscribe(() => this.focusService.focusElementById('ix-close-icon'));
    }
};
exports.IxSlideInService = IxSlideInService;
IxSlideInService.ctorParameters = () => [
    { type: common_1.Location },
    { type: router_1.Router },
    { type: focus_service_1.FocusService }
];
exports.IxSlideInService = IxSlideInService = __decorate([
    (0, until_destroy_1.UntilDestroy)(),
    (0, core_1.Injectable)({
        providedIn: 'root',
    })
], IxSlideInService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL21hY2Jvb2sva2FycG92LXdvcmsvVHJ1ZU5BUy93ZWJ1aS9zcmMvYXBwL3NlcnZpY2VzL2l4LXNsaWRlLWluLnNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsNENBQTJDO0FBQzNDLHdDQUEyRDtBQUMzRCw0Q0FBd0Q7QUFDeEQseURBQXFFO0FBQ3JFLCtCQUVjO0FBQ2QsOENBQThDO0FBRzlDLDhEQUEwRDtBQU1uRCxJQUFNLGdCQUFnQixHQUF0QixNQUFNLGdCQUFnQjtJQVMzQixZQUNVLFFBQWtCLEVBQ2xCLE1BQWMsRUFDZCxZQUEwQjtRQUYxQixhQUFRLEdBQVIsUUFBUSxDQUFVO1FBQ2xCLFdBQU0sR0FBTixNQUFNLENBQVE7UUFDZCxpQkFBWSxHQUFaLFlBQVksQ0FBYztRQVZwQyxrQkFBYSxHQUFHLElBQUksR0FBRyxFQUFpQyxDQUFDO1FBQ3pEOzs7V0FHRztRQUNNLGFBQVEsR0FBRyxJQUFJLGNBQU8sRUFBUSxDQUFDO1FBT3RDLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO0lBQzNCLENBQUM7SUFFRCxJQUFJLGFBQWE7O1FBQ2YsT0FBTyxNQUFBLElBQUksQ0FBQyxnQkFBZ0IsMENBQUUsYUFBYSxDQUFDO0lBQzlDLENBQUM7SUFFRCw2RkFBNkY7SUFDN0YsaUJBQWlCLENBQUMsY0FBa0M7UUFDbEQsSUFBSSxDQUFDLGdCQUFnQixHQUFHLGNBQWMsQ0FBQztJQUN6QyxDQUFDO0lBRUQsSUFBSSxDQUNGLFNBQWtCLEVBQ2xCLE1BQTBEO1FBRTFELElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUVqRCxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxDQUFPLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUM5RSxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsRUFBRSxFQUFF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VXNlcnMvbWFjYm9vay9rYXJwb3Ytd29yay9UcnVlTkFTL3dlYnVpL3NyYy9hcHAvc2VydmljZXMvaXgtc2xpZGUtaW4uc2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMb2NhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3RvciwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmF2aWdhdGlvbkVuZCwgUm91dGVyIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IFVudGlsRGVzdHJveSwgdW50aWxEZXN0cm95ZWQgfSBmcm9tICdAbmduZWF0L3VudGlsLWRlc3Ryb3knO1xuaW1wb3J0IHtcbiAgbWVyZ2UsIE9ic2VydmFibGUsIFN1YmplY3QsIHRpbWVyLFxufSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciwgdGFrZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEl4U2xpZGVJblJlZiB9IGZyb20gJ2FwcC9tb2R1bGVzL2Zvcm1zL2l4LWZvcm1zL2NvbXBvbmVudHMvaXgtc2xpZGUtaW4vaXgtc2xpZGUtaW4tcmVmJztcbmltcG9ydCB7IEl4U2xpZGVJbkNvbXBvbmVudCB9IGZyb20gJ2FwcC9tb2R1bGVzL2Zvcm1zL2l4LWZvcm1zL2NvbXBvbmVudHMvaXgtc2xpZGUtaW4vaXgtc2xpZGUtaW4uY29tcG9uZW50JztcbmltcG9ydCB7IEZvY3VzU2VydmljZSB9IGZyb20gJ2FwcC9zZXJ2aWNlcy9mb2N1cy5zZXJ2aWNlJztcblxuQFVudGlsRGVzdHJveSgpXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgSXhTbGlkZUluU2VydmljZSB7XG4gIHNsaWRlSW5Db21wb25lbnQ6IEl4U2xpZGVJbkNvbXBvbmVudDtcbiAgc2xpZGVJblJlZk1hcCA9IG5ldyBNYXA8c3RyaW5nLCBJeFNsaWRlSW5SZWY8dW5rbm93bj4+KCk7XG4gIC8qKlxuICAgKiBFbWl0cyB3aGVuIGFueSBzbGlkZSBpbiBoYXMgYmVlbiBjbG9zZWQuXG4gICAqIFByZWZlciB0byB1c2Ugc2xpZGVJbkNsb3NlZCQgaW4gc2xpZGVJblJlZiB0byB0ZWxsIHdoZW4gYW4gaW5kaXZpZHVhbCBzbGlkZSBpbiBpcyBjbG9zZWQuXG4gICAqL1xuICByZWFkb25seSBvbkNsb3NlJCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBsb2NhdGlvbjogTG9jYXRpb24sXG4gICAgcHJpdmF0ZSByb3V0ZXI6IFJvdXRlcixcbiAgICBwcml2YXRlIGZvY3VzU2VydmljZTogRm9jdXNTZXJ2aWNlLFxuICApIHtcbiAgICB0aGlzLmNsb3NlT25OYXZpZ2F0aW9uKCk7XG4gIH1cblxuICBnZXQgaXNTbGlkZUluT3BlbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zbGlkZUluQ29tcG9uZW50Py5pc1NsaWRlSW5PcGVuO1xuICB9XG5cbiAgLy8gVE9ETzogUmV3b3JrIHZpYSBjZGsgb3ZlcmxheXMgb3Igc29tZXRoaW5nIGVsc2UgdGhhdCB3b3VsZCBtYWtlIGl0IGVhc2llciB0byB1c2UgaW4gdGVzdHMuXG4gIHNldFNsaWRlQ29tcG9uZW50KHNsaWRlQ29tcG9uZW50OiBJeFNsaWRlSW5Db21wb25lbnQpOiB2b2lkIHtcbiAgICB0aGlzLnNsaWRlSW5Db21wb25lbnQgPSBzbGlkZUNvbXBvbmVudDtcbiAgfVxuXG4gIG9wZW48VCwgRD4oXG4gICAgY29tcG9uZW50OiBUeXBlPFQ+LFxuICAgIHBhcmFtcz86IHsgd2lkZT86IGJvb2xlYW47IGRhdGE/OiBEOyBpbmplY3Rvcj86IEluamVjdG9yIH0sXG4gICk6IEl4U2xpZGVJblJlZjxULCBEPiB7XG4gICAgdGhpcy5zbGlkZUluUmVmTWFwLmZvckVhY2goKHJlZikgPT4gcmVmLmNsb3NlKCkpO1xuXG4gICAgY29uc3Qgc2xpZGVJblJlZiA9IHRoaXMuc2xpZGVJbkNvbXBvbmVudC5vcGVuU2xpZGVJbjxULCBEPihjb21wb25lbnQsIHBhcmFtcyk7XG4gICAgdGhpcy5zbGlkZUluUmVmTWFwLnNldChzbGlkZUluUmVmLmlkLCBzbGlkZUluUmVmKTtcbiAgICBzbGlkZUluUmVmLnNsaWRlSW5DbG9zZWQkLnBpcGUodW50aWxEZXN0cm95ZWQodGhpcykpLnN1YnNjcmliZSgocmVzcG9uc2U/OiBEKSA9PiB7XG4gICAgICB0aGlzLmRlbGV0ZVJlZihzbGlkZUluUmVmLmlkKTtcbiAgICAgIGlmIChyZXNwb25zZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3BvbnNlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMub25DbG9zZSQubmV4dChudWxsKTtcbiAgICB9KTtcblxuICAgIHRoaXMuZm9jdXNTZXJ2aWNlLmNhcHR1cmVDdXJyZW50Rm9jdXMoKTtcbiAgICB0aGlzLmZvY3VzT25UaGVDbG9zZUJ1dHRvbigpO1xuXG4gICAgcmV0dXJuIHNsaWRlSW5SZWY7XG4gIH1cblxuICBjbG9zZUxhc3QoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzU2xpZGVJbk9wZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBsYXN0U2xpZGVJblJlZiA9IEFycmF5LmZyb20odGhpcy5zbGlkZUluUmVmTWFwLnZhbHVlcygpKS5wb3AoKTtcbiAgICBsYXN0U2xpZGVJblJlZi5jbG9zZSgpO1xuICB9XG5cbiAgY2xvc2VBbGwoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzU2xpZGVJbk9wZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNsaWRlSW5SZWZNYXAuZm9yRWFjaCgocmVmKSA9PiByZWYuY2xvc2UoKSk7XG4gIH1cblxuICBkZWxldGVSZWYoaWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuc2xpZGVJblJlZk1hcC5kZWxldGUoaWQpO1xuXG4gICAgaWYgKHRoaXMuaXNTbGlkZUluT3Blbikge1xuICAgICAgdGhpcy5zbGlkZUluQ29tcG9uZW50LmNsb3NlU2xpZGVJbigpO1xuICAgIH1cblxuICAgIHRoaXMuZm9jdXNTZXJ2aWNlLnJlc3RvcmVGb2N1cygpO1xuICB9XG5cbiAgcHJpdmF0ZSBjbG9zZU9uTmF2aWdhdGlvbigpOiB2b2lkIHtcbiAgICBtZXJnZShcbiAgICAgIG5ldyBPYnNlcnZhYmxlKChvYnNlcnZlcikgPT4ge1xuICAgICAgICB0aGlzLmxvY2F0aW9uLnN1YnNjcmliZSgoZXZlbnQpID0+IHtcbiAgICAgICAgICBvYnNlcnZlci5uZXh0KGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIHRoaXMucm91dGVyLmV2ZW50cy5waXBlKGZpbHRlcigoZXZlbnQpID0+IGV2ZW50IGluc3RhbmNlb2YgTmF2aWdhdGlvbkVuZCkpLFxuICAgIClcbiAgICAgIC5waXBlKHVudGlsRGVzdHJveWVkKHRoaXMpKVxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xvc2VBbGwoKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBmb2N1c09uVGhlQ2xvc2VCdXR0b24oKTogdm9pZCB7XG4gICAgdGltZXIoMTAwKS5waXBlKHRha2UoMSkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLmZvY3VzU2VydmljZS5mb2N1c0VsZW1lbnRCeUlkKCdpeC1jbG9zZS1pY29uJykpO1xuICB9XG59XG4iXSwidmVyc2lvbiI6M30=