386591f2222a6e22bf2f9ce82a61fc96
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const jest_1 = require("@ngneat/spectator/jest");
const store_1 = require("@ngrx/store");
const rxjs_1 = require("rxjs");
const locale_service_1 = require("app/services/locale.service");
const preferences_selectors_1 = require("app/store/preferences/preferences.selectors");
const system_config_selectors_1 = require("app/store/system-config/system-config.selectors");
describe('LocaleService', () => {
    let spectator;
    let service;
    const createService = (0, jest_1.createServiceFactory)({
        service: locale_service_1.LocaleService,
        mocks: [store_1.Store],
    });
    beforeEach(() => {
        spectator = createService();
        service = spectator.service;
        const store$ = spectator.inject(store_1.Store);
        store$.select.mockImplementation((selector) => {
            if (selector === system_config_selectors_1.selectTimezone) {
                return (0, rxjs_1.of)('UTC');
            }
            if (selector === preferences_selectors_1.waitForPreferences) {
                return (0, rxjs_1.of)({ dateFormat: 'yyyy-MM-dd', timeFormat: 'HH:mm:ss' });
            }
            return (0, rxjs_1.of)(null);
        });
        jest.useFakeTimers().setSystemTime(new Date('2024-08-14T14:14:27Z'));
    });
    afterEach(() => {
        jest.useRealTimers();
    });
    describe('getDateFormatOptions', () => {
        it('should return correct date format options for default timezone', () => {
            const options = service.getDateFormatOptions();
            expect(options).toEqual([
                { label: '2024-08-14', value: 'yyyy-MM-dd' },
                { label: 'August 14, 2024', value: 'MMMM d, yyyy' },
                { label: '14 August, 2024', value: 'd MMMM, yyyy' },
                { label: 'Aug 14, 2024', value: 'MMM d, yyyy' },
                { label: '14 Aug 2024', value: 'd MMM yyyy' },
                { label: '08/14/2024', value: 'MM/dd/yyyy' },
                { label: '14/08/2024', value: 'dd/MM/yyyy' },
                { label: '14.08.2024', value: 'dd.MM.yyyy' },
            ]);
        });
    });
    describe('getTimeFormatOptions', () => {
        it('should return correct time format options for default timezone', () => {
            const options = service.getTimeFormatOptions();
            expect(options).toEqual([
                { label: '17:14:27 (24 Hours)', value: 'HH:mm:ss' },
                { label: '05:14:27 pm', value: "hh:mm:ss aaaaa'm'" },
                { label: '05:14:27 PM', value: 'hh:mm:ss aa' },
            ]);
        });
    });
    describe('getDateFromString', () => {
        it('should correctly parse a valid date string with default timezone', () => {
            const date = service.getDateFromString('14/08/2024 02:00:00');
            expect(date.toISOString()).toBe('2024-08-13T23:00:00.000Z');
        });
        it('should correctly parse a valid date string with another format with default timezone', () => {
            const date = service.getDateFromString('14.08.2024 02:00:00');
            expect(date.toISOString()).toBe('2024-08-13T23:00:00.000Z');
        });
        it('should throw an error for an invalid date string', () => {
            expect(() => service.getDateFromString('invalid date')).toThrow('Invalid date format: invalid date');
        });
    });
    describe('getPreferredDateFormat', () => {
        it('should return the preferred date format', () => {
            expect(service.getPreferredDateFormat()).toBe('yyyy-MM-dd');
        });
    });
    describe('getPreferredTimeFormat', () => {
        it('should return the preferred time format', () => {
            expect(service.getPreferredTimeFormat()).toBe('HH:mm:ss');
        });
    });
    describe('getDateAndTime', () => {
        it('should return the correct date and time for default timezone', () => {
            const [date, time] = service.getDateAndTime();
            expect(date).toBe('2024-08-14');
            expect(time).toBe('17:14:27');
        });
        it('should return the correct date and time for a specified timezone', () => {
            const [date, time] = service.getDateAndTime('Europe/Kiev');
            expect(date).toBe('2024-08-14');
            expect(time).toBe('17:14:27');
        });
    });
    describe('formatDateTimeToDateFns', () => {
        it('should correctly format date-time string to date-fns format', () => {
            const formatted = service.formatDateTimeToDateFns('YYYY-MM-DD A');
            expect(formatted).toBe('yyyy-MM-dd aa');
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL21hY2Jvb2sva2FycG92LXdvcmsvVHJ1ZU5BUy93ZWJ1aS9zcmMvYXBwL3NlcnZpY2VzL2xvY2FsZS5zZXJ2aWNlLnNwZWMudHMiLCJtYXBwaW5ncyI6Ijs7QUFBQSxpREFBZ0Y7QUFDaEYsdUNBQW9DO0FBQ3BDLCtCQUEwQjtBQUMxQixnRUFBNEQ7QUFDNUQsdUZBQWlGO0FBQ2pGLDZGQUFpRjtBQUVqRixRQUFRLENBQUMsZUFBZSxFQUFFLEdBQUcsRUFBRTtJQUM3QixJQUFJLFNBQTBDLENBQUM7SUFDL0MsSUFBSSxPQUFzQixDQUFDO0lBRTNCLE1BQU0sYUFBYSxHQUFHLElBQUEsMkJBQW9CLEVBQUM7UUFDekMsT0FBTyxFQUFFLDhCQUFhO1FBQ3RCLEtBQUssRUFBRSxDQUFDLGFBQUssQ0FBQztLQUNmLENBQUMsQ0FBQztJQUVILFVBQVUsQ0FBQyxHQUFHLEVBQUU7UUFDZCxTQUFTLEdBQUcsYUFBYSxFQUFFLENBQUM7UUFDNUIsT0FBTyxHQUFHLFNBQVMsQ0FBQyxPQUFPLENBQUM7UUFFNUIsTUFBTSxNQUFNLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQyxhQUFLLENBQUMsQ0FBQztRQUN2QyxNQUFNLENBQUMsTUFBTSxDQUFDLGtCQUFrQixDQUFDLENBQUMsUUFBaUIsRUFBRSxFQUFFO1lBQ3JELElBQUksUUFBUSxLQUFLLHdDQUFjLEVBQUUsQ0FBQztnQkFDaEMsT0FBTyxJQUFBLFNBQUUsRUFBQyxLQUFLLENBQUMsQ0FBQztZQUNuQixDQUFDO1lBRUQsSUFBSSxRQUFRLEtBQUssMENBQWtCLEVBQUUsQ0FBQztnQkFDcEMsT0FBTyxJQUFBLFNBQUUsRUFBQyxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxDQUFDLENBQUM7WUFDbEUsQ0FBQztZQUVELE9BQU8sSUFBQSxTQUFFLEVBQUMsSUFBSSxDQUFDLENBQUM7UUFDbEIsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsYUFBYSxDQUFDLElBQUks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RTtRQUN2QyxFQUFFLENBQUMsNkRBQTZELEVBQUUsR0FBRyxFQUFFO1lBQ3JFLE1BQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUNsRSxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBQzFDLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvbWFjYm9vay9rYXJwb3Ytd29yay9UcnVlTkFTL3dlYnVpL3NyYy9hcHAvc2VydmljZXMvbG9jYWxlLnNlcnZpY2Uuc3BlYy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTcGVjdGF0b3JTZXJ2aWNlLCBjcmVhdGVTZXJ2aWNlRmFjdG9yeSB9IGZyb20gJ0BuZ25lYXQvc3BlY3RhdG9yL2plc3QnO1xuaW1wb3J0IHsgU3RvcmUgfSBmcm9tICdAbmdyeC9zdG9yZSc7XG5pbXBvcnQgeyBvZiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTG9jYWxlU2VydmljZSB9IGZyb20gJ2FwcC9zZXJ2aWNlcy9sb2NhbGUuc2VydmljZSc7XG5pbXBvcnQgeyB3YWl0Rm9yUHJlZmVyZW5jZXMgfSBmcm9tICdhcHAvc3RvcmUvcHJlZmVyZW5jZXMvcHJlZmVyZW5jZXMuc2VsZWN0b3JzJztcbmltcG9ydCB7IHNlbGVjdFRpbWV6b25lIH0gZnJvbSAnYXBwL3N0b3JlL3N5c3RlbS1jb25maWcvc3lzdGVtLWNvbmZpZy5zZWxlY3RvcnMnO1xuXG5kZXNjcmliZSgnTG9jYWxlU2VydmljZScsICgpID0+IHtcbiAgbGV0IHNwZWN0YXRvcjogU3BlY3RhdG9yU2VydmljZTxMb2NhbGVTZXJ2aWNlPjtcbiAgbGV0IHNlcnZpY2U6IExvY2FsZVNlcnZpY2U7XG5cbiAgY29uc3QgY3JlYXRlU2VydmljZSA9IGNyZWF0ZVNlcnZpY2VGYWN0b3J5KHtcbiAgICBzZXJ2aWNlOiBMb2NhbGVTZXJ2aWNlLFxuICAgIG1vY2tzOiBbU3RvcmVdLFxuICB9KTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBzcGVjdGF0b3IgPSBjcmVhdGVTZXJ2aWNlKCk7XG4gICAgc2VydmljZSA9IHNwZWN0YXRvci5zZXJ2aWNlO1xuXG4gICAgY29uc3Qgc3RvcmUkID0gc3BlY3RhdG9yLmluamVjdChTdG9yZSk7XG4gICAgc3RvcmUkLnNlbGVjdC5tb2NrSW1wbGVtZW50YXRpb24oKHNlbGVjdG9yOiB1bmtub3duKSA9PiB7XG4gICAgICBpZiAoc2VsZWN0b3IgPT09IHNlbGVjdFRpbWV6b25lKSB7XG4gICAgICAgIHJldHVybiBvZignVVRDJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3RvciA9PT0gd2FpdEZvclByZWZlcmVuY2VzKSB7XG4gICAgICAgIHJldHVybiBvZih7IGRhdGVGb3JtYXQ6ICd5eXl5LU1NLWRkJywgdGltZUZvcm1hdDogJ0hIOm1tOnNzJyB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9mKG51bGwpO1xuICAgIH0pO1xuXG4gICAgamVzdC51c2VGYWtlVGltZXJzKCkuc2V0U3lzdGVtVGltZShuZXcgRGF0ZSgnMjAyNC0wOC0xNFQxNDoxNDoyN1onKSk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgamVzdC51c2VSZWFsVGltZXJzKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZXREYXRlRm9ybWF0T3B0aW9ucycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiBjb3JyZWN0IGRhdGUgZm9ybWF0IG9wdGlvbnMgZm9yIGRlZmF1bHQgdGltZXpvbmUnLCAoKSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zID0gc2VydmljZS5nZXREYXRlRm9ybWF0T3B0aW9ucygpO1xuICAgICAgZXhwZWN0KG9wdGlvbnMpLnRvRXF1YWwoW1xuICAgICAgICB7IGxhYmVsOiAnMjAyNC0wOC0xNCcsIHZhbHVlOiAneXl5eS1NTS1kZCcgfSxcbiAgICAgICAgeyBsYWJlbDogJ0F1Z3VzdCAxNCwgMjAyNCcsIHZhbHVlOiAnTU1NTSBkLCB5eXl5JyB9LFxuICAgICAgICB7IGxhYmVsOiAnMTQgQXVndXN0LCAyMDI0JywgdmFsdWU6ICdkIE1NTU0sIHl5eXknIH0sXG4gICAgICAgIHsgbGFiZWw6ICdBdWcgMTQsIDIwMjQnLCB2YWx1ZTogJ01NTSBkLCB5eXl5JyB9LFxuICAgICAgICB7IGxhYmVsOiAnMTQgQXVnIDIwMjQnLCB2YWx1ZTogJ2QgTU1NIHl5eXknIH0sXG4gICAgICAgIHsgbGFiZWw6ICcwOC8xNC8yMDI0JywgdmFsdWU6ICdNTS9kZC95eXl5JyB9LFxuICAgICAgICB7IGxhYmVsOiAnMTQvMDgvMjAyNCcsIHZhbHVlOiAnZGQvTU0veXl5eScgfSxcbiAgICAgICAgeyBsYWJlbDogJzE0LjA4LjIwMjQnLCB2YWx1ZTogJ2RkLk1NLnl5eXknIH0sXG4gICAgICBdKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldFRpbWVGb3JtYXRPcHRpb25zJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIGNvcnJlY3QgdGltZSBmb3JtYXQgb3B0aW9ucyBmb3IgZGVmYXVsdCB0aW1lem9uZScsICgpID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBzZXJ2aWNlLmdldFRpbWVGb3JtYXRPcHRpb25zKCk7XG4gICAgICBleHBlY3Qob3B0aW9ucykudG9FcXVhbChbXG4gICAgICAgIHsgbGFiZWw6ICcxNzoxNDoyNyAoMjQgSG91cnMpJywgdmFsdWU6ICdISDptbTpzcycgfSxcbiAgICAgICAgeyBsYWJlbDogJzA1OjE0OjI3IHBtJywgdmFsdWU6IFwiaGg6bW06c3MgYWFhYWEnbSdcIiB9LFxuICAgICAgICB7IGxhYmVsOiAnMDU6MTQ6MjcgUE0nLCB2YWx1ZTogJ2hoOm1tOnNzIGFhJyB9LFxuICAgICAgXSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZXREYXRlRnJvbVN0cmluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNvcnJlY3RseSBwYXJzZSBhIHZhbGlkIGRhdGUgc3RyaW5nIHdpdGggZGVmYXVsdCB0aW1lem9uZScsICgpID0+IHtcbiAgICAgIGNvbnN0IGRhdGUgPSBzZXJ2aWNlLmdldERhdGVGcm9tU3RyaW5nKCcxNC8wOC8yMDI0IDAyOjAwOjAwJyk7XG4gICAgICBleHBlY3QoZGF0ZS50b0lTT1N0cmluZygpKS50b0JlKCcyMDI0LTA4LTEzVDIzOjAwOjAwLjAwMFonKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY29ycmVjdGx5IHBhcnNlIGEgdmFsaWQgZGF0ZSBzdHJpbmcgd2l0aCBhbm90aGVyIGZvcm1hdCB3aXRoIGRlZmF1bHQgdGltZXpvbmUnLCAoKSA9PiB7XG4gICAgICBjb25zdCBkYXRlID0gc2VydmljZS5nZXREYXRlRnJvbVN0cmluZygnMTQuMDguMjAyNCAwMjowMDowMCcpO1xuICAgICAgZXhwZWN0KGRhdGUudG9JU09TdHJpbmcoKSkudG9CZSgnMjAyNC0wOC0xM1QyMzowMDowMC4wMDBaJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRocm93IGFuIGVycm9yIGZvciBhbiBpbnZhbGlkIGRhdGUgc3RyaW5nJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KCgpID0+IHNlcnZpY2UuZ2V0RGF0ZUZyb21TdHJpbmcoJ2ludmFsaWQgZGF0ZScpKS50b1Rocm93KCdJbnZhbGlkIGRhdGUgZm9ybWF0OiBpbnZhbGlkIGRhdGUnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldFByZWZlcnJlZERhdGVGb3JtYXQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdGhlIHByZWZlcnJlZCBkYXRlIGZvcm1hdCcsICgpID0+IHtcbiAgICAgIGV4cGVjdChzZXJ2aWNlLmdldFByZWZlcnJlZERhdGVGb3JtYXQoKSkudG9CZSgneXl5eS1NTS1kZCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0UHJlZmVycmVkVGltZUZvcm1hdCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiB0aGUgcHJlZmVycmVkIHRpbWUgZm9ybWF0JywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHNlcnZpY2UuZ2V0UHJlZmVycmVkVGltZUZvcm1hdCgpKS50b0JlKCdISDptbTpzcycpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0RGF0ZUFuZFRpbWUnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdGhlIGNvcnJlY3QgZGF0ZSBhbmQgdGltZSBmb3IgZGVmYXVsdCB0aW1lem9uZScsICgpID0+IHtcbiAgICAgIGNvbnN0IFtkYXRlLCB0aW1lXSA9IHNlcnZpY2UuZ2V0RGF0ZUFuZFRpbWUoKTtcbiAgICAgIGV4cGVjdChkYXRlKS50b0JlKCcyMDI0LTA4LTE0Jyk7XG4gICAgICBleHBlY3QodGltZSkudG9CZSgnMTc6MTQ6MjcnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIHRoZSBjb3JyZWN0IGRhdGUgYW5kIHRpbWUgZm9yIGEgc3BlY2lmaWVkIHRpbWV6b25lJywgKCkgPT4ge1xuICAgICAgY29uc3QgW2RhdGUsIHRpbWVdID0gc2VydmljZS5nZXREYXRlQW5kVGltZSgnRXVyb3BlL0tpZXYnKTtcbiAgICAgIGV4cGVjdChkYXRlKS50b0JlKCcyMDI0LTA4LTE0Jyk7XG4gICAgICBleHBlY3QodGltZSkudG9CZSgnMTc6MTQ6MjcnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2Zvcm1hdERhdGVUaW1lVG9EYXRlRm5zJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgY29ycmVjdGx5IGZvcm1hdCBkYXRlLXRpbWUgc3RyaW5nIHRvIGRhdGUtZm5zIGZvcm1hdCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGZvcm1hdHRlZCA9IHNlcnZpY2UuZm9ybWF0RGF0ZVRpbWVUb0RhdGVGbnMoJ1lZWVktTU0tREQgQScpO1xuICAgICAgZXhwZWN0KGZvcm1hdHRlZCkudG9CZSgneXl5eS1NTS1kZCBhYScpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sInZlcnNpb24iOjN9