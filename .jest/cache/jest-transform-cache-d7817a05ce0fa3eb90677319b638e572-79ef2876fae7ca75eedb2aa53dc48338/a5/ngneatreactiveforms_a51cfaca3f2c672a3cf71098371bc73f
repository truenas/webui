a2d8a9a3fcda617dd5a993aea056da8d
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ngneat_reactive_forms_exports = {};
__export(ngneat_reactive_forms_exports, {
  ControlValueAccessor: () => ControlValueAccessor,
  FormArray: () => FormArray,
  FormBuilder: () => FormBuilder,
  FormControl: () => FormControl,
  FormGroup: () => FormGroup,
  LocalStorageManager: () => LocalStorageManager,
  SessionStorageManager: () => SessionStorageManager,
  diff: () => diff,
  persistControl: () => persistControl,
  restoreControl: () => restoreControl
});
module.exports = __toCommonJS(ngneat_reactive_forms_exports);
var import_forms = require("@angular/forms");
var import_rxjs = require("rxjs");
var import_operators = require("rxjs/operators");
var i0 = __toESM(require("@angular/core"), 1);
var import_core = require("@angular/core");
function selectControlValue$(control, mapFn) {
  return control.value$.pipe((0, import_operators.map)(mapFn), (0, import_operators.distinctUntilChanged)());
}
function controlValueChanges$(control) {
  return (0, import_rxjs.merge)((0, import_rxjs.defer)(() => (0, import_rxjs.of)(control.getRawValue())), control.valueChanges.pipe((0, import_operators.map)(() => control.getRawValue())));
}
function controlStatus$(control, type) {
  return (0, import_rxjs.merge)((0, import_rxjs.defer)(() => (0, import_rxjs.of)(control[type])), control.statusChanges.pipe((0, import_operators.map)(() => control[type]), (0, import_operators.distinctUntilChanged)()));
}
function enableControl(control, enabled, opts) {
  if (enabled) {
    control.enable(opts);
  } else {
    control.disable(opts);
  }
}
function disableControl(control, disabled, opts) {
  enableControl(control, !disabled, opts);
}
function controlDisabledWhile(control, observable, opts) {
  return observable.subscribe((isDisabled) => disableControl(control, isDisabled, opts));
}
function controlEnabledWhile(control, observable, opts) {
  return observable.subscribe((isEnabled) => enableControl(control, isEnabled, opts));
}
function mergeErrors(existing, toAdd) {
  if (!existing && !toAdd) {
    return null;
  }
  return __spreadValues(__spreadValues({}, existing), toAdd);
}
function removeError(errors, key) {
  if (!errors) {
    return null;
  }
  const updatedErrors = __spreadValues({}, errors);
  delete updatedErrors[key];
  return Object.keys(updatedErrors).length > 0 ? updatedErrors : null;
}
function hasErrorAnd(and, control, error, path) {
  const hasError = control.hasError(error, !path || path.length === 0 ? void 0 : path);
  return hasError && control[and];
}
function controlErrorChanges$(control, errors$) {
  return (0, import_rxjs.merge)((0, import_rxjs.defer)(() => (0, import_rxjs.of)(control.errors)), errors$, control.valueChanges.pipe((0, import_operators.map)(() => control.errors), (0, import_operators.distinctUntilChanged)((a, b) => JSON.stringify(a) === JSON.stringify(b))));
}
function markAllDirty(control) {
  control.markAsDirty({ onlySelf: true });
  control._forEachChild((control2) => {
    var _a;
    return ((_a = control2.markAllAsDirty) == null ? void 0 : _a.call(control2)) || control2.markAsDirty({ onlySelf: true });
  });
}
class FormGroup extends import_forms.UntypedFormGroup {
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(controls, validatorOrOpts, asyncValidator);
    this.controls = controls;
    this.touchChanges = new import_rxjs.Subject();
    this.dirtyChanges = new import_rxjs.Subject();
    this.errorsSubject = new import_rxjs.Subject();
    this.touch$ = this.touchChanges.asObservable().pipe((0, import_operators.distinctUntilChanged)());
    this.dirty$ = this.dirtyChanges.asObservable().pipe((0, import_operators.distinctUntilChanged)());
    this.value$ = controlValueChanges$(this);
    this.disabled$ = controlStatus$(this, "disabled");
    this.enabled$ = controlStatus$(this, "enabled");
    this.invalid$ = controlStatus$(this, "invalid");
    this.valid$ = controlStatus$(this, "valid");
    this.status$ = controlStatus$(this, "status");
    this.errors$ = controlErrorChanges$(this, this.errorsSubject.asObservable());
  }
  select(mapFn) {
    return selectControlValue$(this, mapFn);
  }
  get(key) {
    return super.get(key);
  }
  setValue(valueOrObservable, options) {
    if ((0, import_rxjs.isObservable)(valueOrObservable)) {
      return valueOrObservable.subscribe((value) => super.setValue(value, options));
    }
    super.setValue(valueOrObservable, options);
  }
  patchValue(valueOrObservable, options) {
    if ((0, import_rxjs.isObservable)(valueOrObservable)) {
      return valueOrObservable.subscribe((value) => super.patchValue(value, options));
    }
    super.patchValue(valueOrObservable, options);
  }
  getRawValue() {
    return super.getRawValue();
  }
  markAsTouched(...opts) {
    super.markAsTouched(...opts);
    this.touchChanges.next(true);
  }
  markAsUntouched(...opts) {
    super.markAsUntouched(...opts);
    this.touchChanges.next(false);
  }
  markAsPristine(...opts) {
    super.markAsPristine(...opts);
    this.dirtyChanges.next(false);
  }
  markAsDirty(...opts) {
    super.markAsDirty(...opts);
    this.dirtyChanges.next(true);
  }
  markAllAsDirty() {
    markAllDirty(this);
  }
  setEnable(enable = true, opts) {
    enableControl(this, enable, opts);
  }
  setDisable(disable = true, opts) {
    disableControl(this, disable, opts);
  }
  disabledWhile(observable, options) {
    return controlDisabledWhile(this, observable, options);
  }
  enabledWhile(observable, options) {
    return controlEnabledWhile(this, observable, options);
  }
  reset(formState, options) {
    super.reset(formState, options);
  }
  setValidators(newValidators, options) {
    super.setValidators(newValidators);
    super.updateValueAndValidity(options);
  }
  setAsyncValidators(newValidator, options) {
    super.setAsyncValidators(newValidator);
    super.updateValueAndValidity(options);
  }
  getError(...params) {
    return super.getError(...params);
  }
  setErrors(...opts) {
    var _a;
    (_a = this.errorsSubject) == null ? void 0 : _a.next(opts[0]);
    return super.setErrors(...opts);
  }
  mergeErrors(errors, opts) {
    this.setErrors(mergeErrors(this.errors, errors), opts);
  }
  removeError(key, opts) {
    this.setErrors(removeError(this.errors, key), opts);
  }
  hasErrorAndTouched(error, path) {
    return hasErrorAnd("touched", this, error, path);
  }
  hasErrorAndDirty(error, path) {
    return hasErrorAnd("dirty", this, error, path);
  }
}
class FormControl extends import_forms.UntypedFormControl {
  constructor(formState, validatorOrOpts, asyncValidator) {
    super(formState, validatorOrOpts, asyncValidator);
    this.touchChanges = new import_rxjs.Subject();
    this.dirtyChanges = new import_rxjs.Subject();
    this.errorsSubject = new import_rxjs.Subject();
    this.touch$ = this.touchChanges.asObservable().pipe((0, import_operators.distinctUntilChanged)());
    this.dirty$ = this.dirtyChanges.asObservable().pipe((0, import_operators.distinctUntilChanged)());
    this.value$ = controlValueChanges$(this);
    this.disabled$ = controlStatus$(this, "disabled");
    this.enabled$ = controlStatus$(this, "enabled");
    this.invalid$ = controlStatus$(this, "invalid");
    this.valid$ = controlStatus$(this, "valid");
    this.status$ = controlStatus$(this, "status");
    this.errors$ = controlErrorChanges$(this, this.errorsSubject.asObservable());
  }
  setValue(valueOrObservable, options) {
    if ((0, import_rxjs.isObservable)(valueOrObservable)) {
      return valueOrObservable.subscribe((value) => super.setValue(value, options));
    }
    super.setValue(valueOrObservable, options);
  }
  patchValue(valueOrObservable, options) {
    if ((0, import_rxjs.isObservable)(valueOrObservable)) {
      return valueOrObservable.subscribe((value) => super.patchValue(value, options));
    }
    super.patchValue(valueOrObservable, options);
  }
  getRawValue() {
    return this.value;
  }
  markAsTouched(...opts) {
    super.markAsTouched(...opts);
    this.touchChanges.next(true);
  }
  markAsUntouched(...opts) {
    super.markAsUntouched(...opts);
    this.touchChanges.next(false);
  }
  markAsPristine(...opts) {
    super.markAsPristine(...opts);
    this.dirtyChanges.next(false);
  }
  markAsDirty(...opts) {
    super.markAsDirty(...opts);
    this.dirtyChanges.next(true);
  }
  setEnable(enable = true, opts) {
    enableControl(this, enable, opts);
  }
  setDisable(disable = true, opts) {
    disableControl(this, disable, opts);
  }
  disabledWhile(observable, options) {
    return controlDisabledWhile(this, observable, options);
  }
  enabledWhile(observable, options) {
    return controlEnabledWhile(this, observable, options);
  }
  reset(formState, options) {
    super.reset(formState, options);
  }
  setValidators(newValidators, options) {
    super.setValidators(newValidators);
    super.updateValueAndValidity(options);
  }
  setAsyncValidators(newValidator, options) {
    super.setAsyncValidators(newValidator);
    super.updateValueAndValidity(options);
  }
  getError(...params) {
    return super.getError(...params);
  }
  setErrors(...opts) {
    var _a;
    (_a = this.errorsSubject) == null ? void 0 : _a.next(opts[0]);
    return super.setErrors(...opts);
  }
  mergeErrors(errors, opts) {
    this.setErrors(mergeErrors(this.errors, errors), opts);
  }
  removeError(key, opts) {
    this.setErrors(removeError(this.errors, key), opts);
  }
  hasErrorAndTouched(error) {
    return hasErrorAnd("touched", this, error);
  }
  hasErrorAndDirty(error) {
    return hasErrorAnd("dirty", this, error);
  }
}
class FormArray extends import_forms.UntypedFormArray {
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(controls, validatorOrOpts, asyncValidator);
    this.controls = controls;
    this.touchChanges = new import_rxjs.Subject();
    this.dirtyChanges = new import_rxjs.Subject();
    this.errorsSubject = new import_rxjs.Subject();
    this.touch$ = this.touchChanges.asObservable().pipe((0, import_operators.distinctUntilChanged)());
    this.dirty$ = this.dirtyChanges.asObservable().pipe((0, import_operators.distinctUntilChanged)());
    this.value$ = controlValueChanges$(this);
    this.disabled$ = controlStatus$(this, "disabled");
    this.enabled$ = controlStatus$(this, "enabled");
    this.invalid$ = controlStatus$(this, "invalid");
    this.valid$ = controlStatus$(this, "valid");
    this.status$ = controlStatus$(this, "status");
    this.errors$ = controlErrorChanges$(this, this.errorsSubject.asObservable());
  }
  select(mapFn) {
    return this.value$.pipe((0, import_operators.map)(mapFn), (0, import_operators.distinctUntilChanged)());
  }
  setValue(valueOrObservable, options) {
    if ((0, import_rxjs.isObservable)(valueOrObservable)) {
      return valueOrObservable.subscribe((value) => super.setValue(value, options));
    }
    super.setValue(valueOrObservable, options);
  }
  patchValue(valueOrObservable, options) {
    if ((0, import_rxjs.isObservable)(valueOrObservable)) {
      return valueOrObservable.subscribe((value) => super.patchValue(value, options));
    }
    super.patchValue(valueOrObservable, options);
  }
  getRawValue() {
    return super.getRawValue();
  }
  push(control, options) {
    return super.push(control, options);
  }
  insert(index, control, options) {
    return super.insert(index, control, options);
  }
  setControl(index, control, options) {
    return super.setControl(index, control, options);
  }
  at(index) {
    return super.at(index);
  }
  remove(value, options) {
    this.removeWhen((v) => v.value === value);
  }
  removeWhen(predicate, options) {
    for (let i = this.length - 1; i >= 0; --i) {
      if (predicate(this.at(i))) {
        this.removeAt(i, options);
      }
    }
  }
  markAsTouched(...opts) {
    super.markAsTouched(...opts);
    this.touchChanges.next(true);
  }
  markAsUntouched(...opts) {
    super.markAsUntouched(...opts);
    this.touchChanges.next(false);
  }
  markAsPristine(...opts) {
    super.markAsPristine(...opts);
    this.dirtyChanges.next(false);
  }
  markAsDirty(...opts) {
    super.markAsDirty(...opts);
    this.dirtyChanges.next(true);
  }
  markAllAsDirty() {
    markAllDirty(this);
  }
  setEnable(enable = true, opts) {
    enableControl(this, enable, opts);
  }
  setDisable(disable = true, opts) {
    disableControl(this, disable, opts);
  }
  disabledWhile(observable, options) {
    return controlDisabledWhile(this, observable, options);
  }
  enabledWhile(observable, options) {
    return controlEnabledWhile(this, observable, options);
  }
  reset(formState, options) {
    super.reset(formState, options);
  }
  setValidators(newValidators, options) {
    super.setValidators(newValidators);
    super.updateValueAndValidity(options);
  }
  setAsyncValidators(newValidator, options) {
    super.setAsyncValidators(newValidator);
    super.updateValueAndValidity(options);
  }
  getError(...params) {
    return super.getError(...params);
  }
  setErrors(...opts) {
    var _a;
    (_a = this.errorsSubject) == null ? void 0 : _a.next(opts[0]);
    return super.setErrors(...opts);
  }
  mergeErrors(errors, opts) {
    this.setErrors(mergeErrors(this.errors, errors), opts);
  }
  removeError(key, opts) {
    this.setErrors(removeError(this.errors, key), opts);
  }
  hasErrorAndTouched(error, path) {
    return hasErrorAnd("touched", this, error, path);
  }
  hasErrorAndDirty(error, path) {
    return hasErrorAnd("dirty", this, error, path);
  }
}
class FormBuilder extends import_forms.UntypedFormBuilder {
  control(formState, validatorOrOpts, asyncValidator) {
    return new FormControl(formState, validatorOrOpts, asyncValidator);
  }
  array(controlsConfig, validatorOrOpts, asyncValidator) {
    const controls = controlsConfig.map((c) => this._createControl(c));
    return new FormArray(controls, validatorOrOpts, asyncValidator);
  }
  group(controlsConfig, options) {
    const controls = this._reduceControls(controlsConfig);
    let validators = null;
    let asyncValidators = null;
    let updateOn;
    if (options != null) {
      validators = options.validators != null ? options.validators : null;
      asyncValidators = options.asyncValidators != null ? options.asyncValidators : null;
      updateOn = options.updateOn != null ? options.updateOn : void 0;
    }
    return new FormGroup(controls, { asyncValidators, updateOn, validators });
  }
}
FormBuilder.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.0.1", ngImport: i0, type: FormBuilder, deps: null, target: i0.\u0275\u0275FactoryTarget.Injectable });
FormBuilder.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "14.0.1", ngImport: i0, type: FormBuilder, providedIn: "root" });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.1", ngImport: i0, type: FormBuilder, decorators: [{
  type: import_core.Injectable,
  args: [{ providedIn: "root" }]
}] });
const toArray = (object) => Object.keys(object);
const isArray = (value) => value && Array.isArray(value);
const isObject = (value) => typeof value === "object" && value !== null;
const isFormArray = (prev, curr) => isArray(curr) || isArray(prev);
const isFormGroup = (prev, curr) => isObject(curr) || isObject(prev);
const isFormControl = (prev, curr) => !isFormArray(prev, curr) && !isFormGroup(prev, curr);
const convertTypesToArray = (left, right) => [left, right];
function diff() {
  return (source$) => source$.pipe((0, import_operators.startWith)(void 0), (0, import_operators.pairwise)(), (0, import_operators.map)((control) => reduceControlValue(...control)), (0, import_operators.filter)((control) => control !== void 0));
}
function reduceControlValue(prev, curr) {
  if (prev === void 0) {
    return curr;
  }
  if (isFormControl(prev, curr)) {
    return prev === curr ? void 0 : curr;
  }
  if (isFormArray(prev, curr)) {
    const [left, right] = convertTypesToArray(prev, curr);
    return compareArraysContent(left, right) ? void 0 : curr;
  }
  return compareFormGroup(prev, curr);
}
function compareFormGroup(prev, curr) {
  const reduced = reduceFormGroup(prev, curr);
  return toArray(reduced).length === 0 ? void 0 : reduced;
}
function reduceFormGroup(prev, curr) {
  if (!prev) {
    return curr;
  }
  return toArray(curr).reduce((acc, key) => {
    const control = reduceControlValue(prev[key], curr[key]);
    if (control !== void 0) {
      acc[key] = control;
    }
    return acc;
  }, {});
}
function compareArraysContent(left, right) {
  left = Array.isArray(left) ? left : [];
  right = Array.isArray(right) ? right : [];
  return left.length === right.length && left.every((value) => right.includes(value));
}
function persistControl(control, key, { debounceTime: debounceTime2, manager, arrControlFactory, persistDisabledControls }) {
  const persistManager = manager || new LocalStorageManager();
  return restoreControl(control, key, persistManager, arrControlFactory).pipe((0, import_operators.switchMap)(() => persistValue$(control, key, {
    debounceTime: debounceTime2 || 250,
    manager: persistManager,
    persistDisabledControls
  })));
}
function persistValue$(control, key, options) {
  return control.valueChanges.pipe(
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    (0, import_operators.debounceTime)(options.debounceTime),
    (0, import_operators.switchMap)((value) => (
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      wrapIntoObservable(options.manager.setValue(key, options.persistDisabledControls ? control.getRawValue() : value))
    ))
  );
}
function restoreControl(control, key, manager, arrControlFactory) {
  return wrapIntoObservable(manager.getValue(key)).pipe((0, import_operators.take)(1), (0, import_operators.tap)((value) => {
    if (!value)
      return;
    if (arrControlFactory) {
      handleFormArrays(control, value, arrControlFactory);
    }
    control.patchValue(value, { emitEvent: false });
  }));
}
function handleFormArrays(control, formValue, arrControlFactory) {
  Object.keys(formValue).forEach((controlName) => {
    const value = formValue[controlName];
    if (Array.isArray(value) && control.get(controlName) instanceof import_forms.UntypedFormArray) {
      if (!arrControlFactory || arrControlFactory && !(controlName in arrControlFactory)) {
        throw new Error(`Please provide arrControlFactory for ${controlName}`);
      }
      const current = control.get(controlName);
      const fc = arrControlFactory[controlName];
      clearFormArray(current);
      value.forEach((v, i) => current.insert(i, fc(v)));
    }
  });
}
function clearFormArray(control) {
  while (control.length !== 0) {
    control.removeAt(0);
  }
}
function wrapIntoObservable(value) {
  if ((0, import_rxjs.isObservable)(value) || isPromise(value)) {
    return (0, import_rxjs.from)(value);
  }
  return (0, import_rxjs.of)(value);
}
function isPromise(value) {
  return typeof (value == null ? void 0 : value.then) === "function";
}
class LocalStorageManager {
  setValue(key, data) {
    localStorage.setItem(key, JSON.stringify(data));
    return data;
  }
  getValue(key) {
    return JSON.parse(localStorage.getItem(key) || "{}");
  }
}
class SessionStorageManager {
  setValue(key, data) {
    sessionStorage.setItem(key, JSON.stringify(data));
    return data;
  }
  getValue(key) {
    return JSON.parse(sessionStorage.getItem(key) || "{}");
  }
}
class ControlValueAccessor {
  constructor() {
    this.onChange = (value) => {
    };
    this.onTouched = () => {
    };
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
}
