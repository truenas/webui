03e27c82df2f3a15b69fedb161c85acf
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IxFormatterService = void 0;
const core_1 = require("@angular/core");
const window_helper_1 = require("app/helpers/window.helper");
let IxFormatterService = class IxFormatterService {
    constructor(window) {
        var _a, _b;
        this.window = window;
        this.protocol = ((_b = (_a = this.window) === null || _a === void 0 ? void 0 : _a.location) === null || _b === void 0 ? void 0 : _b.protocol) || 'http:';
        this.iecUnits = ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB'];
        /**
         * Formats any memory size in bytes to human readable string, e.g., '2147483648' to '2 GiB'
         * @param value The string to be formatted
         * @returns Formatted string
         */
        this.memorySizeFormatting = (value) => {
            if (!value) {
                return '';
            }
            value = value.toString();
            return !value || Number.isNaN(Number(value)) ? '' : this.convertBytesToHumanReadable(value, 2);
        };
        /**
         * Parses passed in human readable memory size string into a normalized value.
         * If no units are provided, MiB is used as default unit
         * @param value The value to be parsed
         * @returns The parsed value
         */
        this.memorySizeParsing = (value, postfix) => {
            if (!value) {
                return null;
            }
            const finalValue = `${value} ${!Number(value) ? '' : postfix || ''}`.trim();
            const humanStringToNum = this.convertHumanStringToNum(finalValue, true);
            // Default unit is MiB so if the user passed in no unit, we assume unit is MiB
            return (humanStringToNum !== Number(finalValue)) ? humanStringToNum : this.convertHumanStringToNum(finalValue + 'mb', true);
        };
        /**
         * Converts a number from bytes to the most natural human readable format
         * @param rawBytes Bytes to be converted
         * @param decimalPlaces Number of decimal places that the final value should be rounded off to
         * @param minUnits If no unit is provided, what minimum base unit should be assumed
         * @param hideBytes If the value is in bytes, should the 'B' sign be added
         * @returns A human readable string with appropriate units
         */
        this.convertBytesToHumanReadable = (rawBytes, decimalPlaces, minUnits, hideBytes) => {
            let i = 0;
            let units;
            let bytes = Number(rawBytes);
            const dec = decimalPlaces !== undefined ? decimalPlaces : 2;
            if (bytes >= 1024) {
                do {
                    bytes = bytes / 1024;
                    i++;
                } while (bytes >= 1024 && i < 4);
                units = this.iecUnits[i];
            }
            else if (minUnits) {
                units = minUnits;
            }
            else {
                units = hideBytes ? '' : 'B';
            }
            return `${parseFloat(bytes.toFixed(dec))} ${units}`;
        };
        /**
         * Converts a human readable size string with units into bytes. Any invalid letters result in null returned
         * @param hstr The string to be converted
         * @param dec Does the passed string has a decimal point values
         * @param allowedUnits allowedUnits should include any or all of 'bkmgtp', the first letters of KiB, Mib, etc.
         * The first letter is used as the default, so for 'gtp', an entered value of 256 becomes 256 GiB.
         * If you don't pass in allowedUnits, all of the above are accepted AND no unit is attached to an unlabeled number,
         * so 256 is considered 256 bytes.
         * @returns The passed human readable string converted into number of bytes
         */
        this.convertHumanStringToNum = (hstr, dec = false, allowedUnits) => {
            const { unit, number } = this.getNumberAndUnitFromHumanString(hstr, dec, allowedUnits);
            return number === null ? null : Number(number) * this.convertUnitToNum(unit);
        };
        /**
         * Normalize short units ("MB") or human units ("M") to IEC units ("MiB")
         * @param unitStr The unit string to be normalized
         * @returns Normalized unit string based on the passed value
         */
        this.normalizeUnit = (unitStr) => {
            // empty unit is valid, just return
            if (!unitStr) {
                return '';
            }
            const iecUnitsStr = this.iecUnits.join('|');
            const shortUnitsStr = this.iecUnits.map((unit) => {
                if (unit.length > 1) {
                    return unit.charAt(0) + unit.charAt(2);
                }
                return 'BYTES';
            }).join('|');
            const humanUnitsStr = this.iecUnits.map((unit) => unit.charAt(0)).join('|');
            const allUnitsStr = (iecUnitsStr + '|' + shortUnitsStr + '|' + humanUnitsStr).toUpperCase();
            const unitsRe = new RegExp('^\\s*(' + allUnitsStr + '){1}\\s*$');
            unitStr = unitStr.toUpperCase();
            if (unitStr.match(unitsRe)) {
                // always return IEC units
                // could take a parameter to return short or human units
                if (unitStr.toLowerCase() === 'b' || unitStr.toLowerCase() === 'bytes') {
                    return 'B';
                }
                return unitStr.charAt(0).toUpperCase() + 'iB';
            }
            return undefined;
        };
        /**
         * Convert IEC ("MiB"), short ("MB"), or human ("M") units to number of bytes. Unknown units are evaluated as 1
         * @param unitStr The unit string to be converted
         * @returns Number of bytes
         */
        this.convertUnitToNum = (unitStr) => {
            unitStr = this.normalizeUnit(unitStr);
            if (!unitStr) {
                return 1;
            }
            return (1024 ** (this.iecUnits.indexOf(unitStr)));
        };
        this.stringAsUrlParsing = (value) => {
            if (value.startsWith('http')) {
                return value;
            }
            return `${this.protocol}//${value}`;
        };
    }
    /**
     * Converts passed in human readable string into two parts. The digit value in numbers and the unit that's applied.
     * @param hstr The human readable size string
     * @param dec Does the value has decimal point values
     * @param allowedUnits allowedUnits should include any or all of 'bkmgtp', the first letters of KiB, Mib, etc.
     * The first letter is used as the default, so for 'gtp', an entered value of 256 becomes 256 GiB.
     * If you don't pass in allowedUnits, all of the above are accepted AND no unit is attached to an unlabeled number,
     * so 256 is considered 256 bytes.
     * @returns The passed human readable string converted into number and unit seperately
     */
    getNumberAndUnitFromHumanString(hstr, dec = false, allowedUnits) {
        let num = '0';
        let unit = '';
        // empty value is evaluated as zero
        if (!hstr) {
            return { number: null, unit: null };
        }
        // remove whitespace
        hstr = hstr.replace(/\s+/g, '');
        // get leading number
        let match = [];
        if (dec) {
            match = hstr.match(/^(\d+(\.\d+)?)/);
        }
        else {
            match = hstr.match(/^(\d+)/);
        }
        if (match && match.length > 1) {
            num = match[1];
        }
        else {
            // leading number is required
            return { number: null, unit: null };
        }
        // get optional unit
        unit = hstr.replace(num, '');
        if (!unit && allowedUnits) {
            unit = allowedUnits[0];
        }
        const normalizedUnit = this.normalizeUnit(unit);
        if (
        // error when unit is present and...
        (unit) && (
        // ...allowedUnits are passed in but unit is not in allowed Units
        (allowedUnits && !allowedUnits.toLowerCase().includes(unit[0].toLowerCase()))
            // ...when allowedUnits are not passed in and unit is not recognized
            || !normalizedUnit)) {
            return { number: null, unit: null };
        }
        return { number: num, unit: normalizedUnit };
    }
};
exports.IxFormatterService = IxFormatterService;
IxFormatterService.ctorParameters = () => [
    { type: Window, decorators: [{ type: core_1.Inject, args: [window_helper_1.WINDOW,] }] }
];
exports.IxFormatterService = IxFormatterService = __decorate([
    (0, core_1.Injectable)({ providedIn: 'root' })
], IxFormatterService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL21hY2Jvb2sva2FycG92LXdvcmsvVHJ1ZU5BUy93ZWJ1aS9zcmMvYXBwL21vZHVsZXMvZm9ybXMvaXgtZm9ybXMvc2VydmljZXMvaXgtZm9ybWF0dGVyLnNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsd0NBQW1EO0FBQ25ELDZEQUFtRDtBQUc1QyxJQUFNLGtCQUFrQixHQUF4QixNQUFNLGtCQUFrQjtJQUk3QixZQUFvQyxNQUFjOztRQUFkLFdBQU0sR0FBTixNQUFNLENBQVE7UUFIekMsYUFBUSxHQUFHLENBQUEsTUFBQSxNQUFBLElBQUksQ0FBQyxNQUFNLDBDQUFFLFFBQVEsMENBQUUsUUFBUSxLQUFJLE9BQU8sQ0FBQztRQUN0RCxhQUFRLEdBQXNCLENBQUMsR0FBRyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztRQUloRjs7OztXQUlHO1FBQ0gseUJBQW9CLEdBQXFDLENBQUMsS0FBc0IsRUFBRSxFQUFFO1lBQ2xGLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztnQkFDWCxPQUFPLEVBQUUsQ0FBQztZQUNaLENBQUM7WUFDRCxLQUFLLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ3pCLE9BQU8sQ0FBQyxLQUFLLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsMkJBQTJCLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ2pHLENBQUMsQ0FBQztRQUVGOzs7OztXQUtHO1FBQ0gsc0JBQWlCLEdBQW1ELENBQUMsS0FBYSxFQUFFLE9BQWUsRUFBRSxFQUFFO1lBQ3JHLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztnQkFDWCxPQUFPLElBQUksQ0FBQztZQUNkLENBQUM7WUFFRCxNQUFNLFVBQVUsR0FBRyxHQUFHLEtBQUssSUFBSSxDQUFDLE1B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S0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2pCLENBQUM7YUFBTSxDQUFDO1lBQ04sNkJBQTZCO1lBQzdCLE9BQU8sRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQztRQUN0QyxDQUFDO1FBRUQsb0JBQW9CO1FBQ3BCLElBQUksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUM3QixJQUFJLENBQUMsSUFBSSxJQUFJLFlBQVksRUFBRSxDQUFDO1lBQzFCLElBQUksR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDekIsQ0FBQztRQUVELE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDaEQ7UUFDRSxvQ0FBb0M7UUFDcEMsQ0FBQyxJQUFJLENBQUMsSUFBSTtRQUNSLGlFQUFpRTtRQUNqRSxDQUFDLFlBQVksSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7WUFDN0Usb0VBQW9FO2VBQ2pFLENBQUMsY0FBYyxDQUNuQixFQUNELENBQUM7WUFDRCxPQUFPLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUM7UUFDdEMsQ0FBQztRQUNELE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxjQUFjLEVBQUUsQ0FBQztJQUMvQyxDQUFDOztBQXJKVSxnREFBa0I7O3lDQUloQixhQUFNLFNBQUMsc0JBQU07OzZCQUpmLGtCQUFrQjtJQUQ5QixJQUFBLGlCQUFVLEVBQUMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLENBQUM7R0FDdEIsa0JBQWtCLENBOE05QiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvbWFjYm9vay9rYXJwb3Ytd29yay9UcnVlTkFTL3dlYnVpL3NyYy9hcHAvbW9kdWxlcy9mb3Jtcy9peC1mb3Jtcy9zZXJ2aWNlcy9peC1mb3JtYXR0ZXIuc2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFdJTkRPVyB9IGZyb20gJ2FwcC9oZWxwZXJzL3dpbmRvdy5oZWxwZXInO1xuXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxuZXhwb3J0IGNsYXNzIEl4Rm9ybWF0dGVyU2VydmljZSB7XG4gIHJlYWRvbmx5IHByb3RvY29sID0gdGhpcy53aW5kb3c/LmxvY2F0aW9uPy5wcm90b2NvbCB8fCAnaHR0cDonO1xuICByZWFkb25seSBpZWNVbml0czogcmVhZG9ubHkgc3RyaW5nW10gPSBbJ0InLCAnS2lCJywgJ01pQicsICdHaUInLCAnVGlCJywgJ1BpQiddO1xuXG4gIGNvbnN0cnVjdG9yKEBJbmplY3QoV0lORE9XKSBwcml2YXRlIHdpbmRvdzogV2luZG93KSB7fVxuXG4gIC8qKlxuICAgKiBGb3JtYXRzIGFueSBtZW1vcnkgc2l6ZSBpbiBieXRlcyB0byBodW1hbiByZWFkYWJsZSBzdHJpbmcsIGUuZy4sICcyMTQ3NDgzNjQ4JyB0byAnMiBHaUInXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgc3RyaW5nIHRvIGJlIGZvcm1hdHRlZFxuICAgKiBAcmV0dXJucyBGb3JtYXR0ZWQgc3RyaW5nXG4gICAqL1xuICBtZW1vcnlTaXplRm9ybWF0dGluZzogKHZhbDogc3RyaW5nIHwgbnVtYmVyKSA9PiBzdHJpbmcgPSAodmFsdWU6IHN0cmluZyB8IG51bWJlcikgPT4ge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIHJldHVybiAhdmFsdWUgfHwgTnVtYmVyLmlzTmFOKE51bWJlcih2YWx1ZSkpID8gJycgOiB0aGlzLmNvbnZlcnRCeXRlc1RvSHVtYW5SZWFkYWJsZSh2YWx1ZSwgMik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBwYXNzZWQgaW4gaHVtYW4gcmVhZGFibGUgbWVtb3J5IHNpemUgc3RyaW5nIGludG8gYSBub3JtYWxpemVkIHZhbHVlLlxuICAgKiBJZiBubyB1bml0cyBhcmUgcHJvdmlkZWQsIE1pQiBpcyB1c2VkIGFzIGRlZmF1bHQgdW5pdFxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIHBhcnNlZFxuICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIHZhbHVlXG4gICAqL1xuICBtZW1vcnlTaXplUGFyc2luZzogKHZhbDogc3RyaW5nLCBwb3N0Zml4VmFsdWU/OiBzdHJpbmcpID0+IG51bWJlciA9ICh2YWx1ZTogc3RyaW5nLCBwb3N0Zml4OiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBmaW5hbFZhbHVlID0gYCR7dmFsdWV9ICR7IU51bWJlcih2YWx1ZSkgPyAnJyA6IHBvc3RmaXggfHwgJyd9YC50cmltKCk7XG4gICAgY29uc3QgaHVtYW5TdHJpbmdUb051bSA9IHRoaXMuY29udmVydEh1bWFuU3RyaW5nVG9OdW0oZmluYWxWYWx1ZSwgdHJ1ZSk7XG5cbiAgICAvLyBEZWZhdWx0IHVuaXQgaXMgTWlCIHNvIGlmIHRoZSB1c2VyIHBhc3NlZCBpbiBubyB1bml0LCB3ZSBhc3N1bWUgdW5pdCBpcyBNaUJcbiAgICByZXR1cm4gKGh1bWFuU3RyaW5nVG9OdW0gIT09IE51bWJlcihmaW5hbFZhbHVlKSkgPyBodW1hblN0cmluZ1RvTnVtIDogdGhpcy5jb252ZXJ0SHVtYW5TdHJpbmdUb051bShmaW5hbFZhbHVlICsgJ21iJywgdHJ1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgbnVtYmVyIGZyb20gYnl0ZXMgdG8gdGhlIG1vc3QgbmF0dXJhbCBodW1hbiByZWFkYWJsZSBmb3JtYXRcbiAgICogQHBhcmFtIHJhd0J5dGVzIEJ5dGVzIHRvIGJlIGNvbnZlcnRlZFxuICAgKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhhdCB0aGUgZmluYWwgdmFsdWUgc2hvdWxkIGJlIHJvdW5kZWQgb2ZmIHRvXG4gICAqIEBwYXJhbSBtaW5Vbml0cyBJZiBubyB1bml0IGlzIHByb3ZpZGVkLCB3aGF0IG1pbmltdW0gYmFzZSB1bml0IHNob3VsZCBiZSBhc3N1bWVkXG4gICAqIEBwYXJhbSBoaWRlQnl0ZXMgSWYgdGhlIHZhbHVlIGlzIGluIGJ5dGVzLCBzaG91bGQgdGhlICdCJyBzaWduIGJlIGFkZGVkXG4gICAqIEByZXR1cm5zIEEgaHVtYW4gcmVhZGFibGUgc3RyaW5nIHdpdGggYXBwcm9wcmlhdGUgdW5pdHNcbiAgICovXG4gIGNvbnZlcnRCeXRlc1RvSHVtYW5SZWFkYWJsZSA9IChcbiAgICByYXdCeXRlczogbnVtYmVyIHwgc3RyaW5nLFxuICAgIGRlY2ltYWxQbGFjZXM/OiBudW1iZXIsXG4gICAgbWluVW5pdHM/OiBzdHJpbmcsXG4gICAgaGlkZUJ5dGVzPzogYm9vbGVhbixcbiAgKTogc3RyaW5nID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IHVuaXRzO1xuICAgIGxldCBieXRlcyA9IE51bWJlcihyYXdCeXRlcyk7XG5cbiAgICBjb25zdCBkZWMgPSBkZWNpbWFsUGxhY2VzICE9PSB1bmRlZmluZWQgPyBkZWNpbWFsUGxhY2VzIDogMjtcbiAgICBpZiAoYnl0ZXMgPj0gMTAyNCkge1xuICAgICAgZG8ge1xuICAgICAgICBieXRlcyA9IGJ5dGVzIC8gMTAyNDtcbiAgICAgICAgaSsrO1xuICAgICAgfSB3aGlsZSAoYnl0ZXMgPj0gMTAyNCAmJiBpIDwgNCk7XG4gICAgICB1bml0cyA9IHRoaXMuaWVjVW5pdHNbaV07XG4gICAgfSBlbHNlIGlmIChtaW5Vbml0cykge1xuICAgICAgdW5pdHMgPSBtaW5Vbml0cztcbiAgICB9IGVsc2Uge1xuICAgICAgdW5pdHMgPSBoaWRlQnl0ZXMgPyAnJyA6ICdCJztcbiAgICB9XG4gICAgcmV0dXJuIGAke3BhcnNlRmxvYXQoYnl0ZXMudG9GaXhlZChkZWMpKX0gJHt1bml0c31gO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIGh1bWFuIHJlYWRhYmxlIHNpemUgc3RyaW5nIHdpdGggdW5pdHMgaW50byBieXRlcy4gQW55IGludmFsaWQgbGV0dGVycyByZXN1bHQgaW4gbnVsbCByZXR1cm5lZFxuICAgKiBAcGFyYW0gaHN0ciBUaGUgc3RyaW5nIHRvIGJlIGNvbnZlcnRlZFxuICAgKiBAcGFyYW0gZGVjIERvZXMgdGhlIHBhc3NlZCBzdHJpbmcgaGFzIGEgZGVjaW1hbCBwb2ludCB2YWx1ZXNcbiAgICogQHBhcmFtIGFsbG93ZWRVbml0cyBhbGxvd2VkVW5pdHMgc2hvdWxkIGluY2x1ZGUgYW55IG9yIGFsbCBvZiAnYmttZ3RwJywgdGhlIGZpcnN0IGxldHRlcnMgb2YgS2lCLCBNaWIsIGV0Yy5cbiAgICogVGhlIGZpcnN0IGxldHRlciBpcyB1c2VkIGFzIHRoZSBkZWZhdWx0LCBzbyBmb3IgJ2d0cCcsIGFuIGVudGVyZWQgdmFsdWUgb2YgMjU2IGJlY29tZXMgMjU2IEdpQi5cbiAgICogSWYgeW91IGRvbid0IHBhc3MgaW4gYWxsb3dlZFVuaXRzLCBhbGwgb2YgdGhlIGFib3ZlIGFyZSBhY2NlcHRlZCBBTkQgbm8gdW5pdCBpcyBhdHRhY2hlZCB0byBhbiB1bmxhYmVsZWQgbnVtYmVyLFxuICAgKiBzbyAyNTYgaXMgY29uc2lkZXJlZCAyNTYgYnl0ZXMuXG4gICAqIEByZXR1cm5zIFRoZSBwYXNzZWQgaHVtYW4gcmVhZGFibGUgc3RyaW5nIGNvbnZlcnRlZCBpbnRvIG51bWJlciBvZiBieXRlc1xuICAgKi9cbiAgY29udmVydEh1bWFuU3RyaW5nVG9OdW0gPSAoXG4gICAgaHN0cjogc3RyaW5nLFxuICAgIGRlYyA9IGZhbHNlLFxuICAgIGFsbG93ZWRVbml0cz86ICdia21ndHAnIHwgJ2ttZ3RwJyB8ICdtZ3RwJyB8ICdndHAnIHwgJ3RwJyB8ICdwJyxcbiAgKTogbnVtYmVyID0+IHtcbiAgICBjb25zdCB7IHVuaXQsIG51bWJlciB9ID0gdGhpcy5nZXROdW1iZXJBbmRVbml0RnJvbUh1bWFuU3RyaW5nKGhzdHIsIGRlYywgYWxsb3dlZFVuaXRzKTtcblxuICAgIHJldHVybiBudW1iZXIgPT09IG51bGwgPyBudWxsIDogTnVtYmVyKG51bWJlcikgKiB0aGlzLmNvbnZlcnRVbml0VG9OdW0odW5pdCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHBhc3NlZCBpbiBodW1hbiByZWFkYWJsZSBzdHJpbmcgaW50byB0d28gcGFydHMuIFRoZSBkaWdpdCB2YWx1ZSBpbiBudW1iZXJzIGFuZCB0aGUgdW5pdCB0aGF0J3MgYXBwbGllZC5cbiAgICogQHBhcmFtIGhzdHIgVGhlIGh1bWFuIHJlYWRhYmxlIHNpemUgc3RyaW5nXG4gICAqIEBwYXJhbSBkZWMgRG9lcyB0aGUgdmFsdWUgaGFzIGRlY2ltYWwgcG9pbnQgdmFsdWVzXG4gICAqIEBwYXJhbSBhbGxvd2VkVW5pdHMgYWxsb3dlZFVuaXRzIHNob3VsZCBpbmNsdWRlIGFueSBvciBhbGwgb2YgJ2JrbWd0cCcsIHRoZSBmaXJzdCBsZXR0ZXJzIG9mIEtpQiwgTWliLCBldGMuXG4gICAqIFRoZSBmaXJzdCBsZXR0ZXIgaXMgdXNlZCBhcyB0aGUgZGVmYXVsdCwgc28gZm9yICdndHAnLCBhbiBlbnRlcmVkIHZhbHVlIG9mIDI1NiBiZWNvbWVzIDI1NiBHaUIuXG4gICAqIElmIHlvdSBkb24ndCBwYXNzIGluIGFsbG93ZWRVbml0cywgYWxsIG9mIHRoZSBhYm92ZSBhcmUgYWNjZXB0ZWQgQU5EIG5vIHVuaXQgaXMgYXR0YWNoZWQgdG8gYW4gdW5sYWJlbGVkIG51bWJlcixcbiAgICogc28gMjU2IGlzIGNvbnNpZGVyZWQgMjU2IGJ5dGVzLlxuICAgKiBAcmV0dXJucyBUaGUgcGFzc2VkIGh1bWFuIHJlYWRhYmxlIHN0cmluZyBjb252ZXJ0ZWQgaW50byBudW1iZXIgYW5kIHVuaXQgc2VwZXJhdGVseVxuICAgKi9cbiAgZ2V0TnVtYmVyQW5kVW5pdEZyb21IdW1hblN0cmluZyhcbiAgICBoc3RyOiBzdHJpbmcsXG4gICAgZGVjID0gZmFsc2UsXG4gICAgYWxsb3dlZFVuaXRzPzogJ2JrbWd0cCcgfCAna21ndHAnIHwgJ21ndHAnIHwgJ2d0cCcgfCAndHAnIHwgJ3AnLFxuICApOiB7IG51bWJlcjogc3RyaW5nOyB1bml0OiBzdHJpbmcgfSB7XG4gICAgbGV0IG51bSA9ICcwJztcbiAgICBsZXQgdW5pdCA9ICcnO1xuXG4gICAgLy8gZW1wdHkgdmFsdWUgaXMgZXZhbHVhdGVkIGFzIHplcm9cbiAgICBpZiAoIWhzdHIpIHtcbiAgICAgIHJldHVybiB7IG51bWJlcjogbnVsbCwgdW5pdDogbnVsbCB9O1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSB3aGl0ZXNwYWNlXG4gICAgaHN0ciA9IGhzdHIucmVwbGFjZSgvXFxzKy9nLCAnJyk7XG5cbiAgICAvLyBnZXQgbGVhZGluZyBudW1iZXJcbiAgICBsZXQgbWF0Y2ggPSBbXTtcbiAgICBpZiAoZGVjKSB7XG4gICAgICBtYXRjaCA9IGhzdHIubWF0Y2goL14oXFxkKyhcXC5cXGQrKT8pLyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdGNoID0gaHN0ci5tYXRjaCgvXihcXGQrKS8pO1xuICAgIH1cbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgbnVtID0gbWF0Y2hbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxlYWRpbmcgbnVtYmVyIGlzIHJlcXVpcmVkXG4gICAgICByZXR1cm4geyBudW1iZXI6IG51bGwsIHVuaXQ6IG51bGwgfTtcbiAgICB9XG5cbiAgICAvLyBnZXQgb3B0aW9uYWwgdW5pdFxuICAgIHVuaXQgPSBoc3RyLnJlcGxhY2UobnVtLCAnJyk7XG4gICAgaWYgKCF1bml0ICYmIGFsbG93ZWRVbml0cykge1xuICAgICAgdW5pdCA9IGFsbG93ZWRVbml0c1swXTtcbiAgICB9XG5cbiAgICBjb25zdCBub3JtYWxpemVkVW5pdCA9IHRoaXMubm9ybWFsaXplVW5pdCh1bml0KTtcbiAgICBpZiAoXG4gICAgICAvLyBlcnJvciB3aGVuIHVuaXQgaXMgcHJlc2VudCBhbmQuLi5cbiAgICAgICh1bml0KSAmJiAoXG4gICAgICAgIC8vIC4uLmFsbG93ZWRVbml0cyBhcmUgcGFzc2VkIGluIGJ1dCB1bml0IGlzIG5vdCBpbiBhbGxvd2VkIFVuaXRzXG4gICAgICAgIChhbGxvd2VkVW5pdHMgJiYgIWFsbG93ZWRVbml0cy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHVuaXRbMF0udG9Mb3dlckNhc2UoKSkpXG4gICAgICAgIC8vIC4uLndoZW4gYWxsb3dlZFVuaXRzIGFyZSBub3QgcGFzc2VkIGluIGFuZCB1bml0IGlzIG5vdCByZWNvZ25pemVkXG4gICAgICAgIHx8ICFub3JtYWxpemVkVW5pdFxuICAgICAgKVxuICAgICkge1xuICAgICAgcmV0dXJuIHsgbnVtYmVyOiBudWxsLCB1bml0OiBudWxsIH07XG4gICAgfVxuICAgIHJldHVybiB7IG51bWJlcjogbnVtLCB1bml0OiBub3JtYWxpemVkVW5pdCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSBzaG9ydCB1bml0cyAoXCJNQlwiKSBvciBodW1hbiB1bml0cyAoXCJNXCIpIHRvIElFQyB1bml0cyAoXCJNaUJcIilcbiAgICogQHBhcmFtIHVuaXRTdHIgVGhlIHVuaXQgc3RyaW5nIHRvIGJlIG5vcm1hbGl6ZWRcbiAgICogQHJldHVybnMgTm9ybWFsaXplZCB1bml0IHN0cmluZyBiYXNlZCBvbiB0aGUgcGFzc2VkIHZhbHVlXG4gICAqL1xuICBub3JtYWxpemVVbml0ID0gKHVuaXRTdHI6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgLy8gZW1wdHkgdW5pdCBpcyB2YWxpZCwganVzdCByZXR1cm5cbiAgICBpZiAoIXVuaXRTdHIpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBjb25zdCBpZWNVbml0c1N0ciA9IHRoaXMuaWVjVW5pdHMuam9pbignfCcpO1xuICAgIGNvbnN0IHNob3J0VW5pdHNTdHIgPSB0aGlzLmllY1VuaXRzLm1hcCgodW5pdCkgPT4ge1xuICAgICAgaWYgKHVuaXQubGVuZ3RoID4gMSkge1xuICAgICAgICByZXR1cm4gdW5pdC5jaGFyQXQoMCkgKyB1bml0LmNoYXJBdCgyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnQllURVMnO1xuICAgIH0pLmpvaW4oJ3wnKTtcbiAgICBjb25zdCBodW1hblVuaXRzU3RyID0gdGhpcy5pZWNVbml0cy5tYXAoKHVuaXQpID0+IHVuaXQuY2hhckF0KDApKS5qb2luKCd8Jyk7XG5cbiAgICBjb25zdCBhbGxVbml0c1N0ciA9IChpZWNVbml0c1N0ciArICd8JyArIHNob3J0VW5pdHNTdHIgKyAnfCcgKyBodW1hblVuaXRzU3RyKS50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0IHVuaXRzUmUgPSBuZXcgUmVnRXhwKCdeXFxcXHMqKCcgKyBhbGxVbml0c1N0ciArICcpezF9XFxcXHMqJCcpO1xuXG4gICAgdW5pdFN0ciA9IHVuaXRTdHIudG9VcHBlckNhc2UoKTtcbiAgICBpZiAodW5pdFN0ci5tYXRjaCh1bml0c1JlKSkge1xuICAgICAgLy8gYWx3YXlzIHJldHVybiBJRUMgdW5pdHNcbiAgICAgIC8vIGNvdWxkIHRha2UgYSBwYXJhbWV0ZXIgdG8gcmV0dXJuIHNob3J0IG9yIGh1bWFuIHVuaXRzXG4gICAgICBpZiAodW5pdFN0ci50b0xvd2VyQ2FzZSgpID09PSAnYicgfHwgdW5pdFN0ci50b0xvd2VyQ2FzZSgpID09PSAnYnl0ZXMnKSB7XG4gICAgICAgIHJldHVybiAnQic7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5pdFN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArICdpQic7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgSUVDIChcIk1pQlwiKSwgc2hvcnQgKFwiTUJcIiksIG9yIGh1bWFuIChcIk1cIikgdW5pdHMgdG8gbnVtYmVyIG9mIGJ5dGVzLiBVbmtub3duIHVuaXRzIGFyZSBldmFsdWF0ZWQgYXMgMVxuICAgKiBAcGFyYW0gdW5pdFN0ciBUaGUgdW5pdCBzdHJpbmcgdG8gYmUgY29udmVydGVkXG4gICAqIEByZXR1cm5zIE51bWJlciBvZiBieXRlc1xuICAgKi9cbiAgY29udmVydFVuaXRUb051bSA9ICh1bml0U3RyOiBzdHJpbmcpOiBudW1iZXIgPT4ge1xuICAgIHVuaXRTdHIgPSB0aGlzLm5vcm1hbGl6ZVVuaXQodW5pdFN0cik7XG4gICAgaWYgKCF1bml0U3RyKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuICgxMDI0ICoqICh0aGlzLmllY1VuaXRzLmluZGV4T2YodW5pdFN0cikpKTtcbiAgfTtcblxuICBzdHJpbmdBc1VybFBhcnNpbmcgPSAodmFsdWU6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBgJHt0aGlzLnByb3RvY29sfS8vJHt2YWx1ZX1gO1xuICB9O1xufVxuIl0sInZlcnNpb24iOjN9