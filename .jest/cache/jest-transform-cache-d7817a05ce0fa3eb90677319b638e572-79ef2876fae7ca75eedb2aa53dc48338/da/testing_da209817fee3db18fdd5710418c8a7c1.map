{
  "version": 3,
  "sources": ["/Users/macbook/karpov-work/TrueNAS/webui/node_modules/@angular/material/fesm2022/icon/testing.mjs"],
  "sourcesContent": ["import { ComponentHarness, HarnessPredicate } from '@angular/cdk/testing';\nimport * as i0 from '@angular/core';\nimport { Injectable, NgModule } from '@angular/core';\nimport { MatIconRegistry } from '@angular/material/icon';\nimport { of } from 'rxjs';\n\n/** Possible types of icons. */\nvar IconType;\n(function (IconType) {\n    IconType[IconType[\"SVG\"] = 0] = \"SVG\";\n    IconType[IconType[\"FONT\"] = 1] = \"FONT\";\n})(IconType || (IconType = {}));\n\n/** Harness for interacting with a standard mat-icon in tests. */\nclass MatIconHarness extends ComponentHarness {\n    /** The selector for the host element of a `MatIcon` instance. */\n    static { this.hostSelector = '.mat-icon'; }\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatIconHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which icon instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options = {}) {\n        return new HarnessPredicate(MatIconHarness, options)\n            .addOption('type', options.type, async (harness, type) => (await harness.getType()) === type)\n            .addOption('name', options.name, (harness, text) => HarnessPredicate.stringMatches(harness.getName(), text))\n            .addOption('namespace', options.namespace, (harness, text) => HarnessPredicate.stringMatches(harness.getNamespace(), text));\n    }\n    /** Gets the type of the icon. */\n    async getType() {\n        const type = await (await this.host()).getAttribute('data-mat-icon-type');\n        return type === 'svg' ? IconType.SVG : IconType.FONT;\n    }\n    /** Gets the name of the icon. */\n    async getName() {\n        const host = await this.host();\n        const nameFromDom = await host.getAttribute('data-mat-icon-name');\n        // If we managed to figure out the name from the attribute, use it.\n        if (nameFromDom) {\n            return nameFromDom;\n        }\n        // Some icons support defining the icon as a ligature.\n        // As a fallback, try to extract it from the DOM text.\n        if ((await this.getType()) === IconType.FONT) {\n            // Other directives may add content to the icon (e.g. `MatBadge`), however only the direct\n            // text nodes affect the name of the icon. Exclude all element descendants from the result.\n            const text = await host.text({ exclude: '*' });\n            // There are some internal cases where the icon name is wrapped in another node.\n            // Fall back to extracting the entire text if we ended up excluding everything above.\n            return text.length > 0 ? text : host.text();\n        }\n        return null;\n    }\n    /** Gets the namespace of the icon. */\n    async getNamespace() {\n        return (await this.host()).getAttribute('data-mat-icon-namespace');\n    }\n    /** Gets whether the icon is inline. */\n    async isInline() {\n        return (await this.host()).hasClass('mat-icon-inline');\n    }\n}\n\n/**\n * A null icon registry that must be imported to allow disabling of custom\n * icons.\n */\nclass FakeMatIconRegistry {\n    addSvgIcon() {\n        return this;\n    }\n    addSvgIconLiteral() {\n        return this;\n    }\n    addSvgIconInNamespace() {\n        return this;\n    }\n    addSvgIconLiteralInNamespace() {\n        return this;\n    }\n    addSvgIconSet() {\n        return this;\n    }\n    addSvgIconSetLiteral() {\n        return this;\n    }\n    addSvgIconSetInNamespace() {\n        return this;\n    }\n    addSvgIconSetLiteralInNamespace() {\n        return this;\n    }\n    registerFontClassAlias() {\n        return this;\n    }\n    classNameForFontAlias(alias) {\n        return alias;\n    }\n    getDefaultFontSetClass() {\n        return ['material-icons'];\n    }\n    getSvgIconFromUrl() {\n        return of(this._generateEmptySvg());\n    }\n    getNamedSvgIcon() {\n        return of(this._generateEmptySvg());\n    }\n    setDefaultFontSetClass() {\n        return this;\n    }\n    addSvgIconResolver() {\n        return this;\n    }\n    ngOnDestroy() { }\n    _generateEmptySvg() {\n        const emptySvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        emptySvg.classList.add('fake-testing-svg');\n        // Emulate real icon characteristics from `MatIconRegistry` so size remains consistent in tests.\n        emptySvg.setAttribute('fit', '');\n        emptySvg.setAttribute('height', '100%');\n        emptySvg.setAttribute('width', '100%');\n        emptySvg.setAttribute('preserveAspectRatio', 'xMidYMid meet');\n        emptySvg.setAttribute('focusable', 'false');\n        return emptySvg;\n    }\n    static { this.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: FakeMatIconRegistry, deps: [], target: i0.\u0275\u0275FactoryTarget.Injectable }); }\n    static { this.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: FakeMatIconRegistry }); }\n}\ni0.\u0275\u0275ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: FakeMatIconRegistry, decorators: [{\n            type: Injectable\n        }] });\n/** Import this module in tests to install the null icon registry. */\nclass MatIconTestingModule {\n    static { this.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: MatIconTestingModule, deps: [], target: i0.\u0275\u0275FactoryTarget.NgModule }); }\n    static { this.\u0275mod = i0.\u0275\u0275ngDeclareNgModule({ minVersion: \"14.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: MatIconTestingModule }); }\n    static { this.\u0275inj = i0.\u0275\u0275ngDeclareInjector({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: MatIconTestingModule, providers: [{ provide: MatIconRegistry, useClass: FakeMatIconRegistry }] }); }\n}\ni0.\u0275\u0275ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: MatIconTestingModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    providers: [{ provide: MatIconRegistry, useClass: FakeMatIconRegistry }],\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { FakeMatIconRegistry, IconType, MatIconHarness, MatIconTestingModule };\n//# sourceMappingURL=testing.mjs.map\n"],
  "mappings": "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",
  "names": ["IconType"]
}
