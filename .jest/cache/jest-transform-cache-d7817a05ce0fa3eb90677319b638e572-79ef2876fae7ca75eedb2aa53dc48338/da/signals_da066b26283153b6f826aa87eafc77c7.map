{
  "version": 3,
  "sources": ["/Users/macbook/karpov-work/TrueNAS/webui/node_modules/@angular/core/fesm2022/primitives/signals.mjs"],
  "sourcesContent": ["/**\n * @license Angular v18.2.4\n * (c) 2010-2024 Google LLC. https://angular.io/\n * License: MIT\n */\n\n/**\n * The default equality function used for `signal` and `computed`, which uses referential equality.\n */\nfunction defaultEquals(a, b) {\n    return Object.is(a, b);\n}\n\n/**\n * The currently active consumer `ReactiveNode`, if running code in a reactive context.\n *\n * Change this via `setActiveConsumer`.\n */\nlet activeConsumer = null;\nlet inNotificationPhase = false;\n/**\n * Global epoch counter. Incremented whenever a source signal is set.\n */\nlet epoch = 1;\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nconst SIGNAL = /* @__PURE__ */ Symbol('SIGNAL');\nfunction setActiveConsumer(consumer) {\n    const prev = activeConsumer;\n    activeConsumer = consumer;\n    return prev;\n}\nfunction getActiveConsumer() {\n    return activeConsumer;\n}\nfunction isInNotificationPhase() {\n    return inNotificationPhase;\n}\nfunction isReactive(value) {\n    return value[SIGNAL] !== undefined;\n}\nconst REACTIVE_NODE = {\n    version: 0,\n    lastCleanEpoch: 0,\n    dirty: false,\n    producerNode: undefined,\n    producerLastReadVersion: undefined,\n    producerIndexOfThis: undefined,\n    nextProducerIndex: 0,\n    liveConsumerNode: undefined,\n    liveConsumerIndexOfThis: undefined,\n    consumerAllowSignalWrites: false,\n    consumerIsAlwaysLive: false,\n    producerMustRecompute: () => false,\n    producerRecomputeValue: () => { },\n    consumerMarkedDirty: () => { },\n    consumerOnSignalRead: () => { },\n};\n/**\n * Called by implementations when a producer's signal is read.\n */\nfunction producerAccessed(node) {\n    if (inNotificationPhase) {\n        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode\n            ? `Assertion error: signal read during notification phase`\n            : '');\n    }\n    if (activeConsumer === null) {\n        // Accessed outside of a reactive context, so nothing to record.\n        return;\n    }\n    activeConsumer.consumerOnSignalRead(node);\n    // This producer is the `idx`th dependency of `activeConsumer`.\n    const idx = activeConsumer.nextProducerIndex++;\n    assertConsumerNode(activeConsumer);\n    if (idx < activeConsumer.producerNode.length && activeConsumer.producerNode[idx] !== node) {\n        // There's been a change in producers since the last execution of `activeConsumer`.\n        // `activeConsumer.producerNode[idx]` holds a stale dependency which will be be removed and\n        // replaced with `this`.\n        //\n        // If `activeConsumer` isn't live, then this is a no-op, since we can replace the producer in\n        // `activeConsumer.producerNode` directly. However, if `activeConsumer` is live, then we need\n        // to remove it from the stale producer's `liveConsumer`s.\n        if (consumerIsLive(activeConsumer)) {\n            const staleProducer = activeConsumer.producerNode[idx];\n            producerRemoveLiveConsumerAtIndex(staleProducer, activeConsumer.producerIndexOfThis[idx]);\n            // At this point, the only record of `staleProducer` is the reference at\n            // `activeConsumer.producerNode[idx]` which will be overwritten below.\n        }\n    }\n    if (activeConsumer.producerNode[idx] !== node) {\n        // We're a new dependency of the consumer (at `idx`).\n        activeConsumer.producerNode[idx] = node;\n        // If the active consumer is live, then add it as a live consumer. If not, then use 0 as a\n        // placeholder value.\n        activeConsumer.producerIndexOfThis[idx] = consumerIsLive(activeConsumer)\n            ? producerAddLiveConsumer(node, activeConsumer, idx)\n            : 0;\n    }\n    activeConsumer.producerLastReadVersion[idx] = node.version;\n}\n/**\n * Increment the global epoch counter.\n *\n * Called by source producers (that is, not computeds) whenever their values change.\n */\nfunction producerIncrementEpoch() {\n    epoch++;\n}\n/**\n * Ensure this producer's `version` is up-to-date.\n */\nfunction producerUpdateValueVersion(node) {\n    if (consumerIsLive(node) && !node.dirty) {\n        // A live consumer will be marked dirty by producers, so a clean state means that its version\n        // is guaranteed to be up-to-date.\n        return;\n    }\n    if (!node.dirty && node.lastCleanEpoch === epoch) {\n        // Even non-live consumers can skip polling if they previously found themselves to be clean at\n        // the current epoch, since their dependencies could not possibly have changed (such a change\n        // would've increased the epoch).\n        return;\n    }\n    if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n        // None of our producers report a change since the last time they were read, so no\n        // recomputation of our value is necessary, and we can consider ourselves clean.\n        node.dirty = false;\n        node.lastCleanEpoch = epoch;\n        return;\n    }\n    node.producerRecomputeValue(node);\n    // After recomputing the value, we're no longer dirty.\n    node.dirty = false;\n    node.lastCleanEpoch = epoch;\n}\n/**\n * Propagate a dirty notification to live consumers of this producer.\n */\nfunction producerNotifyConsumers(node) {\n    if (node.liveConsumerNode === undefined) {\n        return;\n    }\n    // Prevent signal reads when we're updating the graph\n    const prev = inNotificationPhase;\n    inNotificationPhase = true;\n    try {\n        for (const consumer of node.liveConsumerNode) {\n            if (!consumer.dirty) {\n                consumerMarkDirty(consumer);\n            }\n        }\n    }\n    finally {\n        inNotificationPhase = prev;\n    }\n}\n/**\n * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n * based on the current consumer context.\n */\nfunction producerUpdatesAllowed() {\n    return activeConsumer?.consumerAllowSignalWrites !== false;\n}\nfunction consumerMarkDirty(node) {\n    node.dirty = true;\n    producerNotifyConsumers(node);\n    node.consumerMarkedDirty?.(node);\n}\n/**\n * Prepare this consumer to run a computation in its reactive context.\n *\n * Must be called by subclasses which represent reactive computations, before those computations\n * begin.\n */\nfunction consumerBeforeComputation(node) {\n    node && (node.nextProducerIndex = 0);\n    return setActiveConsumer(node);\n}\n/**\n * Finalize this consumer's state after a reactive computation has run.\n *\n * Must be called by subclasses which represent reactive computations, after those computations\n * have finished.\n */\nfunction consumerAfterComputation(node, prevConsumer) {\n    setActiveConsumer(prevConsumer);\n    if (!node ||\n        node.producerNode === undefined ||\n        node.producerIndexOfThis === undefined ||\n        node.producerLastReadVersion === undefined) {\n        return;\n    }\n    if (consumerIsLive(node)) {\n        // For live consumers, we need to remove the producer -> consumer edge for any stale producers\n        // which weren't dependencies after the recomputation.\n        for (let i = node.nextProducerIndex; i < node.producerNode.length; i++) {\n            producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n        }\n    }\n    // Truncate the producer tracking arrays.\n    // Perf note: this is essentially truncating the length to `node.nextProducerIndex`, but\n    // benchmarking has shown that individual pop operations are faster.\n    while (node.producerNode.length > node.nextProducerIndex) {\n        node.producerNode.pop();\n        node.producerLastReadVersion.pop();\n        node.producerIndexOfThis.pop();\n    }\n}\n/**\n * Determine whether this consumer has any dependencies which have changed since the last time\n * they were read.\n */\nfunction consumerPollProducersForChange(node) {\n    assertConsumerNode(node);\n    // Poll producers for change.\n    for (let i = 0; i < node.producerNode.length; i++) {\n        const producer = node.producerNode[i];\n        const seenVersion = node.producerLastReadVersion[i];\n        // First check the versions. A mismatch means that the producer's value is known to have\n        // changed since the last time we read it.\n        if (seenVersion !== producer.version) {\n            return true;\n        }\n        // The producer's version is the same as the last time we read it, but it might itself be\n        // stale. Force the producer to recompute its version (calculating a new value if necessary).\n        producerUpdateValueVersion(producer);\n        // Now when we do this check, `producer.version` is guaranteed to be up to date, so if the\n        // versions still match then it has not changed since the last time we read it.\n        if (seenVersion !== producer.version) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Disconnect this consumer from the graph.\n */\nfunction consumerDestroy(node) {\n    assertConsumerNode(node);\n    if (consumerIsLive(node)) {\n        // Drop all connections from the graph to this node.\n        for (let i = 0; i < node.producerNode.length; i++) {\n            producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n        }\n    }\n    // Truncate all the arrays to drop all connection from this node to the graph.\n    node.producerNode.length =\n        node.producerLastReadVersion.length =\n            node.producerIndexOfThis.length =\n                0;\n    if (node.liveConsumerNode) {\n        node.liveConsumerNode.length = node.liveConsumerIndexOfThis.length = 0;\n    }\n}\n/**\n * Add `consumer` as a live consumer of this node.\n *\n * Note that this operation is potentially transitive. If this node becomes live, then it becomes\n * a live consumer of all of its current producers.\n */\nfunction producerAddLiveConsumer(node, consumer, indexOfThis) {\n    assertProducerNode(node);\n    if (node.liveConsumerNode.length === 0 && isConsumerNode(node)) {\n        // When going from 0 to 1 live consumers, we become a live consumer to our producers.\n        for (let i = 0; i < node.producerNode.length; i++) {\n            node.producerIndexOfThis[i] = producerAddLiveConsumer(node.producerNode[i], node, i);\n        }\n    }\n    node.liveConsumerIndexOfThis.push(indexOfThis);\n    return node.liveConsumerNode.push(consumer) - 1;\n}\n/**\n * Remove the live consumer at `idx`.\n */\nfunction producerRemoveLiveConsumerAtIndex(node, idx) {\n    assertProducerNode(node);\n    if (typeof ngDevMode !== 'undefined' && ngDevMode && idx >= node.liveConsumerNode.length) {\n        throw new Error(`Assertion error: active consumer index ${idx} is out of bounds of ${node.liveConsumerNode.length} consumers)`);\n    }\n    if (node.liveConsumerNode.length === 1 && isConsumerNode(node)) {\n        // When removing the last live consumer, we will no longer be live. We need to remove\n        // ourselves from our producers' tracking (which may cause consumer-producers to lose\n        // liveness as well).\n        for (let i = 0; i < node.producerNode.length; i++) {\n            producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n        }\n    }\n    // Move the last value of `liveConsumers` into `idx`. Note that if there's only a single\n    // live consumer, this is a no-op.\n    const lastIdx = node.liveConsumerNode.length - 1;\n    node.liveConsumerNode[idx] = node.liveConsumerNode[lastIdx];\n    node.liveConsumerIndexOfThis[idx] = node.liveConsumerIndexOfThis[lastIdx];\n    // Truncate the array.\n    node.liveConsumerNode.length--;\n    node.liveConsumerIndexOfThis.length--;\n    // If the index is still valid, then we need to fix the index pointer from the producer to this\n    // consumer, and update it from `lastIdx` to `idx` (accounting for the move above).\n    if (idx < node.liveConsumerNode.length) {\n        const idxProducer = node.liveConsumerIndexOfThis[idx];\n        const consumer = node.liveConsumerNode[idx];\n        assertConsumerNode(consumer);\n        consumer.producerIndexOfThis[idxProducer] = idx;\n    }\n}\nfunction consumerIsLive(node) {\n    return node.consumerIsAlwaysLive || (node?.liveConsumerNode?.length ?? 0) > 0;\n}\nfunction assertConsumerNode(node) {\n    node.producerNode ??= [];\n    node.producerIndexOfThis ??= [];\n    node.producerLastReadVersion ??= [];\n}\nfunction assertProducerNode(node) {\n    node.liveConsumerNode ??= [];\n    node.liveConsumerIndexOfThis ??= [];\n}\nfunction isConsumerNode(node) {\n    return node.producerNode !== undefined;\n}\n\n/**\n * Create a computed signal which derives a reactive value from an expression.\n */\nfunction createComputed(computation) {\n    const node = Object.create(COMPUTED_NODE);\n    node.computation = computation;\n    const computed = () => {\n        // Check if the value needs updating before returning it.\n        producerUpdateValueVersion(node);\n        // Record that someone looked at this signal.\n        producerAccessed(node);\n        if (node.value === ERRORED) {\n            throw node.error;\n        }\n        return node.value;\n    };\n    computed[SIGNAL] = node;\n    return computed;\n}\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst UNSET = /* @__PURE__ */ Symbol('UNSET');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst COMPUTING = /* @__PURE__ */ Symbol('COMPUTING');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst ERRORED = /* @__PURE__ */ Symbol('ERRORED');\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst COMPUTED_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        value: UNSET,\n        dirty: true,\n        error: null,\n        equal: defaultEquals,\n        producerMustRecompute(node) {\n            // Force a recomputation if there's no current value, or if the current value is in the\n            // process of being calculated (which should throw an error).\n            return node.value === UNSET || node.value === COMPUTING;\n        },\n        producerRecomputeValue(node) {\n            if (node.value === COMPUTING) {\n                // Our computation somehow led to a cyclic read of itself.\n                throw new Error('Detected cycle in computations.');\n            }\n            const oldValue = node.value;\n            node.value = COMPUTING;\n            const prevConsumer = consumerBeforeComputation(node);\n            let newValue;\n            try {\n                newValue = node.computation();\n            }\n            catch (err) {\n                newValue = ERRORED;\n                node.error = err;\n            }\n            finally {\n                consumerAfterComputation(node, prevConsumer);\n            }\n            if (oldValue !== UNSET &&\n                oldValue !== ERRORED &&\n                newValue !== ERRORED &&\n                node.equal(oldValue, newValue)) {\n                // No change to `valueVersion` - old and new values are\n                // semantically equivalent.\n                node.value = oldValue;\n                return;\n            }\n            node.value = newValue;\n            node.version++;\n        },\n    };\n})();\n\nfunction defaultThrowError() {\n    throw new Error();\n}\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError() {\n    throwInvalidWriteToSignalErrorFn();\n}\nfunction setThrowInvalidWriteToSignalError(fn) {\n    throwInvalidWriteToSignalErrorFn = fn;\n}\n\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\nlet postSignalSetFn = null;\n/**\n * Create a `Signal` that can be set or updated directly.\n */\nfunction createSignal(initialValue) {\n    const node = Object.create(SIGNAL_NODE);\n    node.value = initialValue;\n    const getter = (() => {\n        producerAccessed(node);\n        return node.value;\n    });\n    getter[SIGNAL] = node;\n    return getter;\n}\nfunction setPostSignalSetFn(fn) {\n    const prev = postSignalSetFn;\n    postSignalSetFn = fn;\n    return prev;\n}\nfunction signalGetFn() {\n    producerAccessed(this);\n    return this.value;\n}\nfunction signalSetFn(node, newValue) {\n    if (!producerUpdatesAllowed()) {\n        throwInvalidWriteToSignalError();\n    }\n    if (!node.equal(node.value, newValue)) {\n        node.value = newValue;\n        signalValueChanged(node);\n    }\n}\nfunction signalUpdateFn(node, updater) {\n    if (!producerUpdatesAllowed()) {\n        throwInvalidWriteToSignalError();\n    }\n    signalSetFn(node, updater(node.value));\n}\nfunction runPostSignalSetFn() {\n    postSignalSetFn?.();\n}\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst SIGNAL_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        equal: defaultEquals,\n        value: undefined,\n    };\n})();\nfunction signalValueChanged(node) {\n    node.version++;\n    producerIncrementEpoch();\n    producerNotifyConsumers(node);\n    postSignalSetFn?.();\n}\n\nfunction createWatch(fn, schedule, allowSignalWrites) {\n    const node = Object.create(WATCH_NODE);\n    if (allowSignalWrites) {\n        node.consumerAllowSignalWrites = true;\n    }\n    node.fn = fn;\n    node.schedule = schedule;\n    const registerOnCleanup = (cleanupFn) => {\n        node.cleanupFn = cleanupFn;\n    };\n    function isWatchNodeDestroyed(node) {\n        return node.fn === null && node.schedule === null;\n    }\n    function destroyWatchNode(node) {\n        if (!isWatchNodeDestroyed(node)) {\n            consumerDestroy(node); // disconnect watcher from the reactive graph\n            node.cleanupFn();\n            // nullify references to the integration functions to mark node as destroyed\n            node.fn = null;\n            node.schedule = null;\n            node.cleanupFn = NOOP_CLEANUP_FN;\n        }\n    }\n    const run = () => {\n        if (node.fn === null) {\n            // trying to run a destroyed watch is noop\n            return;\n        }\n        if (isInNotificationPhase()) {\n            throw new Error(`Schedulers cannot synchronously execute watches while scheduling.`);\n        }\n        node.dirty = false;\n        if (node.hasRun && !consumerPollProducersForChange(node)) {\n            return;\n        }\n        node.hasRun = true;\n        const prevConsumer = consumerBeforeComputation(node);\n        try {\n            node.cleanupFn();\n            node.cleanupFn = NOOP_CLEANUP_FN;\n            node.fn(registerOnCleanup);\n        }\n        finally {\n            consumerAfterComputation(node, prevConsumer);\n        }\n    };\n    node.ref = {\n        notify: () => consumerMarkDirty(node),\n        run,\n        cleanup: () => node.cleanupFn(),\n        destroy: () => destroyWatchNode(node),\n        [SIGNAL]: node,\n    };\n    return node.ref;\n}\nconst NOOP_CLEANUP_FN = () => { };\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst WATCH_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        consumerIsAlwaysLive: true,\n        consumerAllowSignalWrites: false,\n        consumerMarkedDirty: (node) => {\n            if (node.schedule !== null) {\n                node.schedule(node.ref);\n            }\n        },\n        hasRun: false,\n        cleanupFn: NOOP_CLEANUP_FN,\n    };\n})();\n\nfunction setAlternateWeakRefImpl(impl) {\n    // TODO: remove this function\n}\n\nexport { REACTIVE_NODE, SIGNAL, SIGNAL_NODE, consumerAfterComputation, consumerBeforeComputation, consumerDestroy, consumerMarkDirty, consumerPollProducersForChange, createComputed, createSignal, createWatch, defaultEquals, getActiveConsumer, isInNotificationPhase, isReactive, producerAccessed, producerIncrementEpoch, producerNotifyConsumers, producerUpdateValueVersion, producerUpdatesAllowed, runPostSignalSetFn, setActiveConsumer, setAlternateWeakRefImpl, setPostSignalSetFn, setThrowInvalidWriteToSignalError, signalSetFn, signalUpdateFn };\n//# sourceMappingURL=signals.mjs.map\n"],
  "mappings": "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",
  "names": ["node"]
}
