{
  "version": 3,
  "sources": ["/Users/macbook/karpov-work/TrueNAS/webui/node_modules/@angular/cdk/fesm2022/text-field.mjs"],
  "sourcesContent": ["import * as i1 from '@angular/cdk/platform';\nimport { normalizePassiveListenerOptions } from '@angular/cdk/platform';\nimport * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, Directive, Output, booleanAttribute, Optional, Inject, Input, NgModule } from '@angular/core';\nimport { coerceElement, coerceNumberProperty } from '@angular/cdk/coercion';\nimport { EMPTY, Subject, fromEvent } from 'rxjs';\nimport { auditTime, takeUntil } from 'rxjs/operators';\nimport { DOCUMENT } from '@angular/common';\n\n/** Options to pass to the animationstart listener. */\nconst listenerOptions = normalizePassiveListenerOptions({ passive: true });\n/**\n * An injectable service that can be used to monitor the autofill state of an input.\n * Based on the following blog post:\n * https://medium.com/@brunn/detecting-autofilled-fields-in-javascript-aed598d25da7\n */\nclass AutofillMonitor {\n    constructor(_platform, _ngZone) {\n        this._platform = _platform;\n        this._ngZone = _ngZone;\n        this._monitoredElements = new Map();\n    }\n    monitor(elementOrRef) {\n        if (!this._platform.isBrowser) {\n            return EMPTY;\n        }\n        const element = coerceElement(elementOrRef);\n        const info = this._monitoredElements.get(element);\n        if (info) {\n            return info.subject;\n        }\n        const result = new Subject();\n        const cssClass = 'cdk-text-field-autofilled';\n        const listener = ((event) => {\n            // Animation events fire on initial element render, we check for the presence of the autofill\n            // CSS class to make sure this is a real change in state, not just the initial render before\n            // we fire off events.\n            if (event.animationName === 'cdk-text-field-autofill-start' &&\n                !element.classList.contains(cssClass)) {\n                element.classList.add(cssClass);\n                this._ngZone.run(() => result.next({ target: event.target, isAutofilled: true }));\n            }\n            else if (event.animationName === 'cdk-text-field-autofill-end' &&\n                element.classList.contains(cssClass)) {\n                element.classList.remove(cssClass);\n                this._ngZone.run(() => result.next({ target: event.target, isAutofilled: false }));\n            }\n        });\n        this._ngZone.runOutsideAngular(() => {\n            element.addEventListener('animationstart', listener, listenerOptions);\n            element.classList.add('cdk-text-field-autofill-monitored');\n        });\n        this._monitoredElements.set(element, {\n            subject: result,\n            unlisten: () => {\n                element.removeEventListener('animationstart', listener, listenerOptions);\n            },\n        });\n        return result;\n    }\n    stopMonitoring(elementOrRef) {\n        const element = coerceElement(elementOrRef);\n        const info = this._monitoredElements.get(element);\n        if (info) {\n            info.unlisten();\n            info.subject.complete();\n            element.classList.remove('cdk-text-field-autofill-monitored');\n            element.classList.remove('cdk-text-field-autofilled');\n            this._monitoredElements.delete(element);\n        }\n    }\n    ngOnDestroy() {\n        this._monitoredElements.forEach((_info, element) => this.stopMonitoring(element));\n    }\n    static { this.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: AutofillMonitor, deps: [{ token: i1.Platform }, { token: i0.NgZone }], target: i0.\u0275\u0275FactoryTarget.Injectable }); }\n    static { this.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: AutofillMonitor, providedIn: 'root' }); }\n}\ni0.\u0275\u0275ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: AutofillMonitor, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: i1.Platform }, { type: i0.NgZone }] });\n/** A directive that can be used to monitor the autofill state of an input. */\nclass CdkAutofill {\n    constructor(_elementRef, _autofillMonitor) {\n        this._elementRef = _elementRef;\n        this._autofillMonitor = _autofillMonitor;\n        /** Emits when the autofill state of the element changes. */\n        this.cdkAutofill = new EventEmitter();\n    }\n    ngOnInit() {\n        this._autofillMonitor\n            .monitor(this._elementRef)\n            .subscribe(event => this.cdkAutofill.emit(event));\n    }\n    ngOnDestroy() {\n        this._autofillMonitor.stopMonitoring(this._elementRef);\n    }\n    static { this.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: CdkAutofill, deps: [{ token: i0.ElementRef }, { token: AutofillMonitor }], target: i0.\u0275\u0275FactoryTarget.Directive }); }\n    static { this.\u0275dir = i0.\u0275\u0275ngDeclareDirective({ minVersion: \"14.0.0\", version: \"18.2.0-next.2\", type: CdkAutofill, isStandalone: true, selector: \"[cdkAutofill]\", outputs: { cdkAutofill: \"cdkAutofill\" }, ngImport: i0 }); }\n}\ni0.\u0275\u0275ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: CdkAutofill, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkAutofill]',\n                    standalone: true,\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: AutofillMonitor }], propDecorators: { cdkAutofill: [{\n                type: Output\n            }] } });\n\n/** Directive to automatically resize a textarea to fit its content. */\nclass CdkTextareaAutosize {\n    /** Minimum amount of rows in the textarea. */\n    get minRows() {\n        return this._minRows;\n    }\n    set minRows(value) {\n        this._minRows = coerceNumberProperty(value);\n        this._setMinHeight();\n    }\n    /** Maximum amount of rows in the textarea. */\n    get maxRows() {\n        return this._maxRows;\n    }\n    set maxRows(value) {\n        this._maxRows = coerceNumberProperty(value);\n        this._setMaxHeight();\n    }\n    /** Whether autosizing is enabled or not */\n    get enabled() {\n        return this._enabled;\n    }\n    set enabled(value) {\n        // Only act if the actual value changed. This specifically helps to not run\n        // resizeToFitContent too early (i.e. before ngAfterViewInit)\n        if (this._enabled !== value) {\n            (this._enabled = value) ? this.resizeToFitContent(true) : this.reset();\n        }\n    }\n    get placeholder() {\n        return this._textareaElement.placeholder;\n    }\n    set placeholder(value) {\n        this._cachedPlaceholderHeight = undefined;\n        if (value) {\n            this._textareaElement.setAttribute('placeholder', value);\n        }\n        else {\n            this._textareaElement.removeAttribute('placeholder');\n        }\n        this._cacheTextareaPlaceholderHeight();\n    }\n    constructor(_elementRef, _platform, _ngZone, \n    /** @breaking-change 11.0.0 make document required */\n    document) {\n        this._elementRef = _elementRef;\n        this._platform = _platform;\n        this._ngZone = _ngZone;\n        this._destroyed = new Subject();\n        this._enabled = true;\n        /**\n         * Value of minRows as of last resize. If the minRows has decreased, the\n         * height of the textarea needs to be recomputed to reflect the new minimum. The maxHeight\n         * does not have the same problem because it does not affect the textarea's scrollHeight.\n         */\n        this._previousMinRows = -1;\n        this._isViewInited = false;\n        /** Handles `focus` and `blur` events. */\n        this._handleFocusEvent = (event) => {\n            this._hasFocus = event.type === 'focus';\n        };\n        this._document = document;\n        this._textareaElement = this._elementRef.nativeElement;\n    }\n    /** Sets the minimum height of the textarea as determined by minRows. */\n    _setMinHeight() {\n        const minHeight = this.minRows && this._cachedLineHeight ? `${this.minRows * this._cachedLineHeight}px` : null;\n        if (minHeight) {\n            this._textareaElement.style.minHeight = minHeight;\n        }\n    }\n    /** Sets the maximum height of the textarea as determined by maxRows. */\n    _setMaxHeight() {\n        const maxHeight = this.maxRows && this._cachedLineHeight ? `${this.maxRows * this._cachedLineHeight}px` : null;\n        if (maxHeight) {\n            this._textareaElement.style.maxHeight = maxHeight;\n        }\n    }\n    ngAfterViewInit() {\n        if (this._platform.isBrowser) {\n            // Remember the height which we started with in case autosizing is disabled\n            this._initialHeight = this._textareaElement.style.height;\n            this.resizeToFitContent();\n            this._ngZone.runOutsideAngular(() => {\n                const window = this._getWindow();\n                fromEvent(window, 'resize')\n                    .pipe(auditTime(16), takeUntil(this._destroyed))\n                    .subscribe(() => this.resizeToFitContent(true));\n                this._textareaElement.addEventListener('focus', this._handleFocusEvent);\n                this._textareaElement.addEventListener('blur', this._handleFocusEvent);\n            });\n            this._isViewInited = true;\n            this.resizeToFitContent(true);\n        }\n    }\n    ngOnDestroy() {\n        this._textareaElement.removeEventListener('focus', this._handleFocusEvent);\n        this._textareaElement.removeEventListener('blur', this._handleFocusEvent);\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    /**\n     * Cache the height of a single-row textarea if it has not already been cached.\n     *\n     * We need to know how large a single \"row\" of a textarea is in order to apply minRows and\n     * maxRows. For the initial version, we will assume that the height of a single line in the\n     * textarea does not ever change.\n     */\n    _cacheTextareaLineHeight() {\n        if (this._cachedLineHeight) {\n            return;\n        }\n        // Use a clone element because we have to override some styles.\n        let textareaClone = this._textareaElement.cloneNode(false);\n        textareaClone.rows = 1;\n        // Use `position: absolute` so that this doesn't cause a browser layout and use\n        // `visibility: hidden` so that nothing is rendered. Clear any other styles that\n        // would affect the height.\n        textareaClone.style.position = 'absolute';\n        textareaClone.style.visibility = 'hidden';\n        textareaClone.style.border = 'none';\n        textareaClone.style.padding = '0';\n        textareaClone.style.height = '';\n        textareaClone.style.minHeight = '';\n        textareaClone.style.maxHeight = '';\n        // In Firefox it happens that textarea elements are always bigger than the specified amount\n        // of rows. This is because Firefox tries to add extra space for the horizontal scrollbar.\n        // As a workaround that removes the extra space for the scrollbar, we can just set overflow\n        // to hidden. This ensures that there is no invalid calculation of the line height.\n        // See Firefox bug report: https://bugzilla.mozilla.org/show_bug.cgi?id=33654\n        textareaClone.style.overflow = 'hidden';\n        this._textareaElement.parentNode.appendChild(textareaClone);\n        this._cachedLineHeight = textareaClone.clientHeight;\n        textareaClone.remove();\n        // Min and max heights have to be re-calculated if the cached line height changes\n        this._setMinHeight();\n        this._setMaxHeight();\n    }\n    _measureScrollHeight() {\n        const element = this._textareaElement;\n        const previousMargin = element.style.marginBottom || '';\n        const isFirefox = this._platform.FIREFOX;\n        const needsMarginFiller = isFirefox && this._hasFocus;\n        const measuringClass = isFirefox\n            ? 'cdk-textarea-autosize-measuring-firefox'\n            : 'cdk-textarea-autosize-measuring';\n        // In some cases the page might move around while we're measuring the `textarea` on Firefox. We\n        // work around it by assigning a temporary margin with the same height as the `textarea` so that\n        // it occupies the same amount of space. See #23233.\n        if (needsMarginFiller) {\n            element.style.marginBottom = `${element.clientHeight}px`;\n        }\n        // Reset the textarea height to auto in order to shrink back to its default size.\n        // Also temporarily force overflow:hidden, so scroll bars do not interfere with calculations.\n        element.classList.add(measuringClass);\n        // The measuring class includes a 2px padding to workaround an issue with Chrome,\n        // so we account for that extra space here by subtracting 4 (2px top + 2px bottom).\n        const scrollHeight = element.scrollHeight - 4;\n        element.classList.remove(measuringClass);\n        if (needsMarginFiller) {\n            element.style.marginBottom = previousMargin;\n        }\n        return scrollHeight;\n    }\n    _cacheTextareaPlaceholderHeight() {\n        if (!this._isViewInited || this._cachedPlaceholderHeight != undefined) {\n            return;\n        }\n        if (!this.placeholder) {\n            this._cachedPlaceholderHeight = 0;\n            return;\n        }\n        const value = this._textareaElement.value;\n        this._textareaElement.value = this._textareaElement.placeholder;\n        this._cachedPlaceholderHeight = this._measureScrollHeight();\n        this._textareaElement.value = value;\n    }\n    ngDoCheck() {\n        if (this._platform.isBrowser) {\n            this.resizeToFitContent();\n        }\n    }\n    /**\n     * Resize the textarea to fit its content.\n     * @param force Whether to force a height recalculation. By default the height will be\n     *    recalculated only if the value changed since the last call.\n     */\n    resizeToFitContent(force = false) {\n        // If autosizing is disabled, just skip everything else\n        if (!this._enabled) {\n            return;\n        }\n        this._cacheTextareaLineHeight();\n        this._cacheTextareaPlaceholderHeight();\n        // If we haven't determined the line-height yet, we know we're still hidden and there's no point\n        // in checking the height of the textarea.\n        if (!this._cachedLineHeight) {\n            return;\n        }\n        const textarea = this._elementRef.nativeElement;\n        const value = textarea.value;\n        // Only resize if the value or minRows have changed since these calculations can be expensive.\n        if (!force && this._minRows === this._previousMinRows && value === this._previousValue) {\n            return;\n        }\n        const scrollHeight = this._measureScrollHeight();\n        const height = Math.max(scrollHeight, this._cachedPlaceholderHeight || 0);\n        // Use the scrollHeight to know how large the textarea *would* be if fit its entire value.\n        textarea.style.height = `${height}px`;\n        this._ngZone.runOutsideAngular(() => {\n            if (typeof requestAnimationFrame !== 'undefined') {\n                requestAnimationFrame(() => this._scrollToCaretPosition(textarea));\n            }\n            else {\n                setTimeout(() => this._scrollToCaretPosition(textarea));\n            }\n        });\n        this._previousValue = value;\n        this._previousMinRows = this._minRows;\n    }\n    /**\n     * Resets the textarea to its original size\n     */\n    reset() {\n        // Do not try to change the textarea, if the initialHeight has not been determined yet\n        // This might potentially remove styles when reset() is called before ngAfterViewInit\n        if (this._initialHeight !== undefined) {\n            this._textareaElement.style.height = this._initialHeight;\n        }\n    }\n    _noopInputHandler() {\n        // no-op handler that ensures we're running change detection on input events.\n    }\n    /** Access injected document if available or fallback to global document reference */\n    _getDocument() {\n        return this._document || document;\n    }\n    /** Use defaultView of injected document if available or fallback to global window reference */\n    _getWindow() {\n        const doc = this._getDocument();\n        return doc.defaultView || window;\n    }\n    /**\n     * Scrolls a textarea to the caret position. On Firefox resizing the textarea will\n     * prevent it from scrolling to the caret position. We need to re-set the selection\n     * in order for it to scroll to the proper position.\n     */\n    _scrollToCaretPosition(textarea) {\n        const { selectionStart, selectionEnd } = textarea;\n        // IE will throw an \"Unspecified error\" if we try to set the selection range after the\n        // element has been removed from the DOM. Assert that the directive hasn't been destroyed\n        // between the time we requested the animation frame and when it was executed.\n        // Also note that we have to assert that the textarea is focused before we set the\n        // selection range. Setting the selection range on a non-focused textarea will cause\n        // it to receive focus on IE and Edge.\n        if (!this._destroyed.isStopped && this._hasFocus) {\n            textarea.setSelectionRange(selectionStart, selectionEnd);\n        }\n    }\n    static { this.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: CdkTextareaAutosize, deps: [{ token: i0.ElementRef }, { token: i1.Platform }, { token: i0.NgZone }, { token: DOCUMENT, optional: true }], target: i0.\u0275\u0275FactoryTarget.Directive }); }\n    static { this.\u0275dir = i0.\u0275\u0275ngDeclareDirective({ minVersion: \"16.1.0\", version: \"18.2.0-next.2\", type: CdkTextareaAutosize, isStandalone: true, selector: \"textarea[cdkTextareaAutosize]\", inputs: { minRows: [\"cdkAutosizeMinRows\", \"minRows\"], maxRows: [\"cdkAutosizeMaxRows\", \"maxRows\"], enabled: [\"cdkTextareaAutosize\", \"enabled\", booleanAttribute], placeholder: \"placeholder\" }, host: { attributes: { \"rows\": \"1\" }, listeners: { \"input\": \"_noopInputHandler()\" }, classAttribute: \"cdk-textarea-autosize\" }, exportAs: [\"cdkTextareaAutosize\"], ngImport: i0 }); }\n}\ni0.\u0275\u0275ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: CdkTextareaAutosize, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'textarea[cdkTextareaAutosize]',\n                    exportAs: 'cdkTextareaAutosize',\n                    host: {\n                        'class': 'cdk-textarea-autosize',\n                        // Textarea elements that have the directive applied should have a single row by default.\n                        // Browsers normally show two rows by default and therefore this limits the minRows binding.\n                        'rows': '1',\n                        '(input)': '_noopInputHandler()',\n                    },\n                    standalone: true,\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i1.Platform }, { type: i0.NgZone }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }], propDecorators: { minRows: [{\n                type: Input,\n                args: ['cdkAutosizeMinRows']\n            }], maxRows: [{\n                type: Input,\n                args: ['cdkAutosizeMaxRows']\n            }], enabled: [{\n                type: Input,\n                args: [{ alias: 'cdkTextareaAutosize', transform: booleanAttribute }]\n            }], placeholder: [{\n                type: Input\n            }] } });\n\nclass TextFieldModule {\n    static { this.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: TextFieldModule, deps: [], target: i0.\u0275\u0275FactoryTarget.NgModule }); }\n    static { this.\u0275mod = i0.\u0275\u0275ngDeclareNgModule({ minVersion: \"14.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: TextFieldModule, imports: [CdkAutofill, CdkTextareaAutosize], exports: [CdkAutofill, CdkTextareaAutosize] }); }\n    static { this.\u0275inj = i0.\u0275\u0275ngDeclareInjector({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: TextFieldModule }); }\n}\ni0.\u0275\u0275ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: TextFieldModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [CdkAutofill, CdkTextareaAutosize],\n                    exports: [CdkAutofill, CdkTextareaAutosize],\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AutofillMonitor, CdkAutofill, CdkTextareaAutosize, TextFieldModule };\n//# sourceMappingURL=text-field.mjs.map\n"],
  "mappings": "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",
  "names": ["document", "window"]
}
